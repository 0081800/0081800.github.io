<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Notes on Taking Smart Notes With Org-mode</title>
    <link>https://notes.0081800.xyz/notes/</link>
    <description>Recent content in Notes on Taking Smart Notes With Org-mode</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 11 Sep 2023 14:24:00 +0800</lastBuildDate><atom:link href="https://notes.0081800.xyz/notes/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>FreeBSD</title>
      <link>https://notes.0081800.xyz/notes/20230911142403-freebsd/</link>
      <pubDate>Mon, 11 Sep 2023 14:24:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230911142403-freebsd/</guid>
      <description></description>
    </item>
    
    <item>
      <title>FreeBSD</title>
      <link>https://notes.0081800.xyz/notes/20230911142417-freebsd/</link>
      <pubDate>Mon, 11 Sep 2023 14:24:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230911142417-freebsd/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Building a FreeBSD backup server</title>
      <link>https://notes.0081800.xyz/notes/20230911142350-building_a_freebsd_backup_server/</link>
      <pubDate>Mon, 11 Sep 2023 14:23:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230911142350-building_a_freebsd_backup_server/</guid>
      <description>TAGS: FreeBSD, NAS Source: “Building a FreeBSD Backup Server.” Accessed September 11, 2023. https://ogris.de/howtos/freebsd-backup-server.html. $ zfs create -quota=1T data/timemachine [global] workgroup = WORKGROUP security = user netbios name = backup server string = backup.your-local-domain.invalid hostname lookups = yes load printers = no show add printer wizard = no time server = yes map to guest = Bad User use mmap = yes dos charset = 850 unix charset = UTF-8 mangled names = no log level = 0 vfs objects = fruit streams_xattr zfsacl fruit:model = MacPro fruit:resource = file fruit:metadata = netatalk ; time machines [macbook] path = /data/timemachine read only = no use sendfile = yes browseable = no hosts allow = macbook.</description>
    </item>
    
    <item>
      <title>Sui</title>
      <link>https://notes.0081800.xyz/notes/20230911093102-sui/</link>
      <pubDate>Mon, 11 Sep 2023 09:31:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230911093102-sui/</guid>
      <description> TAGS: Blockchain </description>
    </item>
    
    <item>
      <title>Sui Move Call</title>
      <link>https://notes.0081800.xyz/notes/20230911093008-sui_move_call/</link>
      <pubDate>Mon, 11 Sep 2023 09:30:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230911093008-sui_move_call/</guid>
      <description> TAGS: Sui POST http://127.0.0.1:9000 Content-Type: application/json { &amp;#34;jsonrpc&amp;#34;: &amp;#34;2.0&amp;#34;, &amp;#34;method&amp;#34;: &amp;#34;sui_moveCall&amp;#34;, &amp;#34;params&amp;#34;: [ &amp;#34;0x1&amp;#34;, &amp;#34;0xc8&amp;#34;, &amp;#34;obc_dao&amp;#34;, &amp;#34;voting_delay&amp;#34;, &amp;#34; ] } </description>
    </item>
    
    <item>
      <title>Uniswap V3 Event Log</title>
      <link>https://notes.0081800.xyz/notes/20230731163157-uniswap_v3_event_log/</link>
      <pubDate>Mon, 31 Jul 2023 16:31:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230731163157-uniswap_v3_event_log/</guid>
      <description> tags: Uniswap V3, Ethereum POST https://rpc.ankr.com/eth Content-Type: application/json { &amp;#34;jsonrpc&amp;#34;: &amp;#34;2.0&amp;#34;, &amp;#34;id&amp;#34;: 1, &amp;#34;method&amp;#34;: &amp;#34;eth_getTransactionReceipt&amp;#34;, &amp;#34;params&amp;#34;: [&amp;#34;0xeedf302cc12f4b7194742694aabec075c1c229f7b9d8e57a53c44c992bc6690c&amp;#34;] } </description>
    </item>
    
    <item>
      <title>The Best Way To Launch Your Startup</title>
      <link>https://notes.0081800.xyz/notes/20230726091549-the_best_way_to_launch_your_startup/</link>
      <pubDate>Wed, 26 Jul 2023 09:15:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230726091549-the_best_way_to_launch_your_startup/</guid>
      <description>tags: Microstartup source: The Best Way To Launch Your Startup | Startup School, 2023. https://www.youtube.com/watch?v=u36A-YTxiOw. Emphasis Launch it ASAP, and launch it again and again.
How to Write a Pitch 1-line description
to introduce your bussiness:
Tell WHAT, not WHY(maybe later). What problem it it solving, and for who. X for Y may not the best sentence. Ways: Launch in Different Channels Silent Launch Launch to Friends and family Launch to Strangers Online Community Lanuch: HN Waitlist Launch: Domain/Landing Page/Email list.</description>
    </item>
    
    <item>
      <title>Should I read papers</title>
      <link>https://notes.0081800.xyz/notes/20230719091127-should_i_read_papers/</link>
      <pubDate>Wed, 19 Jul 2023 09:11:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230719091127-should_i_read_papers/</guid>
      <description>tags: Papers source: “Mrb: Should I Read Papers?” Accessed February 20, 2023. https://michaelrbernste.in/2014/10/21/should-i-read-papers.html. Yes, but reading a paper isn&amp;rsquo;t the same as reading a blogpost or a novel.
A paper could be an idea captured by someone, or the result of a life&amp;rsquo;s work, or anything in between.
You might need to read it bit by bit, again and again.</description>
    </item>
    
    <item>
      <title>Software Engineers Should Read Academic Papers</title>
      <link>https://notes.0081800.xyz/notes/20230717111715-software_engineers_should_read_academic_papers/</link>
      <pubDate>Mon, 17 Jul 2023 11:17:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230717111715-software_engineers_should_read_academic_papers/</guid>
      <description>tags: Papers source: Al-Ansari, Khaled. “Software Engineers Should Read Academic Papers.” Medium (blog), July 15, 2023. https://medium.com/@KhaledElAnsari/software-engineers-should-read-academic-papers-9a6ee6ebc40d. There are some benefits of reading academic papers:
Structured content can enhance your technical writing, you can learn structured writing.
(Reading - Writing - Reviewing) cycle making you a better reader and reviewer.
Reading to gain information. Structured writing make review easier. Better deading and writing make you a better reviewer. Bridge the industry and the academic field.</description>
    </item>
    
    <item>
      <title>Solana Off-Chain Message Signing</title>
      <link>https://notes.0081800.xyz/notes/20230615180334-solana_off_chain_message_signing/</link>
      <pubDate>Thu, 15 Jun 2023 18:03:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230615180334-solana_off_chain_message_signing/</guid>
      <description> tags: Solana source: https://github.com/solana-labs/solana/blob/eabe1070667e87f447b9cb892e2d916ca5b68e34/sdk/src/offchain_message.rs#L237-L240 /// Serialize the off-chain message to bytes including full header pub fn serialize(&amp;amp;self) -&amp;gt; Result&amp;lt;Vec&amp;lt;u8&amp;gt;, SanitizeError&amp;gt; { // serialize signing domain let mut data = Self::SIGNING_DOMAIN.to_vec(); // serialize version and call version specific serializer match self { Self::V0(msg) =&amp;gt; { data.push(0); msg.serialize(&amp;amp;mut data)?; } } Ok(data) } </description>
    </item>
    
    <item>
      <title>Ethereum Execution Layer</title>
      <link>https://notes.0081800.xyz/notes/20230614091826-ethereum_execution_layer/</link>
      <pubDate>Wed, 14 Jun 2023 09:18:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230614091826-ethereum_execution_layer/</guid>
      <description> tags: Ethereum Networking Layer </description>
    </item>
    
    <item>
      <title>Ethereum Sub-protocols</title>
      <link>https://notes.0081800.xyz/notes/20230614091155-ethereum_sub_protocols/</link>
      <pubDate>Wed, 14 Jun 2023 09:11:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230614091155-ethereum_sub_protocols/</guid>
      <description> tags: Ethereum Networking, Ethereum Execution Layer </description>
    </item>
    
    <item>
      <title>Ethereum Wire Protocol</title>
      <link>https://notes.0081800.xyz/notes/20230614091142-ethereum_wire_protocol/</link>
      <pubDate>Wed, 14 Jun 2023 09:11:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230614091142-ethereum_wire_protocol/</guid>
      <description>tags: Ethereum Sub-protocols, Ethereum Simulator Node Started when a RLPx session had initiated. Three main tasks before switch to PoS:
Chain synchronization Block propagation Transaction exchange: exchange pending transaction between nodes. Only transaction exchange remit after switch to PoS.</description>
    </item>
    
    <item>
      <title>Ethereum DevP2P</title>
      <link>https://notes.0081800.xyz/notes/20230614090850-ethereum_devp2p/</link>
      <pubDate>Wed, 14 Jun 2023 09:08:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230614090850-ethereum_devp2p/</guid>
      <description>tags: Ethereum Networking, Ethereum Execution Layer Basic stack for p2p networking. Initiating RLPx Session.
RLPX Session Communicate messages that encoded in RLP between peers.</description>
    </item>
    
    <item>
      <title>Ethereum Networking Layer</title>
      <link>https://notes.0081800.xyz/notes/20230614090110-ethereum_networking/</link>
      <pubDate>Wed, 14 Jun 2023 09:01:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230614090110-ethereum_networking/</guid>
      <description> tags: Ethereum source: https://ethereum.org/en/developers/docs/networking-layer/ </description>
    </item>
    
    <item>
      <title>Ethereum Discovery Nodes</title>
      <link>https://notes.0081800.xyz/notes/20230614090056-ethereum_discovery_nodes/</link>
      <pubDate>Wed, 14 Jun 2023 09:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230614090056-ethereum_discovery_nodes/</guid>
      <description>tags: Ethereum Networking, Ethereum Simulator Node Boot nodes Using a small set that hardcoded bootnodes to bootstrap.
Protocol Kademlia a modified form of Distributed Hash Table.
Steps to join the network start client &amp;ndash;&amp;gt; connect to bootnode &amp;ndash;&amp;gt; bond to bootnode &amp;ndash;&amp;gt; find neighbours &amp;ndash;&amp;gt; bond to neighbours</description>
    </item>
    
    <item>
      <title>How is a Transaction Broadcasted</title>
      <link>https://notes.0081800.xyz/notes/20230612100850-how_is_a_transaction_broadcasted/</link>
      <pubDate>Mon, 12 Jun 2023 10:08:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230612100850-how_is_a_transaction_broadcasted/</guid>
      <description>tags: Ethereum Simulator Node, Ethereum Execution Layer Node Side: Receive pending transactions If we want to broadcast our transactions to the network in Ethereum, two RPC calls are involved:
https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction So let&amp;rsquo;s follow those two calls to track how a transaction is broadcasted. Those two corresponding implementations are defined at internal/ethapi/api.go:
SendTransaction SendRawTransaction And both of them are pointing to SubmitTransaction, which calls SendTx to put transaction into the txpool by calling:</description>
    </item>
    
    <item>
      <title>Ethereum Simulator Node</title>
      <link>https://notes.0081800.xyz/notes/20230612100350-ethereum_simulator_node/</link>
      <pubDate>Mon, 12 Jun 2023 10:03:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230612100350-ethereum_simulator_node/</guid>
      <description>tags: Ethereum Simulator Only use the data of the mainnet to simulate transaction, and DONOT commit the final transaction to the mainnet.
Relay To identify our transactions that need to simulate, if it&amp;rsquo;s failed then drop that tx, otherwise commit the final transaction to the mainnet.
Things need to consider:
How to limit or identify transactions that need to simulate?
Only execute the transactions from local txpool.
Where to execute the transction previously?</description>
    </item>
    
    <item>
      <title>How to Write a Technical Article</title>
      <link>https://notes.0081800.xyz/notes/20230608223754-how_to_write_a_technical_article/</link>
      <pubDate>Thu, 08 Jun 2023 22:37:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230608223754-how_to_write_a_technical_article/</guid>
      <description>tags: Essay Writing Guide
List outlines
Explore the resources and documentation to understand
Taking notes during the exploring
Use the method of How to Take Smart Notes</description>
    </item>
    
    <item>
      <title>English Words</title>
      <link>https://notes.0081800.xyz/notes/20230608214607-english_words/</link>
      <pubDate>Thu, 08 Jun 2023 21:46:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230608214607-english_words/</guid>
      <description> tags: Learning English, Journal </description>
    </item>
    
    <item>
      <title>Journal</title>
      <link>https://notes.0081800.xyz/notes/20230608214629-journal/</link>
      <pubDate>Thu, 08 Jun 2023 21:46:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230608214629-journal/</guid>
      <description></description>
    </item>
    
    <item>
      <title>coherent</title>
      <link>https://notes.0081800.xyz/notes/20230608214518-coherent/</link>
      <pubDate>Thu, 08 Jun 2023 21:45:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230608214518-coherent/</guid>
      <description> tags: English Words Adjective
(of an argument , theory, or policy) logical and consistent: they failed to develop a coherent economic strategy. united as or forming a whole: divided into a number of geographically coherent kingdoms. Physics (of waves) having a constant phase relationship. </description>
    </item>
    
    <item>
      <title>Essay Writing Guide</title>
      <link>https://notes.0081800.xyz/notes/20230608213315-essay_writing_guide/</link>
      <pubDate>Thu, 08 Jun 2023 21:33:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230608213315-essay_writing_guide/</guid>
      <description>source: https://jordanbpeterson.com/wp-content/uploads/2018/02/Essay_Writing_Guide.docx tags: How to Write PART I: INTRODUCTION Why are we need to learn how to write an essay? Writing an essay is to think by writing, formulate and organize ideas. Writing an essay is also to learn or explore a new topic. How to get things done? If you don&amp;rsquo;t have a big chunk of time in your daily life, then don&amp;rsquo;t relay your success on it, take 15 minutes every day is still powerful: 「日拱一卒，功不唐捐」.</description>
    </item>
    
    <item>
      <title>PostgresQL autovacuum &amp; ANALYZE</title>
      <link>https://notes.0081800.xyz/notes/20230529093313-postgresql_autovacuum_analyze/</link>
      <pubDate>Mon, 29 May 2023 09:33:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230529093313-postgresql_autovacuum_analyze/</guid>
      <description> tags: PostgresQL Recently, I met a problem in PostgresQL: the index mismatched after batch rows inserted.
Run ANALYZE on the table solved this problem after batch rows inerted.
Turns out autovacuum has been disabled on the PostgresQL instance:
show autovacuum_analyze_scale_factor; show autovacuum_analyze_threshold ; SELECT * FROM pg_settings WHERE name LIKE &amp;#39;%autovacuum%&amp;#39;; </description>
    </item>
    
    <item>
      <title>Met Eddie</title>
      <link>https://notes.0081800.xyz/notes/20230508154357-met_eddie/</link>
      <pubDate>Mon, 08 May 2023 15:43:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230508154357-met_eddie/</guid>
      <description>tags: On The Road https://www.google.com/maps/dir/New+York/Joliet/Rock+Island,+IL/Rapids+City,+IL/Des+Moines,+IA/Adel,+Iowa/Stuart,+Iowa/Council+Bluffs,+Iowa/Omaha,+NE/Grand+Island,+NE/@40.7489186,-96.7492412,5z/data=!3m1!4b1!4m62!4m61!1m5!1m1!1s0x89c24fa5d33f083b:0xc80b8f06e177fe62!2m2!1d-74.0059728!2d40.7127753!1m5!1m1!1s0x880e456bec363d7d:0x9f9e66f7a36bc042!2m2!1d-88.0817251!2d41.525031!1m5!1m1!1s0x87e232c357044b77:0xecc19371d71475f1!2m2!1d-90.5787476!2d41.5094771!1m5!1m1!1s0x87e23f0ad2e7aeb3:0x43aab678fe9e328d!2m2!1d-90.3434615!2d41.5817!1m5!1m1!1s0x87ee99a4c1611ee7:0x710028512691e4b2!2m2!1d-93.6249593!2d41.5868353!1m5!1m1!1s0x87ec39285c3540b9:0x84581d5d4142c1ec!2m2!1d-94.017453!2d41.6144325!1m5!1m1!1s0x87ec60c99a9a7d0f:0xb0c00a66d8103978!2m2!1d-94.3183715!2d41.5034243!1m5!1m1!1s0x879381cfa109322f:0xbe4e81fa5222799e!2m2!1d-95.8608333!2d41.2619444!1m5!1m1!1s0x87938dc8b50cfced:0x46424d4fae37b604!2m2!1d-95.9345034!2d41.2565369!1m5!1m1!1s0x87998644ec7765f7:0xa12d5b784951b17b!2m2!1d-98.3420118!2d40.9263957!3e0</description>
    </item>
    
    <item>
      <title>On The Road</title>
      <link>https://notes.0081800.xyz/notes/20230508154308-on_the_road/</link>
      <pubDate>Mon, 08 May 2023 15:43:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230508154308-on_the_road/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Emacs on Macos: Too Many Files Open</title>
      <link>https://notes.0081800.xyz/notes/20230418212343-emacs_on_macos_too_many_files_open/</link>
      <pubDate>Tue, 18 Apr 2023 21:23:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230418212343-emacs_on_macos_too_many_files_open/</guid>
      <description>tags: Emacs, macOS source: Simon, Ben. “Gotcha: Emacs on Mac OS: Too Many Files Open.” Accessed April 18, 2023. https://www.blogbyben.com/2022/05/gotcha-emacs-on-mac-os-too-many-files.html. Add below code snippet to your init.el:
(defun file-notify-rm-all-watches () &amp;#34;Remove all existing file notification watches from Emacs.&amp;#34; (interactive) (maphash (lambda (key _value) (file-notify-rm-watch key)) file-notify-descriptors)) Then just execute M-x file-notify-rm-all-watches when you meet this problem next time.</description>
    </item>
    
    <item>
      <title>NLTK Data</title>
      <link>https://notes.0081800.xyz/notes/20230418151139-nltk_data/</link>
      <pubDate>Tue, 18 Apr 2023 15:11:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230418151139-nltk_data/</guid>
      <description> tags: AI Clone nltk_data
git clone https://github.com/nltk/nltk_data.git ~/.local/nltk_data Link nltk_data
ln -sf ~/.local/nltk_data/packages ~/nltk_data Unzip
cd ~/nltk_data/path unzip xx.zip </description>
    </item>
    
    <item>
      <title>Bash</title>
      <link>https://notes.0081800.xyz/notes/20230417095019-bash/</link>
      <pubDate>Mon, 17 Apr 2023 09:50:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230417095019-bash/</guid>
      <description> tags: Linux </description>
    </item>
    
    <item>
      <title>Bash scripting cheatsheet</title>
      <link>https://notes.0081800.xyz/notes/20230417095009-bash_scripting_cheatsheet/</link>
      <pubDate>Mon, 17 Apr 2023 09:50:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230417095009-bash_scripting_cheatsheet/</guid>
      <description> tags: Cheatsheet, Bash source: Devhints.io cheatsheets. “Bash Scripting Cheatsheet.” Accessed April 17, 2023. https://devhints.io/bash. </description>
    </item>
    
    <item>
      <title>Searchable Linux Syscall Table for x86 and x86_64</title>
      <link>https://notes.0081800.xyz/notes/20230417094911-searchable_linux_syscall_table_for_x86_and_x86_64/</link>
      <pubDate>Mon, 17 Apr 2023 09:49:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230417094911-searchable_linux_syscall_table_for_x86_and_x86_64/</guid>
      <description> tags: Cheatsheet, Linux source: “Searchable Linux Syscall Table for X86 and X86_64 | PyTux.” Accessed April 17, 2023. https://filippo.io/linux-syscall-table/. </description>
    </item>
    
    <item>
      <title>Starcoin Signing Message</title>
      <link>https://notes.0081800.xyz/notes/20230412102128-starcoin_signing_message/</link>
      <pubDate>Wed, 12 Apr 2023 10:21:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230412102128-starcoin_signing_message/</guid>
      <description>tags: Starcoin Web3 StarTrek, Sign Message Invocation Path Dapp request personal_sign1
const msg = `0x${Buffer.from(exampleMessage, &amp;#39;utf8&amp;#39;).toString(&amp;#39;hex&amp;#39;)}` console.log({ msg }) const networkId = networkDiv.innerHTML const extraParams = { networkId } const sign = await window.starcoin.request({ method: &amp;#39;personal_sign&amp;#39;, // params: [msg, from, &amp;#39;Example password&amp;#39;], // extraParams = params[2] || {}; means it should be an object: // params: [msg, from, { pwd: &amp;#39;Example password&amp;#39; }], params: [msg, from, extraParams], }) Starmask handling request signPersonalMessage</description>
    </item>
    
    <item>
      <title>pyenv</title>
      <link>https://notes.0081800.xyz/notes/20230411180138-pyenv/</link>
      <pubDate>Tue, 11 Apr 2023 18:01:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230411180138-pyenv/</guid>
      <description> tags: Python </description>
    </item>
    
    <item>
      <title>Speedup Python Installation of pyenv</title>
      <link>https://notes.0081800.xyz/notes/20230411180124-speedup_python_installation_of_pyenv/</link>
      <pubDate>Tue, 11 Apr 2023 18:01:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230411180124-speedup_python_installation_of_pyenv/</guid>
      <description> tags: Python, pyenv export PYTHON_BUILD_MIRROR_URL_SKIP_CHECKSUM=1 export PYTHON_BUILD_MIRROR_URL=&amp;#34;https://npm.taobao.org/mirrors/python/&amp;#34; </description>
    </item>
    
    <item>
      <title>Aptos Signing Message</title>
      <link>https://notes.0081800.xyz/notes/20230411092153-aptos_signing_message/</link>
      <pubDate>Tue, 11 Apr 2023 09:21:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230411092153-aptos_signing_message/</guid>
      <description>tags: Sign Message The starmask has implemented about signing message of APTOS.</description>
    </item>
    
    <item>
      <title>Pyright Type Stubs</title>
      <link>https://notes.0081800.xyz/notes/20230410161857-pyright_type_stubs/</link>
      <pubDate>Mon, 10 Apr 2023 16:18:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230410161857-pyright_type_stubs/</guid>
      <description>tags: Python, LSP
source: https://emacs-lsp.github.io/lsp-pyright/#usage-notes
Download Default Type Stubs git clone https://github.com/microsoft/python-type-stubs $HOME/.local/src/python-type-stubs Use it in Emacs (setq lsp-pyright-stub-path (concat (getenv &amp;#34;HOME&amp;#34;) &amp;#34;/.local//src/python-type-stubs&amp;#34;)) ;; example Add Django Type Stubs git clone git@github.com:typeddjango/django-stubs.git ~/.local/src/django-stubs ln -sf ~/.local/src/django-stubs/django-stubs ~/.local/src/python-type-stubs/django Add Celery Type Stubs git clone https://github.com/sbdchd/celery-types ~/.local/src/celery-types ln -sf ~/.local/src/celery-types/amqp-stubs ~/.local/src/python-type-stubs/amqp ln -sf ~/.local/src/celery-types/billiard-stubs ~/.local/src/python-type-stubs/billiard ln -sf ~/.local/src/celery-types/celery-stubs ~/.local/src/python-type-stubs/celery ln -sf ~/.local/src/celery-types/django_celery_results-stubs ~/.local/src/python-type-stubs/django_celery_results ln -sf ~/.local/src/celery-types/ephem-stubs ~/.local/src/python-type-stubs/ephem ln -sf ~/.local/src/celery-types/kombu-stubs ~/.local/src/python-type-stubs/kombu ln -sf ~/.</description>
    </item>
    
    <item>
      <title>jemalloc</title>
      <link>https://notes.0081800.xyz/notes/20230407181930-jemalloc/</link>
      <pubDate>Fri, 07 Apr 2023 18:19:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230407181930-jemalloc/</guid>
      <description> tags: Memory Management, Heap Fragmentation </description>
    </item>
    
    <item>
      <title>Memory Management</title>
      <link>https://notes.0081800.xyz/notes/20230407181835-memory_management/</link>
      <pubDate>Fri, 07 Apr 2023 18:18:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230407181835-memory_management/</guid>
      <description> tags: Memory Model </description>
    </item>
    
    <item>
      <title>Heap Fragmentation</title>
      <link>https://notes.0081800.xyz/notes/20230407181757-heap_fragmentation/</link>
      <pubDate>Fri, 07 Apr 2023 18:17:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230407181757-heap_fragmentation/</guid>
      <description> tags: Memory Management </description>
    </item>
    
    <item>
      <title>Spotting and Avoiding Heap Fragmentation in Rust Applications</title>
      <link>https://notes.0081800.xyz/notes/20230407181742-spotting_and_avoiding_heap_fragmentation_in_rust_applications/</link>
      <pubDate>Fri, 07 Apr 2023 18:17:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230407181742-spotting_and_avoiding_heap_fragmentation_in_rust_applications/</guid>
      <description>tags: Heap Fragmentation, jemalloc source:Svix Blog. “Spotting and Avoiding Heap Fragmentation in Rust Applications,” April 4, 2023. https://www.svix.com/blog/heap-fragmentation-in-rust-applications/. Heap fragmentation cause stair-step memeory usage, use jemalloc to solve heap fragmentation.</description>
    </item>
    
    <item>
      <title>Sign Message</title>
      <link>https://notes.0081800.xyz/notes/20230407180408-sign_message/</link>
      <pubDate>Fri, 07 Apr 2023 18:04:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230407180408-sign_message/</guid>
      <description> tags: Blockchain </description>
    </item>
    
    <item>
      <title>Tron Signing Data</title>
      <link>https://notes.0081800.xyz/notes/20230407180424-tron_signing_data/</link>
      <pubDate>Fri, 07 Apr 2023 18:04:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230407180424-tron_signing_data/</guid>
      <description>tags: Tron, Sign Message Three methods tronweb.trx.signMessageV11 tronweb.trx.signMessageV22 tronweb.trx._signtypeddata3, 4 https://github.com/tronprotocol/tronweb/blob/859253856c79d3aff26ec6c89afefc73840d648d/src/lib/trx.js#L727-L739&amp;#160;&amp;#x21a9;&amp;#xfe0e;
https://github.com/tronprotocol/tronweb/blob/859253856c79d3aff26ec6c89afefc73840d648d/src/utils/message.js#L8-L18&amp;#160;&amp;#x21a9;&amp;#xfe0e;
https://github.com/tronprotocol/tronweb/blob/859253856c79d3aff26ec6c89afefc73840d648d/src/utils/crypto.js#L89&amp;#160;&amp;#x21a9;&amp;#xfe0e;
TIP 104&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description>
    </item>
    
    <item>
      <title>Ethereum Signing Data</title>
      <link>https://notes.0081800.xyz/notes/20230406090923-ethereum_signing_data/</link>
      <pubDate>Thu, 06 Apr 2023 09:09:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230406090923-ethereum_signing_data/</guid>
      <description>tags: Ethereum, Sign Message source: “Signing Data | MetaMask Docs.” Accessed April 6, 2023. https://docs.metamask.io/guide/signing-data.html#signtypeddata-v4. Five Methods1 eth_sign allow to sign arbitrary hash.2 personal_sign add prefix to data and human readable text that encoded UFT-8.3 signTypedData or signTypedData_v1 first release that lacked some later security improvements. signTypedData_v3 signTypedData_v4 compatible with V3. Differences Between V3 and V44 Some input types that V3 doesn&amp;rsquo;t support but V4 does:
Custom type array Custom type with null input Some input types that V4 doesn&amp;rsquo;t support but V3 does:</description>
    </item>
    
    <item>
      <title>Use GDB to Debug Cgo Segmentation Fault</title>
      <link>https://notes.0081800.xyz/notes/20230405200523-use_gdb_to_debug_cgo_segmentation_fault/</link>
      <pubDate>Wed, 05 Apr 2023 20:05:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230405200523-use_gdb_to_debug_cgo_segmentation_fault/</guid>
      <description>tags: Go, GDB Enable Core Dumps ulimit -S -c unlimited Confirm or Change The Location of Core Dumps sysctl -w kernel.core_pattern=/tmp/core.%e.%p # Or echo &amp;#39;/tmp/core.%e.%p&amp;#39; | tee /proc/sys/kernel/core_pattern Set GOTRACEBACK Environment Variable to Let Go Program Core Dumps when Panic export GOTRACEBACK=crash Run Go Program and Wait Segmentation Fault Use GDB to Debug gdb /path/to/goprogram /tmp/core-xx-xx Then use thread apply all bt to see all backtraces, include compiled C code.</description>
    </item>
    
    <item>
      <title>ScrollL2: How to Caculate L1Fee</title>
      <link>https://notes.0081800.xyz/notes/20230323083609-scrolll2_how_to_cacluate_l1fee/</link>
      <pubDate>Thu, 23 Mar 2023 08:36:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230323083609-scrolll2_how_to_cacluate_l1fee/</guid>
      <description>tags: Ethereum Layer 2 Background You may meet the below error when you&amp;rsquo;re trying to transfer all your ETH from one address to another address:
invalid transaction: insufficient funds for l1fee + gas * price + value
The reason is that the Layer 1 fee are included in Scroll&amp;rsquo;s gas fee system, but the wallet only exclude the Layer 2 gas fee to do so when you transfer all your ETH.</description>
    </item>
    
    <item>
      <title>How to Yubikey: a configuration cheatsheet</title>
      <link>https://notes.0081800.xyz/notes/20230311085820-how_to_yubikey_a_configuration_cheatsheet/</link>
      <pubDate>Sat, 11 Mar 2023 08:58:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230311085820-how_to_yubikey_a_configuration_cheatsheet/</guid>
      <description> tags: Yubikey source: “How to Yubikey: A Configuration Cheatsheet,” March 1, 2023. https://debugging.works/blog/yubikey-cheatsheet/. </description>
    </item>
    
    <item>
      <title>Overhead of Python asyncio Tasks: 260K/s</title>
      <link>https://notes.0081800.xyz/notes/20230309093002-overhead_of_python_asyncio_tasks_260k_s/</link>
      <pubDate>Thu, 09 Mar 2023 09:30:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230309093002-overhead_of_python_asyncio_tasks_260k_s/</guid>
      <description>tags: Python, High Performance source: Textual Documentation. “Textual - Overhead of Python Asyncio Tasks,” March 8, 2023. https://textual.textualize.io/blog/2023/03/08/overhead-of-python-asyncio-tasks/. Tasks of asyncio from create to run, then shutdown is about: 260K tasks per second.</description>
    </item>
    
    <item>
      <title>Yubikey</title>
      <link>https://notes.0081800.xyz/notes/20230225090409-yubikey/</link>
      <pubDate>Sat, 25 Feb 2023 09:04:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230225090409-yubikey/</guid>
      <description></description>
    </item>
    
    <item>
      <title>How to Weaponize the Yubikey</title>
      <link>https://notes.0081800.xyz/notes/20230225090358-how_to_weaponize_the_yubikey/</link>
      <pubDate>Sat, 25 Feb 2023 09:03:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230225090358-how_to_weaponize_the_yubikey/</guid>
      <description> tags: Yubikey source: BHIS. “How to Weaponize the Yubikey.” Black Hills Information Security (blog), May 2, 2019. https://www.blackhillsinfosec.com/how-to-weaponize-the-yubikey/. </description>
    </item>
    
    <item>
      <title>优质免费服务</title>
      <link>https://notes.0081800.xyz/notes/20230224101131-%E4%BC%98%E8%B4%A8%E5%85%8D%E8%B4%B9%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Fri, 24 Feb 2023 10:11:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230224101131-%E4%BC%98%E8%B4%A8%E5%85%8D%E8%B4%B9%E6%9C%8D%E5%8A%A1/</guid>
      <description>tags: Online Tools,Microstartup
source: https://twitter.com/vikingmute/status/1597417185470992384
HTTPS: Let&amp;rsquo;s Encrypt(acme.sh)
企业邮箱：
ym.163.coom（3G 容量） zoho.com.cn/mail/ landing page 搭建
https://tailblocks.cc/ https://landing.ant.design/ 图标素材
fontawesome.com iconfinder.com 音乐素材
https://uppbeat.io 插画
https://undraw.co/illustrations https://www.manypixels.co/gallery storyset.com CDN
cloudflare.com jsdelivr.com 静态托管
pages.cloudflare.com（无限请求和无线带宽） vercel.com(1G 带宽限制) 免费域名
freenom.com 免费 PS
photopea.com 非关系数据库
AWS DynamoDB 25GB 存储 + 1G 传输,https://aws.amazon.com/cn/dynamodb/ Azure CosmosDB 25GB 存储，兼容 MongoDB 以及 PostgresQL 关系型数据库
https://planetscale.com 5GB 存储，每月 10亿行读，1000万行写。 监控工具
https://uptimerobot.com/ 对象存储
网易云 nos https://163yun.com/nos/free 50GB 存储，20GB下行流量/月 又拍云联盟 https://upyun.com/league 10GB 存储，25GB流量/月 https://cloudinary.</description>
    </item>
    
    <item>
      <title>EIP 1559</title>
      <link>https://notes.0081800.xyz/notes/20230221094510-eip_1559/</link>
      <pubDate>Tue, 21 Feb 2023 09:45:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230221094510-eip_1559/</guid>
      <description>tags: Ethereum Before EIP 1559 The miner receive both fees and block reward.
After EIP 1559 The fee divide to 2 parts:
Base Fee Priority Fee The miner receive priority fee and block reward, the base fee will be burned.</description>
    </item>
    
    <item>
      <title>Papers We Love</title>
      <link>https://notes.0081800.xyz/notes/20230220113243-papers_we_love/</link>
      <pubDate>Mon, 20 Feb 2023 11:32:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230220113243-papers_we_love/</guid>
      <description> source: https://github.com/papers-we-love/papers-we-love tags: Papers </description>
    </item>
    
    <item>
      <title>The Refreshingly Rewarding Realm of Research Papers</title>
      <link>https://notes.0081800.xyz/notes/20230220113142-the_refreshingly_rewarding_realm_of_research_papers/</link>
      <pubDate>Mon, 20 Feb 2023 11:31:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230220113142-the_refreshingly_rewarding_realm_of_research_papers/</guid>
      <description>source: The Refreshingly Rewarding Realm of Research Papers, 2015. https://www.youtube.com/watch?v=8eRx5Wo3xYA. tags: Papers Finding Something to Read Sources:
Colleagues Papers We Love the morning paper With some topics/categories, to search on ACM Classification System(Require membership) Librarian Reading &amp;amp; Comprehending 3 Passes:
Go though: title/sections/concclusions/references. (10min) Read more closely (1-2 hours) Mark unread References Step though closely Summarize in 1-2 sentences; outline major contributes; note strengths/weaknesses (couple hours) Implementing Use familar tools, except the paper used specific tool.</description>
    </item>
    
    <item>
      <title>MPC</title>
      <link>https://notes.0081800.xyz/notes/20230218143222-mpc/</link>
      <pubDate>Sat, 18 Feb 2023 14:32:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230218143222-mpc/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Five Tips For a Healthier Postgres Database in the New Year</title>
      <link>https://notes.0081800.xyz/notes/20230213164423-five_tips_for_a_healthier_postgres_database_in_the_new_year/</link>
      <pubDate>Mon, 13 Feb 2023 16:44:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230213164423-five_tips_for_a_healthier_postgres_database_in_the_new_year/</guid>
      <description> tags: Database, PostgresQL source: Crunchy Data. “Five Tips For a Healthier Postgres Database in the New Year.” Accessed February 13, 2023. https://crunchydata.com/blog/five-tips-for-a-healthier-postgres-database-in-the-new-year. </description>
    </item>
    
    <item>
      <title>Decode input data of Ethereum</title>
      <link>https://notes.0081800.xyz/notes/20230203133843-decode_input_data_of_ethereum/</link>
      <pubDate>Fri, 03 Feb 2023 13:38:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230203133843-decode_input_data_of_ethereum/</guid>
      <description>tags: Ethereum,Blockchain,Tron source: https://ethereum.stackexchange.com/a/110498 const data = &amp;#39;0x7ff36ab50000000000000000000000000000000000000000000000bc18ba4144048bbab00000000000000000000000000000000000000000000000000000000000000080000000000000000000000000c0c5eb43e2df059e3be6e4fb0284c283caa5991900000000000000000000000000000000000000000000000000000000614d87a80000000000000000000000000000000000000000000000000000000000000002000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c00000000000000000000000008ba0619b1e7a582e0bce5bbe9843322c954c340&amp;#39;; ethers.utils.defaultAbiCoder.decode( [&amp;#39;uint256&amp;#39;, &amp;#39;address[]&amp;#39;, &amp;#39;address&amp;#39;, &amp;#39;uint256&amp;#39;], ethers.utils.hexDataSlice(data, 4) ) // gives: [e, [&amp;#34;0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c&amp;#34;, &amp;#34;0x08ba0619b1e7A582E0BCe5BBE9843322C954C340&amp;#34;], &amp;#34;0xC0C5eb43E2dF059e3Be6E4fb0284C283CAa59919&amp;#34;, e] (4) Online tools: Playground.</description>
    </item>
    
    <item>
      <title>Tron</title>
      <link>https://notes.0081800.xyz/notes/20230203133859-tron/</link>
      <pubDate>Fri, 03 Feb 2023 13:38:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230203133859-tron/</guid>
      <description> tags: Blockchain </description>
    </item>
    
    <item>
      <title>Hypertext in Emacs: find-file-at-point</title>
      <link>https://notes.0081800.xyz/notes/20230131105103-hypertext_in_emacs_find_file_at_point/</link>
      <pubDate>Tue, 31 Jan 2023 10:51:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20230131105103-hypertext_in_emacs_find_file_at_point/</guid>
      <description>tags: Emacs source: http://bjornwestergard.com/log/2022-04-19-hypertext-emacs.gmi C-x C-f M-n to find-file-at-point.</description>
    </item>
    
    <item>
      <title>Solana PDA</title>
      <link>https://notes.0081800.xyz/notes/20221226154617-solana_pda/</link>
      <pubDate>Mon, 26 Dec 2022 15:46:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20221226154617-solana_pda/</guid>
      <description>tags: Solana, Solana 101: 2. Anchor What is Program Derived Address(PDA)?1 A Program Derived Address is simply an account owned by the program, but has no private key. Instead it&amp;rsquo;s signature is obtained by a set of seeds and a bump (a nonce which makes sure it&amp;rsquo;s off curve). &amp;ldquo;Generating&amp;rdquo; a Program Address is different from &amp;ldquo;creating&amp;rdquo; it.
Generating One can generate a PDA using Pubkey::find_program_address in Rust or PublicKey.</description>
    </item>
    
    <item>
      <title>Reverse Proxy to bypass Network Issue of Solana RPC Node</title>
      <link>https://notes.0081800.xyz/notes/20221224153042-reverse_proxy_to_bypass_network_issue_of_solana_rpc_node/</link>
      <pubDate>Sat, 24 Dec 2022 15:30:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20221224153042-reverse_proxy_to_bypass_network_issue_of_solana_rpc_node/</guid>
      <description>tags: Nginx One Endpoint for Both WebSocket and Normal Requests,Solana,Solana 101: Create an Escrow dApp I met a lot network issues about connecting to RPC node of Solana, so I&amp;rsquo;m using a nginx server as a reverse proxy to bypass this problem:
location / { # https://serverfault.com/a/923254 try_files /nonexistent @$http_upgrade; } location @ { proxy_pass https://api.testnet.solana.com; proxy_read_timeout 300s; proxy_send_timeout 300s; proxy_set_header Host &amp;#34;api.testnet.solana.com&amp;#34;; } location @websocket { proxy_redirect off; proxy_pass https://api.</description>
    </item>
    
    <item>
      <title>Nginx</title>
      <link>https://notes.0081800.xyz/notes/20221224152920-nginx/</link>
      <pubDate>Sat, 24 Dec 2022 15:29:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20221224152920-nginx/</guid>
      <description> tags: Linux </description>
    </item>
    
    <item>
      <title>Nginx One Endpoint for Both WebSocket and Normal Requests</title>
      <link>https://notes.0081800.xyz/notes/20221224152905-nginx_one_endpoint_for_both_websocket_and_normal_requests/</link>
      <pubDate>Sat, 24 Dec 2022 15:29:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20221224152905-nginx_one_endpoint_for_both_websocket_and_normal_requests/</guid>
      <description> tags: Nginx source: https://serverfault.com/a/923254 server { # ... location / { # If &amp;#34;Websocket&amp;#34; is in Upgrade header, then @websocket will take effect, # otherwise @ will take effect. try_files /nonexistent @$http_upgrade; } location @websocket { # websocket related stuff } location @ { # web related stuff } } </description>
    </item>
    
    <item>
      <title>Decoration</title>
      <link>https://notes.0081800.xyz/notes/20221224110813-decoration/</link>
      <pubDate>Sat, 24 Dec 2022 11:08:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20221224110813-decoration/</guid>
      <description>参考 https://github.com/RobbieXie/2020DecorationNote Ideas 在马桶旁边要留一个插座，用于智能马桶垫； 厨房油烟机机一个光滑斜面可以在餐厅坐着看锅里的情况； 全屋六类线预留 AP 和插座，最好能扩大弱电箱能放进去个 NAS； 面向扫地机器人装修； </description>
    </item>
    
    <item>
      <title>Ethereum Layer 2</title>
      <link>https://notes.0081800.xyz/notes/20221223100819-ethereum_layer_2/</link>
      <pubDate>Fri, 23 Dec 2022 10:08:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20221223100819-ethereum_layer_2/</guid>
      <description>tags: Ethereum Knowning Layer 2 Chain Rollup(or bundle) transactions off-chain to reduce fee and scale capacity, such as Bitcoin Lightning.
Two layer 2 rollups Optimistic Rollups Zero-Knowledge Rollups Record on-chain state by writing calldata to L1(Ethereum), which more cheaper than change state on L1 chain.
Fees Some layer 2 chain like Optimism should plus l1 fee when executing transaction on layer 1.1
Many Ethereum applications display estimated fees to users by multiplying the gas price by the gas limit.</description>
    </item>
    
    <item>
      <title>Go Reflect</title>
      <link>https://notes.0081800.xyz/notes/20221123104729-go_reflect/</link>
      <pubDate>Wed, 23 Nov 2022 10:47:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20221123104729-go_reflect/</guid>
      <description> tags: Go Elem() Returns Value type T struct { } t := &amp;amp;T{} v := reflect.New(reflect.TypeOf(t)).Elem() // type of v is `T` Interface() Returns Pointer type T struct { } t := &amp;amp;T{} v := reflect.New(reflect.TypeOf(t)).Interface() // type of v is `&amp;amp;T` </description>
    </item>
    
    <item>
      <title>Solana 101: 5. Escrow dApp</title>
      <link>https://notes.0081800.xyz/notes/20221122204630-solana_101_5_escrow_dapp/</link>
      <pubDate>Tue, 22 Nov 2022 20:46:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20221122204630-solana_101_5_escrow_dapp/</guid>
      <description> tags: Solana 101: Create an Escrow dApp </description>
    </item>
    
    <item>
      <title>Solana 101: 3. SPL Token</title>
      <link>https://notes.0081800.xyz/notes/20221122204508-solana_101_3_create_a_spl_token/</link>
      <pubDate>Tue, 22 Nov 2022 20:45:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20221122204508-solana_101_3_create_a_spl_token/</guid>
      <description>tags: Solana 101: Create an Escrow dApp 连接钱包 安装 Phantom 钱包； 使用 @solana/wallet-adapter 连接钱包。官方提供了 React 相关的实现，Vue 可以通过社区提供的库：https://github.com/lorisleiva/solana-wallets-vue。 npm install solana-wallets-vue @solana/wallet-adapter-wallets 创建 SPL Token 安装依赖 npm install --save @solana/spl-token 创建代币 通过 Token Program 创建 Token，Solana 通过其特有的账号机制，通过创建一个账号并将 Owner 设置为一个统一的 Token Program 即可发行一种代币。1
发行代币 要持有代币必须创建一个对应的 Associated Token Account（ATA），也就是要接收一个代币首先要检查有没有对应代币的 ATA，没有则创建，然后给对应的 ATA 转移代币。
代币转帐 燃烧代币 SPL Token 交互：授权 Program 转帐 Libraries:
spl_associated_token_account Steps:
Delegate token to Program &amp;ndash; in frontend. Create a Associated Token Account for Program to hold token.</description>
    </item>
    
    <item>
      <title>Solana 101: 4. SPL NFT</title>
      <link>https://notes.0081800.xyz/notes/20221122204541-solana_101_4_create_a_spl_nft/</link>
      <pubDate>Tue, 22 Nov 2022 20:45:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20221122204541-solana_101_4_create_a_spl_nft/</guid>
      <description> tags: Solana 101: Create an Escrow dApp </description>
    </item>
    
    <item>
      <title>Solana 101: 2. Anchor</title>
      <link>https://notes.0081800.xyz/notes/20221122204442-solana_101_2_anchor/</link>
      <pubDate>Tue, 22 Nov 2022 20:44:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20221122204442-solana_101_2_anchor/</guid>
      <description>tags: Solana 101: Create an Escrow dApp 链上数据存储 账号所有权 账号可以通过 Metadata 指定一个 Program 作为拥有者（Owner）； Program 作为拥有者可以： 修改账号数据； 可以使用该 PDA 进行签名。 PDA(Program Derived Address) 1 使用 PDA 进行合约状态链上存储。
PDA 只有一个类似公钥的地址，但是没有对应的私钥； 链下生成：通过 PublicKey.findProgramAddress 生成 PDA，seeds 用于生成多个 PDA； 链上创建：将 PDA 作为账号传递给 Program 进行链上创建：填充足够的 lamports 用于支付租金、开辟空间、指定 program 作为 Owner。 创建一个计数器 部署智能合约； 生成一个 PDA 并进行链上创建； 增加计数器； 其他账号获取 PDA，并增加计数器； 使用 Anchor 重写计数器 安装 Anchor 安装 Yarn 安装 avm cargo install --git https://github.com/project-serum/anchor avm --locked --force 使用 avm 安装 anchor avm install latest avm use latest 创建 anchor 项目 anchor init hello-anchor anchor 项目结构 Understanding Program Derived Addresses&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description>
    </item>
    
    <item>
      <title>Solana 101: 1. Develop Model</title>
      <link>https://notes.0081800.xyz/notes/20221122204241-solana_101_develop_model/</link>
      <pubDate>Tue, 22 Nov 2022 20:42:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20221122204241-solana_101_develop_model/</guid>
      <description>tags: Solana 101: Create an Escrow dApp Account UTXO Unspend Transaction Output.
EVM Accounts1 EOA(Externally-owned acount) - 用户用私钥控制的账号； 合约账号（Contract account） - 代码控制的账号，用于部署智能合约代码。 账号模型通过用户地址为用户开辟一块单独的存储，简单的理解就是用公私钥导出的唯一地址作为主键存储在节点的存储系统里（RocksDB）； 这样只要将链上转账或者智能合约产生的结果或副作用存储在账号下面即可。
Solana Account Model Accounts2 账号用于提供给智能合约（Program）跨交易存储状态，类似文件系统； 包含元数据（metadata）说明谁有权限访问这些状态； Solana 独特的创新：账号伴有生命周期，也就是对应的私钥并不完全拥有一个账号，而是从链上租借（rent）了一个账号，并支付对应的租金，当租借过期且没有足够的余额（lamports）支付租金的情况下，账号下的数据将被链回收； 一笔交易里可以参与的账号类型有：
Signers 一笔交易可以包含一个或多个签名者，表示授权此笔交易（多签机制）； Read-only 交易里对该账号只读； Executable 其账号可以作为智能合约进行调用（将其账号对应的公钥地址作为 program id）； Programs or Smart Contract3 账号被标记为 Executable 可以部署代码（Program）作为智能合约。两种类型的智能合约：
Native Programs &amp;ndash; 区块链系统提供的标准库； On Chain Programs &amp;ndash; 用户开发部署到链上的智能合约。 同时智能合约可以控制多个其他账号，并且只能修改它所拥有的账号数据，但是可以读取其他账号的数据。
Solana 的 Program 可以被更新。
搭建开发环境 命令行钱包 sh -c &amp;#34;$(curl -sSfL https://release.solana.com/stable/install)&amp;#34; 连接到测试节点 solana config set --url https://api.</description>
    </item>
    
    <item>
      <title>Solana 101: 0. Prelude</title>
      <link>https://notes.0081800.xyz/notes/20221121160749-solana_101_prelude/</link>
      <pubDate>Mon, 21 Nov 2022 16:07:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20221121160749-solana_101_prelude/</guid>
      <description>tags: Solana 101: Create an Escrow dApp 聊聊区块链 一个完整的区块链系统生态：
主币：进行 gas 费结算：BitCoin / ETH / TRX 等等 节点服务(JSONRPC 2.0)：提供数据查询、广播交易，交易广播（P2P -&amp;gt; 挖矿节点）； 交易验证：挣取 gas 费，出块奖励（挖矿）； PoW（Proof of Work）：通过算力证明提供交易验证（出块）；sha256(nonce + body) -&amp;gt; sha256 import hashlib from typing import Tuple raw_block = b&amp;#39;block data&amp;#39; dificulty = 5 def proof_my_work(dificulty, raw_block) -&amp;gt; Tuple[int, str]: nonce = 1 while True: body = bytes(nonce) + raw_block h = hashlib.sha256(body) hex_value = h.hexdigest() if hex_value[:dificulty] == &amp;#39;0&amp;#39; * dificulty: return nonce, hex_value nonce += 1 proof_my_work(dificulty, raw_block) PoS（Proof of Stake）：通过质押主币提供交易验证，一旦被发现作弊则扣除质押的主币； 链浏览器：通过 Web UI 进行链上数据查询； 钱包 == 私钥：资产证明，交易授权，公钥导出地址，私钥则是证明拥有该地址； 智能合约（Smart Contract）：对资产进行编程； 代币（Tokens）：基于智能合约实现，Fungible Tokens（ERC20 / TRC20） 和 Non-Fungible Tokens （ERC721） dApp：通过桥接钱包和链上智能合约实现一定的链上操作； 从智能合约来看各个区块链生态之间的区别 主要是虚拟机的区别，为了执行智能合约，区块链系统需要虚拟机来执行代码，目前主流的虚拟机包括：</description>
    </item>
    
    <item>
      <title>Solana 101: Create an Escrow dApp</title>
      <link>https://notes.0081800.xyz/notes/20221119104334-solana_101_create_a_escrow_dapp/</link>
      <pubDate>Sat, 19 Nov 2022 10:43:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20221119104334-solana_101_create_a_escrow_dapp/</guid>
      <description> tags: Solana </description>
    </item>
    
    <item>
      <title>Python lambda generate bitmap</title>
      <link>https://notes.0081800.xyz/notes/20221024112631-python_lambda_generate_bitmap/</link>
      <pubDate>Mon, 24 Oct 2022 11:26:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20221024112631-python_lambda_generate_bitmap/</guid>
      <description>tags: Python _ = ( 255, lambda V ,B,c :c and Y(V*V+B,B, c -1)if(abs(V)&amp;lt;6)else ( 2+c-4*abs(V)**-0.4)/i ) ;v, x=1500,1000;C=range(v*x );import struct;P=struct.pack;M,\ j =&amp;#39;&amp;lt;QIIHHHH&amp;#39;,open(&amp;#39;M.bmp&amp;#39;,&amp;#39;wb&amp;#39;).write for X in j(&amp;#39;BM&amp;#39;+P(M,v*x*3+26,26,12,v,x,1,24))or C: i ,Y=_;j(P(&amp;#39;BBB&amp;#39;,*(lambda T:(T*80+T**9 *i-950*T **99,T*70-880*T**18+701* T **9 ,T*i**(1-T**45*2)))(sum( [ Y(0,(A%3/3.+X%v+(X/v+ A/3/3.-x/2)/1j)*2.5 /x -2.7,i)**2 for \ A in C [:9]]) /9) ) ) It generates a Mandelbrot like the code likes:</description>
    </item>
    
    <item>
      <title>GTK Debug Mode</title>
      <link>https://notes.0081800.xyz/notes/20221024111901-gtk_debug_mode/</link>
      <pubDate>Mon, 24 Oct 2022 11:19:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20221024111901-gtk_debug_mode/</guid>
      <description> tags: GTK
GTK_DEBUG=interactive my-gtk-app </description>
    </item>
    
    <item>
      <title>macOS Cheatsheet</title>
      <link>https://notes.0081800.xyz/notes/20220914093806-macos_cheatsheet/</link>
      <pubDate>Wed, 14 Sep 2022 09:38:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220914093806-macos_cheatsheet/</guid>
      <description> tags: Cheatsheet, macOS Retrieve Bundle ID osascript -e &amp;#39;id of app &amp;#34;/usr/local/MacGPG2/libexec/pinentry-mac.app&amp;#34;&amp;#39; osascript -e &amp;#39;id of app &amp;#34;Finder&amp;#34;&amp;#39; </description>
    </item>
    
    <item>
      <title>Cheatsheet</title>
      <link>https://notes.0081800.xyz/notes/20220913105435-cheatsheet/</link>
      <pubDate>Tue, 13 Sep 2022 10:54:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220913105435-cheatsheet/</guid>
      <description></description>
    </item>
    
    <item>
      <title>PostgresQL</title>
      <link>https://notes.0081800.xyz/notes/20220913105411-postgresql/</link>
      <pubDate>Tue, 13 Sep 2022 10:54:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220913105411-postgresql/</guid>
      <description></description>
    </item>
    
    <item>
      <title>PostgresQL Cheatsheet</title>
      <link>https://notes.0081800.xyz/notes/20220913105403-postgresql_cheatsheet/</link>
      <pubDate>Tue, 13 Sep 2022 10:54:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220913105403-postgresql_cheatsheet/</guid>
      <description> tags: PostgresQL, Cheatsheet Create User and Role Docs: Examples of Create Role
CREATE ROLE whoami WITH LOGIN PASSWORD &amp;#39;P@ssw0rd&amp;#39;; Create Database Docs: Examples of Create Database
CREATE DATABASE sales OWNER whoami; </description>
    </item>
    
    <item>
      <title>GnuPG Agent Cheatsheet</title>
      <link>https://notes.0081800.xyz/notes/20220908111543-gpg_agent/</link>
      <pubDate>Thu, 08 Sep 2022 11:15:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220908111543-gpg_agent/</guid>
      <description> tags: GPG, GnuPG Agent,Cheatsheet Stop GPG Agent
gpg-connect-agent killagent /bye obsolete option &amp;ldquo;write-env-file&amp;rdquo; - it has no effect
set -gx GPG_TTY (tty) set -gx SSH_AUTH_SOCK (gpgconf --list-dirs agent-ssh-socket) gpgconf --launch gpg-agent </description>
    </item>
    
    <item>
      <title>DeFi from Scratch</title>
      <link>https://notes.0081800.xyz/notes/20220825160507-defi_from_scartch/</link>
      <pubDate>Thu, 25 Aug 2022 16:05:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220825160507-defi_from_scartch/</guid>
      <description>tags: DeFi, Blockchain, Uniswap, Uniswap V3 I need derive price from decentralized exchanges, and I have finished some research about Uniswap v3.
It&amp;rsquo;s brand new for me, and after that I want to share some ideas about DeFi, and I think it would be helpful for you to understand Uniswap and some other decentralized exchanges.
DeFi from Scratch We exchange stuffs very often, and we can exchange tokens in a centralized exchange.</description>
    </item>
    
    <item>
      <title>Uniswap V3 Tick</title>
      <link>https://notes.0081800.xyz/notes/20220825151409-uniswap_v3_tick/</link>
      <pubDate>Thu, 25 Aug 2022 15:14:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220825151409-uniswap_v3_tick/</guid>
      <description> tags: Uniswap V3 source: Shao, 田少谷. “Uniswap v3 Features Explained in Depth.” Taipei Ethereum Meetup (blog), July 20, 2021. https://medium.com/taipei-ethereum-meetup/uniswap-v3-features-explained-in-depth-178cfe45f223. Tick is a price range Each tick is a price range with upper bound and lower bound.
Tick price from index: \(p(i) = 1.0001 ^ i\)
1.0001 ** 138162 # 999_998 Tick index from price: \(log_{1.0001}p\)
import math math.log(1000_000, base=1.0001) # 138162.01321981344 </description>
    </item>
    
    <item>
      <title>Uniswap V3</title>
      <link>https://notes.0081800.xyz/notes/20220825151116-uniswap_v3/</link>
      <pubDate>Thu, 25 Aug 2022 15:11:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220825151116-uniswap_v3/</guid>
      <description> tags: Uniswap The Graph: Uniswap V3 Subgraph </description>
    </item>
    
    <item>
      <title>DeFi</title>
      <link>https://notes.0081800.xyz/notes/20220825151036-defi/</link>
      <pubDate>Thu, 25 Aug 2022 15:10:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220825151036-defi/</guid>
      <description> tags: Blockchain </description>
    </item>
    
    <item>
      <title>Uniswap</title>
      <link>https://notes.0081800.xyz/notes/20220825151023-uniswap/</link>
      <pubDate>Thu, 25 Aug 2022 15:10:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220825151023-uniswap/</guid>
      <description> tags: Blockchain,Ethereum,DeFi </description>
    </item>
    
    <item>
      <title>Non-Fungible Tokens vs. Fungible Tokens</title>
      <link>https://notes.0081800.xyz/notes/20220823105929-non_fungible_tokens_vs_fungible_tokens/</link>
      <pubDate>Tue, 23 Aug 2022 10:59:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220823105929-non_fungible_tokens_vs_fungible_tokens/</guid>
      <description>tags: Blockchain,Ethereum source: “Graphical Guide to Understanding Uniswap - EthHub.” Accessed August 23, 2022. https://docs.ethhub.io/guides/graphical-guide-for-understanding-uniswap/. ERC20 tokens are the most common type of token built on top of Ethereum. They are fungible in nature, meaning that there isn’t a distinction between individual tokens. For example, if I have 100 metal marbles in my hand that are all the same size and color, it doesn’t matter which one I give you.</description>
    </item>
    
    <item>
      <title>Your Makefiles are wrong</title>
      <link>https://notes.0081800.xyz/notes/20220822112621-your_makefiles_are_wrong/</link>
      <pubDate>Mon, 22 Aug 2022 11:26:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220822112621-your_makefiles_are_wrong/</guid>
      <description>tags: Makefile source: Davis-Hansson, Jacob. “Your Makefiles Are Wrong.” Jacob Davis-Hansson on Tech, December 15, 2019. https://tech.davis-hansson.com/p/make/. Best Makefile Defaults # Always use bash as the shell. SHELL := bash # Enable bash strict mode. .SHELLFLAGS := -eu -o pipefail -c ## Change some Defaults of Make. # Ensures each Make recipe is ran as one single shell session, # rather than one new shell per line. .ONESHELL: # Delete it&amp;#39;s target file if a Make rule fails.</description>
    </item>
    
    <item>
      <title>Podcasts RSS Feed Validator</title>
      <link>https://notes.0081800.xyz/notes/20220817142152-podcasts_rss_feed_validator/</link>
      <pubDate>Wed, 17 Aug 2022 14:21:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220817142152-podcasts_rss_feed_validator/</guid>
      <description> tags: Online Tools website: https://www.castfeedvalidator.com/ </description>
    </item>
    
    <item>
      <title>Solana Account</title>
      <link>https://notes.0081800.xyz/notes/20220802181223-solana_account/</link>
      <pubDate>Tue, 02 Aug 2022 18:12:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220802181223-solana_account/</guid>
      <description>tags: Solana, Solana 101: 1. Develop Model Account: a Memory region The solana term for a memory region is &amp;ldquo;account&amp;rdquo;. Some programs own thousands of independent accounts.
Programs own accounts, aka the owner of accounts.
Transactions and Accounts You can make a program read and write data by sending transactions. Programs provide endpoints that can be called via transactions (In reality it&amp;rsquo;s a bit more complex than that but frameworks like Anchor abstract away this complexity).</description>
    </item>
    
    <item>
      <title>Solana Program</title>
      <link>https://notes.0081800.xyz/notes/20220802174748-solana_program/</link>
      <pubDate>Tue, 02 Aug 2022 17:47:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220802174748-solana_program/</guid>
      <description>tags: Solana, Solana 101: 1. Develop Model Program Owns Accounts And each memory region has a program that manages it (sometimes called the “owner”).
How to Communicate with Solana Programs? Off-chain This means your programs aren&amp;rsquo;t on-chain program, you can submit transactions with instructions to the network, it could be done via the JSON RPC API or any SDK built on top this API.
On-chain TODO</description>
    </item>
    
    <item>
      <title>Rust Opaque Types: Static Dispatch vs. Dynamic Dispatch</title>
      <link>https://notes.0081800.xyz/notes/20220802104148-rust_opaque_types_static_dispatch_vs_dynamic_dispatch/</link>
      <pubDate>Tue, 02 Aug 2022 10:41:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220802104148-rust_opaque_types_static_dispatch_vs_dynamic_dispatch/</guid>
      <description> tags: Rust source: Johnston, Dylan R. “Formally Verifying Rust’s Opaque Types,” August 1, 2022. https://dylanj.xyz/posts/rust-coq-opaque-types/. Prelude trait ToString { fn to_string(&amp;amp;self) -&amp;gt; String; } Static Dispatch fn yell&amp;lt;S: ToString&amp;gt;(stringable: S) { println!(stringable.to_string().to_uppercase()) } Dynamic Dispatch fn yell(stringable: &amp;amp;dyn ToString) { println!(stringable.to_string().to_uppercase()) } impl Trait fn yell(stringable: impl ToString) { println!(stringable.to_string().to_uppercase()) } </description>
    </item>
    
    <item>
      <title>error: is only available in macOS 10.15 or newer</title>
      <link>https://notes.0081800.xyz/notes/20220728071920-error_is_only_available_in_macos_10_15_or_newer/</link>
      <pubDate>Thu, 28 Jul 2022 07:19:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220728071920-error_is_only_available_in_macos_10_15_or_newer/</guid>
      <description>tags: Flutter,GUI,macOS souce: https://github.com/flutter/flutter/issues/73122 To solve this problem we should specify MACOSX_DEPLOYMENT_TARGET：
I would imagine that there is Apple documentation on managing build settings in Xcode, but I don&amp;rsquo;t have a link offhand. There&amp;rsquo;s no Flutter-specific documentation of the process, if that&amp;rsquo;s what you mean; it isn&amp;rsquo;t any different in a Flutter macOS application as it would be any other macOS application.
If you don&amp;rsquo;t want to use Xcode, you can change MACOSX_DEPLOYMENT_TARGET directly in Runner.</description>
    </item>
    
    <item>
      <title>Wecom Debug Mode</title>
      <link>https://notes.0081800.xyz/notes/20220725161801-wecom_debug_mode/</link>
      <pubDate>Mon, 25 Jul 2022 16:18:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220725161801-wecom_debug_mode/</guid>
      <description>macOS Press Command + Shift + Control + D to enter debug mod.
Then you can open url in brower: Help -&amp;gt; Debug -&amp;gt; 「浏览器 webview 相关-系统浏览器打开网页」</description>
    </item>
    
    <item>
      <title>Flutter</title>
      <link>https://notes.0081800.xyz/notes/20220725083304-flutter/</link>
      <pubDate>Mon, 25 Jul 2022 08:33:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220725083304-flutter/</guid>
      <description> tags: GUI </description>
    </item>
    
    <item>
      <title>iOS</title>
      <link>https://notes.0081800.xyz/notes/20220725083317-ios/</link>
      <pubDate>Mon, 25 Jul 2022 08:33:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220725083317-ios/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Flutter FFI didn&#39;t be Invoked in Release Mode</title>
      <link>https://notes.0081800.xyz/notes/20220725081335-flutter_ffi_won_t_be_invoked_in_release_mode/</link>
      <pubDate>Mon, 25 Jul 2022 08:13:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220725081335-flutter_ffi_won_t_be_invoked_in_release_mode/</guid>
      <description>tags: Rust,Flutter,iOS source: “Using Dummy Headers - Flutter_rust_bridge.” Accessed July 25, 2022. http://cjycode.com/flutter_rust_bridge/integrate/ios_headers.html. Recently, I met a problem that the iOS app didn&amp;rsquo;t work properly in release mode. After a little searching, I found it&amp;rsquo;s a Flutter app and invoked a Rust function by FFI. The inital call were not invoked during app startup, and it should be.
I finally resolved the problem by following:
https://github.com/fzyzcjy/flutter_rust_bridge/issues/496 http://cjycode.com/flutter_rust_bridge/integrate/ios_headers.html In short:</description>
    </item>
    
    <item>
      <title>openssl</title>
      <link>https://notes.0081800.xyz/notes/20220715140459-openssl/</link>
      <pubDate>Fri, 15 Jul 2022 14:04:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220715140459-openssl/</guid>
      <description> tags: Tools </description>
    </item>
    
    <item>
      <title>openssl unknown ca</title>
      <link>https://notes.0081800.xyz/notes/20220715140444-openssl_unknown_ca/</link>
      <pubDate>Fri, 15 Jul 2022 14:04:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220715140444-openssl_unknown_ca/</guid>
      <description>tags: openssl This problem is caused about the ca certs are different between client and server.</description>
    </item>
    
    <item>
      <title>Move Resources Permissions</title>
      <link>https://notes.0081800.xyz/notes/20220705071653-move_resources_permissions/</link>
      <pubDate>Tue, 05 Jul 2022 07:16:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220705071653-move_resources_permissions/</guid>
      <description>tags: Move,Starcoin Web3 StarTrek Bedrock &amp;ndash; Object-capability model In my words, Move is kind of a Resource-Oriented Programming language. The resource is represented by struct in Move, aka object in other programming language. By the way, the resource in Move is the struct which cannot be copied and cannot be dropped1.
Distinct from other programming language, objects are stored in memory, resource in Move can store to the chain&amp;rsquo;s global storage.</description>
    </item>
    
    <item>
      <title>Brevity 500: 500 mini-games to help you learn powerful writing skills</title>
      <link>https://notes.0081800.xyz/notes/20220630120053-brevity_500_500_mini_games_to_help_you_learn_powerful_writing_skills/</link>
      <pubDate>Thu, 30 Jun 2022 12:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220630120053-brevity_500_500_mini_games_to_help_you_learn_powerful_writing_skills/</guid>
      <description> tags: How to Write,Online Tools source: https://brevity500.com/ </description>
    </item>
    
    <item>
      <title>GitHub: hackclub/some-assembly-required</title>
      <link>https://notes.0081800.xyz/notes/20220629071413-github_hackclub_some_assembly_required/</link>
      <pubDate>Wed, 29 Jun 2022 07:14:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220629071413-github_hackclub_some_assembly_required/</guid>
      <description>tags: Assembly source: https://github.com/hackclub/some-assembly-required What do we mean by an abstraction? Well, an abstraction is a layer above something else that makes that thing easier to do.</description>
    </item>
    
    <item>
      <title>How is a Block Executed</title>
      <link>https://notes.0081800.xyz/notes/20220624172625-how_a_block_is_executed/</link>
      <pubDate>Fri, 24 Jun 2022 17:26:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220624172625-how_a_block_is_executed/</guid>
      <description>tags: Starcoin Web3 StarTrek,Move When I start learning Move and looking at the stdlib starcoin-framework and starcoin-framework-commons. Then I realized there are must some magic during the block execution in runtime. To roll the world, the runtime should provide some built in types and call some function in the stdlib.
How does StarcoinVM Validate Transactions? As a miner, it&amp;rsquo;s responsible for executing block, it follows:
Received some transactions from P2P network: EventHandler of PeerTransactionsMessage.</description>
    </item>
    
    <item>
      <title>Starcoin Node Debug</title>
      <link>https://notes.0081800.xyz/notes/20220621153549-starcoin_node_debug/</link>
      <pubDate>Tue, 21 Jun 2022 15:35:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220621153549-starcoin_node_debug/</guid>
      <description>tags: Starcoin Web3 StarTrek Start node with console:
$ ./target/debug/starcoin -d ~/.starcoin -n dev console In console type:
starcoin% dev log level debug Note: starcoin% is the prompt.
Then we can see debug log in ~/.starcoin/dev/starcoin.log.</description>
    </item>
    
    <item>
      <title>Move: A Language With Programmable Resources</title>
      <link>https://notes.0081800.xyz/notes/20220618163332-move_a_language_with_programmable_resources/</link>
      <pubDate>Sat, 18 Jun 2022 16:33:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220618163332-move_a_language_with_programmable_resources/</guid>
      <description> tags: Move,Starcoin Web3 StarTrek source: Blackshear, Sam, Evan Cheng, David L Dill, Victor Gao, Ben Maurer, Todd Nowacki, Alistair Pott, et al. “Move: A Language With Programmable Resources,” n.d., 26. </description>
    </item>
    
    <item>
      <title>Move</title>
      <link>https://notes.0081800.xyz/notes/20220618163155-move/</link>
      <pubDate>Sat, 18 Jun 2022 16:31:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220618163155-move/</guid>
      <description> tags: Starcoin Web3 StarTrek,Blockchain,Smart contracts </description>
    </item>
    
    <item>
      <title>How is an Account Created</title>
      <link>https://notes.0081800.xyz/notes/20220616181130-how_a_account_is_created/</link>
      <pubDate>Thu, 16 Jun 2022 18:11:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220616181130-how_a_account_is_created/</guid>
      <description>tags: Starcoin Web3 StarTrek,Account-Model Blockchain Systems We can create an account by wallet like MetaMask or StarMask, but I&amp;rsquo;m curious about how an account is created on the blockchain system.
As a wallet has been embedded in the starcoin node, we can use it to create an account as follow:
$ ./target/debug/starcoin -d ~/.starcoin -n dev account create -p my-pass { &amp;#34;ok&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;0x2f1aeb63bd30d8eb841d6a941c5d6df3&amp;#34;, &amp;#34;is_default&amp;#34;: false, &amp;#34;is_readonly&amp;#34;: false, &amp;#34;public_key&amp;#34;: &amp;#34;0x91f79bdd9ced49332bf85b751d02339e05aff047c386d0c14b380d8519d2fb4b&amp;#34;, &amp;#34;receipt_identifier&amp;#34;: &amp;#34;stc1p9udwkcaaxrvwhpqad22pchtd7vy2276p&amp;#34; } } As above we can see our account has been created, and the address is: 0x2f1aeb63bd30d8eb841d6a941c5d6df3.</description>
    </item>
    
    <item>
      <title>Luck Surface Area: How to Get Lucky In Life(a Note of &#34;How to Get Rich&#34;)</title>
      <link>https://notes.0081800.xyz/notes/20220615183503-luck_surface_area_how_to_get_lucky_in_life_a_note_of_how_to_get_rich/</link>
      <pubDate>Wed, 15 Jun 2022 18:35:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220615183503-luck_surface_area_how_to_get_lucky_in_life_a_note_of_how_to_get_rich/</guid>
      <description> tags: Career,How To Get Rich (without getting lucky) source: Frontera. “Luck Surface Area: How to Get Lucky In Life,” May 31, 2022. https://fronterablog.com/luck-surface-area/. 5 ways to expand your luck surface area:
Do &amp;amp; Tell, don&amp;rsquo;t miss the &amp;ldquo;telling&amp;rdquo; part. Follow your curiosity Talk to new peopli Build a personal brand Take luck as a skill </description>
    </item>
    
    <item>
      <title>Rust libp2p</title>
      <link>https://notes.0081800.xyz/notes/20220615073334-rust_libp2p/</link>
      <pubDate>Wed, 15 Jun 2022 07:33:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220615073334-rust_libp2p/</guid>
      <description>tags: libp2p,Starcoin Web3 StarTrek source: https://docs.rs/libp2p/0.45.1/libp2p/tutorials/index.html Ping: Four necessary traits Identity: PeerId and corresponding Keypair Transport: send and receive bytes on the network. NetworkBehaviour: decode or encode the bytes from the Transport. Swarm: drives both a Transport and a NetworkBehaviour forward. use futures::StreamExt; use libp2p::ping::{Ping, PingConfig}; use libp2p::{identity, Multiaddr, PeerId, Swarm}; use std::error::Error; #[async_std::main] async fn main() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt; { // First we need to create a network identity.</description>
    </item>
    
    <item>
      <title>Distributed Hash Table</title>
      <link>https://notes.0081800.xyz/notes/20220615072945-distributed_hash_table_dht/</link>
      <pubDate>Wed, 15 Jun 2022 07:29:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220615072945-distributed_hash_table_dht/</guid>
      <description> tags: P2P,libp2p,Starcoin Web3 StarTrek </description>
    </item>
    
    <item>
      <title>libp2p</title>
      <link>https://notes.0081800.xyz/notes/20220615071057-libp2p/</link>
      <pubDate>Wed, 15 Jun 2022 07:10:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220615071057-libp2p/</guid>
      <description>tags: P2P,Starcoin Web3 StarTrek,Network source: https://docs.libp2p.io/ A set of protocols for peer identity, discover, routing, transport and more.
Peer-to-peer network Peers or nodes communicate with oen another directly, it&amp;rsquo;s different from the client-server architecture.
libp2p Solved Transport abstract data transmission and receipt to adapte many protocols, include the future protocols.
Identity use public key cryptography as the basis of peer identity， with this:
It gives each peer a globally unique &amp;ldquo;name&amp;rdquo;, in the form of a PeerId.</description>
    </item>
    
    <item>
      <title>P2P</title>
      <link>https://notes.0081800.xyz/notes/20220615070942-p2p/</link>
      <pubDate>Wed, 15 Jun 2022 07:09:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220615070942-p2p/</guid>
      <description> tags: Starcoin Web3 StarTrek,Blockchain </description>
    </item>
    
    <item>
      <title>starcoin#3450</title>
      <link>https://notes.0081800.xyz/notes/20220611164505-starcoin_3450/</link>
      <pubDate>Sat, 11 Jun 2022 16:45:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220611164505-starcoin_3450/</guid>
      <description>tags: Starcoin Web3 StarTrek,starcoin issue solving Today I saw this issue: starcoin#3450 at GitHub, I decide to give it a try.
The corresponding type VMStatus is defined out of starcoin&amp;rsquo;s reposiotry, here.
The work need to be done seems are:
convert function from u16 to a readable string. convert status_code from StatusCode to a readable string. Let&amp;rsquo;s take a look at StatusCode first, StatusCode is a enum that contains lot of variants, WOW!</description>
    </item>
    
    <item>
      <title>starcoin issue solving</title>
      <link>https://notes.0081800.xyz/notes/20220611154932-starcoin_issue_solving/</link>
      <pubDate>Sat, 11 Jun 2022 15:49:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220611154932-starcoin_issue_solving/</guid>
      <description> tags: Starcoin Web3 StarTrek </description>
    </item>
    
    <item>
      <title>Addressable Merkle Tree(AMT)</title>
      <link>https://notes.0081800.xyz/notes/20220607191822-addressable_merkle_tree_amt/</link>
      <pubDate>Tue, 07 Jun 2022 19:18:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220607191822-addressable_merkle_tree_amt/</guid>
      <description>tags: Merkle tree,Blockchain,Starcoin Web3 StarTrek source: Gao, Zhenhuan, Yuxuan Hu, and Qinfan Wu. “Jellyfish Merkle Tree,” n.d., 12. What is Addressable mean? It means the leaf node in the tree can be found by an address. The address encoded the path to the leaf node, for example, a leaf node in a binary tree, which has 3 level. Its address may be encoded to 010, the corresponding path is: left-&amp;gt;right-&amp;gt;left:</description>
    </item>
    
    <item>
      <title>UTXO VS. ACCOUNT MODEL</title>
      <link>https://notes.0081800.xyz/notes/20220607185225-utxo_vs_account_model/</link>
      <pubDate>Tue, 07 Jun 2022 18:52:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220607185225-utxo_vs_account_model/</guid>
      <description> tags: Starcoin Web3 StarTrek,Account-Model Blockchain Systems source: https://academy.horizen.io/technology/expert/utxo-vs-account-model/ </description>
    </item>
    
    <item>
      <title>Account-Model Blockchain Systems</title>
      <link>https://notes.0081800.xyz/notes/20220607185130-account_model_blockchain_systems/</link>
      <pubDate>Tue, 07 Jun 2022 18:51:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220607185130-account_model_blockchain_systems/</guid>
      <description> tags: Starcoin Web3 StarTrek,Ethereum,Merkle tree </description>
    </item>
    
    <item>
      <title>Patricia Merkle Tree</title>
      <link>https://notes.0081800.xyz/notes/20220607184852-patricia_merkle_tree/</link>
      <pubDate>Tue, 07 Jun 2022 18:48:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220607184852-patricia_merkle_tree/</guid>
      <description>tags: Starcoin Web3 StarTrek,Merkle tree,Ethereum Powers the widely known Ethereum network.</description>
    </item>
    
    <item>
      <title>Seal is a verifiable timestamp mechanism for cryptographically proving that a note is created before a specific time.</title>
      <link>https://notes.0081800.xyz/notes/20220606141221-seal_is_a_verifiable_timestamp_mechanism_for_cryptographically_proving_that_a_note_is_created_before_a_specific_time/</link>
      <pubDate>Mon, 06 Jun 2022 14:12:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220606141221-seal_is_a_verifiable_timestamp_mechanism_for_cryptographically_proving_that_a_note_is_created_before_a_specific_time/</guid>
      <description>tags: Let&amp;rsquo;s Encrypt,Merkle tree source: https://docs.planet.ink/data/seal/ This idea is genius, it use a merkle tree to combine serval notes. And use the root hash of merkel tree to obtain a certificate from Let&amp;rsquo;s Encrypt.</description>
    </item>
    
    <item>
      <title>Binary Search : Median of two sorted arrays of different sizes.</title>
      <link>https://notes.0081800.xyz/notes/20220606071010-binary_search_median_of_two_sorted_arrays_of_different_sizes/</link>
      <pubDate>Mon, 06 Jun 2022 07:10:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220606071010-binary_search_median_of_two_sorted_arrays_of_different_sizes/</guid>
      <description>tags: Binary Search,LeetCodeNJ YouTube: https://www.youtube.com/watch?v=LPFhl65R7ww The most difficult thing is doing binary search among two sorted arrays, in this video Tushar Roy given us a straightforward method of how to do binary search among tow sorted arrays.
Assume we have two sorted arrays, X and Y, and cut them between at x2,x3 and y3,y4:
If we meet the conditions:
x2 &amp;lt;= y3 y2 &amp;lt;= x3 then we find the median postion, as the merged arrays of the four elements may be order by:</description>
    </item>
    
    <item>
      <title>LeetCodeNJ</title>
      <link>https://notes.0081800.xyz/notes/20220606071040-leetcodenj/</link>
      <pubDate>Mon, 06 Jun 2022 07:10:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220606071040-leetcodenj/</guid>
      <description>tags: Algorithm,Data Structures Make my best effort to move to Nanjing for my son. This is a successor of LeetCode101.</description>
    </item>
    
    <item>
      <title>Starcoin Blockchain from Scartch</title>
      <link>https://notes.0081800.xyz/notes/20220602110916-starcoin_blockchain/</link>
      <pubDate>Thu, 02 Jun 2022 11:09:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220602110916-starcoin_blockchain/</guid>
      <description>tags: Starcoin Web3 StarTrek,Blockchain Overview Block is the basic element in a blockchain system, as we known blockchain system is just a ledger, which means a bookkeeping1 that recording of financial transactions. In the blockchain system, those transactions are stored in the blocks. In each block, the data stored in may look like:
TXN FROM TO VALUE #0 God Cale 100 #1 Cale Alice 10 #2 Alice Bob 1 #3 Bob Mike 0.</description>
    </item>
    
    <item>
      <title>Sparse Merkle Tree</title>
      <link>https://notes.0081800.xyz/notes/20220602102655-sparse_merkle_tree/</link>
      <pubDate>Thu, 02 Jun 2022 10:26:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220602102655-sparse_merkle_tree/</guid>
      <description> tags: Merkle tree,Starcoin Web3 StarTrek </description>
    </item>
    
    <item>
      <title>Jellyfish Merkle Tree</title>
      <link>https://notes.0081800.xyz/notes/20220602102439-jellyfish_merkle_tree/</link>
      <pubDate>Thu, 02 Jun 2022 10:24:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220602102439-jellyfish_merkle_tree/</guid>
      <description>tags: Starcoin Web3 StarTrek,Sparse Merkle Tree,Merkle tree,LSM-Tree,Account-Model Blockchain Systems source: Gao, Zhenhuan, Yuxuan Hu, and Qinfan Wu. “Jellyfish Merkle Tree,” n.d., 12. JMT(Jellyfish Merkle Tree) a LSM-tree based Implementation of Sparse Merkle Tree Inspired by Patricia Merkle Tree and has been implemented in Rust, but it is language-independent.
Merkel tree fits pretty well as an authenticated key-value store holding a huge amount of data in a tamper-proof way.
Two major concerns where people have been trying to achieve some enhnacements:</description>
    </item>
    
    <item>
      <title>Starcoin PoW</title>
      <link>https://notes.0081800.xyz/notes/20220601190052-starcoin_pow/</link>
      <pubDate>Wed, 01 Jun 2022 19:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220601190052-starcoin_pow/</guid>
      <description> tags: Starcoin Web3 StarTrek, Proof-of-work Generate nonce (random data) as salt to join to the data of block to be hash. The goal is to find a hash value that less than target. The target is influenced by difficulty. As the difficulty gets bigger and the target will be smaller, which means more difficult to find.
pub fn difficult_to_target(difficulty: U256) -&amp;gt; U256 { U256::max_value() / difficulty } </description>
    </item>
    
    <item>
      <title>Merkle tree</title>
      <link>https://notes.0081800.xyz/notes/20220601110304-merkle_tree/</link>
      <pubDate>Wed, 01 Jun 2022 11:03:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220601110304-merkle_tree/</guid>
      <description>tags: Starcoin Web3 StarTrek,Blockchain source: Wikipedia: Merkle tree Starcoin Cookbook What is a Merkle tree. Merkle tree is a hash tree, named after Ralph Merkle, who patented in 1979.
Most implementations of them are binary, which means two child nodes under each node.
Why the merkle tree is important to the peer-to-peer network? The main purpose of a merkle tree is to ensure the data we received from a peer-to-peer network are undamaged and unaltered, it&amp;rsquo;s important as the data were splitted into many blocks and stored in multiple nodes in the network.</description>
    </item>
    
    <item>
      <title>Starcoin Learn Resource</title>
      <link>https://notes.0081800.xyz/notes/20220601104619-starcoin_learn_resource/</link>
      <pubDate>Wed, 01 Jun 2022 10:46:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220601104619-starcoin_learn_resource/</guid>
      <description> tags: Starcoin Web3 StarTrek The documentation of Starcoin are written in multiple places:
The Developers Documentation on the main site English Version Chinese Version The Starcoin Cookbook English Version Chinese Version </description>
    </item>
    
    <item>
      <title>Compile Starcoin from Source And Setup a Dev Node</title>
      <link>https://notes.0081800.xyz/notes/20220531133557-compile_starcoin_and_setup_a_dev_node/</link>
      <pubDate>Tue, 31 May 2022 13:35:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220531133557-compile_starcoin_and_setup_a_dev_node/</guid>
      <description>tags: Starcoin Web3 StarTrek Why compile starcoin from source? Why not download a released binary? Because I want to contribute code to it, maybe in the future.
But the toolchain is awesome, the progress is very simple. Just two steps:
Clone the code from GitHub
git clone git@github.com:starcoinorg/starcoin.git Run scripts/dev_setup.sh:
cd starcoin ./scripts/dev_setup.sh Then we are ready to compile:
cargo build Wait? You haven&amp;rsquo;t install Rust yet? Please refer to Getting started.</description>
    </item>
    
    <item>
      <title>Starcoin Web3 StarTrek</title>
      <link>https://notes.0081800.xyz/notes/20220531104515-starcoin_web3_startrek/</link>
      <pubDate>Tue, 31 May 2022 10:45:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220531104515-starcoin_web3_startrek/</guid>
      <description>tags: Web3 Learn journal of Starcoin Web3 StarTrek Program, check the follow &amp;ldquo;Links to this note&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Blogchain</title>
      <link>https://notes.0081800.xyz/notes/20220531102226-blogchain/</link>
      <pubDate>Tue, 31 May 2022 10:22:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220531102226-blogchain/</guid>
      <description> tags: ipfs source: https://blogchain.app/home </description>
    </item>
    
    <item>
      <title>ipfs</title>
      <link>https://notes.0081800.xyz/notes/20220531102232-ipfs/</link>
      <pubDate>Tue, 31 May 2022 10:22:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220531102232-ipfs/</guid>
      <description> source: https://github.com/ipfs/ipfs site: https://ipfs.io/ </description>
    </item>
    
    <item>
      <title>IPFS</title>
      <link>https://notes.0081800.xyz/notes/20220531102139-ipfs/</link>
      <pubDate>Tue, 31 May 2022 10:21:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220531102139-ipfs/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Words that I always forgot</title>
      <link>https://notes.0081800.xyz/notes/20220514204502-words_that_i_always_forgot/</link>
      <pubDate>Sat, 14 May 2022 20:45:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220514204502-words_that_i_always_forgot/</guid>
      <description>Some words that I always forget util I wrote it down:
discipline collapse phantom </description>
    </item>
    
    <item>
      <title>Fast bitset decoding using Intel AVX-512</title>
      <link>https://notes.0081800.xyz/notes/20220512182310-fast_bitset_decoding_using_intel_avx_512/</link>
      <pubDate>Thu, 12 May 2022 18:23:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220512182310-fast_bitset_decoding_using_intel_avx_512/</guid>
      <description> tags: High Performance,SIMD source: Lemire, Author Daniel. “Fast Bitset Decoding Using Intel AVX-512.” Daniel Lemire’s Blog (blog). Accessed May 12, 2022. https://lemire.me/blog/2022/05/06/fast-bitset-decoding-using-intel-avx-512/. </description>
    </item>
    
    <item>
      <title>Master’s Degree in Computer Science</title>
      <link>https://notes.0081800.xyz/notes/20220506111914-master_s_degree_in_computer_science/</link>
      <pubDate>Fri, 06 May 2022 11:19:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220506111914-master_s_degree_in_computer_science/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Master’s Degree in Computer Science</title>
      <link>https://notes.0081800.xyz/notes/20220506111923-master_s_degree_in_computer_science/</link>
      <pubDate>Fri, 06 May 2022 11:19:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220506111923-master_s_degree_in_computer_science/</guid>
      <description> tags: Degree source: evanprodromou. “Master’s Degree in Computer Science.” Evan Prodromou’s Blog (blog), May 4, 2022. https://evanp.me/2022/05/04/masters-degree-in-computer-science/. </description>
    </item>
    
    <item>
      <title>【01B0801】 计算机及应用（独立本科段）</title>
      <link>https://notes.0081800.xyz/notes/20220506104347-01b0801_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%8A%E5%BA%94%E7%94%A8_%E7%8B%AC%E7%AB%8B%E6%9C%AC%E7%A7%91%E6%AE%B5/</link>
      <pubDate>Fri, 06 May 2022 10:43:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220506104347-01b0801_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%8A%E5%BA%94%E7%94%A8_%E7%8B%AC%E7%AB%8B%E6%9C%AC%E7%A7%91%E6%AE%B5/</guid>
      <description>tags: Degree source: “【01B0801】 计算机及应用（独立本科段）.” Accessed May 6, 2022. http://zkxcx.bjeea.cn/portal/kszylb.jsp?zydm=01B0801&amp;amp;amp;tab=2. Required Courses Code Name Credit Type Level1 Status2 Free Online Courses 03708 中国近现代史纲要 2 Political 5 pending 03708 马克思主义基本原理概论 4 Political 5 pending 00015 英语（二） 14 Basic 1 passed 00023 高等数学（工本） 10 Basic 7 pending 02197 概率论与数理统计（二） 3 Basic 7 pending 02324 离散数学 4 CS 7 pending 腾讯课堂 04737 C++程序设计 3 CS 1 pending 04738 C++程序设计（实践） 2 CS - pending 02326 操作系统 4 CS 2 pending 02327 操作系统（实践） 1 CS - pending 02331 数据结构 3 CS 2 pending 04734 数据结构（实践） 2 CS - pending 02325 计算机系统结构 4 CS 3 pending 04735 数据库系统原理 4 CS 1 pending 04736 数据库系统原理（实践） 2 CS - pending 02333 软件工程 3 CS 3 pending 02334 软件工程（实践） 1 CS - pending 04741 计算机网络原理 4 CS 2 pending 04747 Java语言程序设计（一） 3 CS 1 pending 04748 Java语言程序设计（一）（实践） 1 CS 1 pending 10027 计算机及应用专业毕业设计 0 CS 1 wait Summary:</description>
    </item>
    
    <item>
      <title>Carr</title>
      <link>https://notes.0081800.xyz/notes/20220506102543-carr/</link>
      <pubDate>Fri, 06 May 2022 10:25:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220506102543-carr/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Why I Decide to Get A Computer Science Degree in 2022</title>
      <link>https://notes.0081800.xyz/notes/20220506102535-why_i_decide_to_get_a_computer_science_degree_in_2022/</link>
      <pubDate>Fri, 06 May 2022 10:25:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220506102535-why_i_decide_to_get_a_computer_science_degree_in_2022/</guid>
      <description>tags: Degree, Career I haven&amp;rsquo;t got a CS degree, it wasn&amp;rsquo;t a big deal when I was yonger, as I was cheap and many employers could affort, and didn&amp;rsquo;t care too much about it.
But now days, when I&amp;rsquo;m 30+ years old, and not cheap anymore. The employers who can affort me are much less. And most of them are required a CS degree, so the degree is important to me now.</description>
    </item>
    
    <item>
      <title>My experience getting a tech job with no degree or relevant work experience</title>
      <link>https://notes.0081800.xyz/notes/20220506101358-my_experience_getting_a_tech_job_with_no_degree_or_relevant_work_experience/</link>
      <pubDate>Fri, 06 May 2022 10:13:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220506101358-my_experience_getting_a_tech_job_with_no_degree_or_relevant_work_experience/</guid>
      <description> tags: Degree source: Engineer, Lowly Midwestern. “My Experience Getting a Tech Job with No Degree or Relevant Work Experience.” Substack newsletter. Lowly Midwestern Engineers’ Newsletter (blog), May 2, 2022. https://lowlyswe.substack.com/p/my-experience-getting-a-tech-job. </description>
    </item>
    
    <item>
      <title>How I Got a Computer Science Degree in 3 Months for Less Than $5000 | Miguel Rochefort</title>
      <link>https://notes.0081800.xyz/notes/20220506101023-how_i_got_a_computer_science_degree_in_3_months_for_less_than_5000_miguel_rochefort/</link>
      <pubDate>Fri, 06 May 2022 10:10:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220506101023-how_i_got_a_computer_science_degree_in_3_months_for_less_than_5000_miguel_rochefort/</guid>
      <description> tags: Degree source: “How I Got a Computer Science Degree in 3 Months for Less Than $5000 | Miguel Rochefort.” Accessed April 28, 2022. https://miguelrochefort.com/blog/cs-degree/. </description>
    </item>
    
    <item>
      <title>Degree</title>
      <link>https://notes.0081800.xyz/notes/20220506100932-degree/</link>
      <pubDate>Fri, 06 May 2022 10:09:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220506100932-degree/</guid>
      <description> tags: Career </description>
    </item>
    
    <item>
      <title>Luhn algorithm using SWAR and SIMD</title>
      <link>https://notes.0081800.xyz/notes/20220505144135-luhn_algorithm_using_swar_and_simd/</link>
      <pubDate>Thu, 05 May 2022 14:41:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220505144135-luhn_algorithm_using_swar_and_simd/</guid>
      <description>tags: SIMD,High Performance source: “Luhn Algorithm Using SWAR and SIMD.” Accessed May 5, 2022. https://nullprogram.com/blog/2022/04/30/. 3x increase after used SIMD.</description>
    </item>
    
    <item>
      <title>Removing characters from strings faster with AVX-512</title>
      <link>https://notes.0081800.xyz/notes/20220505141919-removing_characters_from_strings_faster_with_avx_512/</link>
      <pubDate>Thu, 05 May 2022 14:19:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220505141919-removing_characters_from_strings_faster_with_avx_512/</guid>
      <description>tags: SSE/AVX/AVX2/AVX512,High Performance source: Lemire, Author Daniel. “Removing Characters from Strings Faster with AVX-512.” Daniel Lemire’s Blog (blog). Accessed May 5, 2022. https://lemire.me/blog/2022/04/28/removing-characters-from-strings-faster-with-avx-512/. It&amp;rsquo;s 21.25 times faster with AVX-152: 0.4 GB/s to 8.5 GB/s.</description>
    </item>
    
    <item>
      <title>GnuPG Can not Sign Commit with Magit in Terminal Text Mode</title>
      <link>https://notes.0081800.xyz/notes/20220501082812-gnupg_can_not_sign_commit_with_magit_in_terminal_text_mode/</link>
      <pubDate>Sun, 01 May 2022 08:28:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220501082812-gnupg_can_not_sign_commit_with_magit_in_terminal_text_mode/</guid>
      <description>tags: Emacs,GnuPG Pinentry,GnuPG,GnuPG Agent There is a little bit more background here: I&amp;rsquo;m using Windows Subsystem Linux(WSL) now, which means I was running Emacs in a virtual machine with Debian Linux distro.
And also I ran Emacs in GUI mode with WSL, the pinentry for GnuPG Agent is: /usr/bin/pinentry-gtk2, everything was prefect.
This morning I couldn&amp;rsquo;t commit with Magit in Emacs, when I was running my Emacs in Terminal Text Mode.</description>
    </item>
    
    <item>
      <title>GnuPG</title>
      <link>https://notes.0081800.xyz/notes/20220501082607-gnupg/</link>
      <pubDate>Sun, 01 May 2022 08:26:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220501082607-gnupg/</guid>
      <description> tags: Unix,Tools </description>
    </item>
    
    <item>
      <title>GnuPG Agent</title>
      <link>https://notes.0081800.xyz/notes/20220501082647-gnupg_agent/</link>
      <pubDate>Sun, 01 May 2022 08:26:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220501082647-gnupg_agent/</guid>
      <description> tags: GnuPG </description>
    </item>
    
    <item>
      <title>GnuPG Pinentry</title>
      <link>https://notes.0081800.xyz/notes/20220501082558-gnupg_pinentry/</link>
      <pubDate>Sun, 01 May 2022 08:25:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220501082558-gnupg_pinentry/</guid>
      <description> tags: GnuPG,GnuPG Agent </description>
    </item>
    
    <item>
      <title>Graph</title>
      <link>https://notes.0081800.xyz/notes/20220427074209-graph/</link>
      <pubDate>Wed, 27 Apr 2022 07:42:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220427074209-graph/</guid>
      <description> tags: Data Structures,Algorithm </description>
    </item>
    
    <item>
      <title>Minimum spanning tree</title>
      <link>https://notes.0081800.xyz/notes/20220427074048-minimum_spanning_tree/</link>
      <pubDate>Wed, 27 Apr 2022 07:40:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220427074048-minimum_spanning_tree/</guid>
      <description> tags: Algorithm,Tree,Graph source: https://en.wikipedia.org/wiki/Minimum%5Fspanning%5Ftree </description>
    </item>
    
    <item>
      <title>NUMA</title>
      <link>https://notes.0081800.xyz/notes/20220416080519-numa/</link>
      <pubDate>Sat, 16 Apr 2022 08:05:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220416080519-numa/</guid>
      <description> tags: High Performance source: https://en.wikipedia.org/wiki/Non-uniform_memory_access </description>
    </item>
    
    <item>
      <title>netstat</title>
      <link>https://notes.0081800.xyz/notes/20220416075544-netstat/</link>
      <pubDate>Sat, 16 Apr 2022 07:55:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220416075544-netstat/</guid>
      <description> tags: Linux,Network,Tools netstat -s: show network status(errors) # show udp status $ netstat -s --udp Udp: 437.0k/s packets received 0.0/s packets to unknown port received. 386.9k/s packet receive errors 0.0/s packets sent RcvbufErrors: 123.8k/s SndbufErrors: 0 InCsumErrors: 0 </description>
    </item>
    
    <item>
      <title>ethtool</title>
      <link>https://notes.0081800.xyz/notes/20220416073825-ethtool/</link>
      <pubDate>Sat, 16 Apr 2022 07:38:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220416073825-ethtool/</guid>
      <description> tags: Linux,Network,TCP,UDP,Tools ethtool -S: Reveal where the packets actuaaly went receiver$ watch &amp;#39;sudo ethtool -S eth2 |grep rx&amp;#39; rx_nodesc_drop_cnt: 451.3k/s rx-0.rx_packets: 8.0/s rx-1.rx_packets: 0.0/s rx-2.rx_packets: 0.0/s rx-3.rx_packets: 0.5/s rx-4.rx_packets: 355.2k/s rx-5.rx_packets: 0.0/s rx-6.rx_packets: 0.0/s rx-7.rx_packets: 0.5/s rx-8.rx_packets: 0.0/s rx-9.rx_packets: 0.0/s rx-10.rx_packets: 0.0/s </description>
    </item>
    
    <item>
      <title>Multi-queue NICs</title>
      <link>https://notes.0081800.xyz/notes/20220416073757-multi_queue_nics/</link>
      <pubDate>Sat, 16 Apr 2022 07:37:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220416073757-multi_queue_nics/</guid>
      <description>tags: Linux,High Performance,Network,ethtool source: The Cloudflare Blog. “How to Receive a Million Packets per Second,” June 16, 2015. http://blog.cloudflare.com/how-to-receive-a-million-packets/. What are Multi-queue NICs RX queue was used to pass packets between hardware and kernel. Now days NICs support multiple RX queues: Each RX queue is pinned to a separate CPU.
Multi-queue hashing algorithms Use a hash from packet to decide the RX queue number. The hash is usually counted from a tuple (src IP, dst IP, src port, dst port).</description>
    </item>
    
    <item>
      <title>iptables</title>
      <link>https://notes.0081800.xyz/notes/20220416073414-iptables/</link>
      <pubDate>Sat, 16 Apr 2022 07:34:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220416073414-iptables/</guid>
      <description> tags: Network,Linux,Tools </description>
    </item>
    
    <item>
      <title>Assembly</title>
      <link>https://notes.0081800.xyz/notes/20220415065058-assembly/</link>
      <pubDate>Fri, 15 Apr 2022 06:50:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220415065058-assembly/</guid>
      <description></description>
    </item>
    
    <item>
      <title>How to receive a million packets per second</title>
      <link>https://notes.0081800.xyz/notes/20220414185003-how_to_receive_a_million_packets_per_second/</link>
      <pubDate>Thu, 14 Apr 2022 18:50:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220414185003-how_to_receive_a_million_packets_per_second/</guid>
      <description>tags: Network,UDP,High Performance,iptables,ethtool,netstat,NUMA source: The Cloudflare Blog. “How to Receive a Million Packets per Second,” June 16, 2015. http://blog.cloudflare.com/how-to-receive-a-million-packets/. Keys:
Make sure traffic won&amp;rsquo;t be interfered with by the iptables
iptables -I INPUT 1 -p udp --dport 4321 -j ACCEPT iptables -t raw -I PREROUTING 1 -p udp --dport 4321 -j NOTRACK #+end_src[[id:C471A6FF-7F4E-4E23-B070-14CE146BFA14][Multi-queue NICs]] 2. The first bottleneck ​	+ All packets are received by a signal RX queue, checked out with =ethtool -S=.</description>
    </item>
    
    <item>
      <title>UDP</title>
      <link>https://notes.0081800.xyz/notes/20220414185017-udp/</link>
      <pubDate>Thu, 14 Apr 2022 18:50:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220414185017-udp/</guid>
      <description> tags: Network </description>
    </item>
    
    <item>
      <title>Multicast</title>
      <link>https://notes.0081800.xyz/notes/20220414161423-multicast/</link>
      <pubDate>Thu, 14 Apr 2022 16:14:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220414161423-multicast/</guid>
      <description> tags: Network </description>
    </item>
    
    <item>
      <title>Clock Synchronization</title>
      <link>https://notes.0081800.xyz/notes/20220414150932-clock_synchronization/</link>
      <pubDate>Thu, 14 Apr 2022 15:09:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220414150932-clock_synchronization/</guid>
      <description> tags: Distributed Systems </description>
    </item>
    
    <item>
      <title>C&#43;&#43; Lambda</title>
      <link>https://notes.0081800.xyz/notes/20220409082936-c_lambda/</link>
      <pubDate>Sat, 09 Apr 2022 08:29:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220409082936-c_lambda/</guid>
      <description> tags: C/C++ Capture a map with reference If we capture a map by value, then we can&amp;rsquo;t use the operator []:
unordered_map&amp;lt;int, int&amp;gt; freq; // Won&amp;#39;t compile // auto comp_by_map = [freq](const int&amp;amp; a, const int&amp;amp; b) { return freq[a] &amp;lt; freq[b];}; auto comp_by_map = [&amp;amp;freq](const int&amp;amp; a, const int&amp;amp; b) { return freq[a] &amp;lt; freq[b];}; </description>
    </item>
    
    <item>
      <title>LeetCode101: 347. Top K Frequent Elements</title>
      <link>https://notes.0081800.xyz/notes/20220409082813-leetcode101_347_top_k_frequent_elements/</link>
      <pubDate>Sat, 09 Apr 2022 08:28:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220409082813-leetcode101_347_top_k_frequent_elements/</guid>
      <description>tags: Hash Table,Heap (data structure),LeetCode101,Priority Queue,C++ Lambda class Solution { public: vector&amp;lt;int&amp;gt; topKFrequent(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { vector&amp;lt;int&amp;gt; res; unordered_map&amp;lt;int, int&amp;gt; freq; // Note that: we need caputre a map by reference, // otherwise we can&amp;#39;t use the operator[]. // See also: https://stackoverflow.com/a/6281071 auto comp_by_map = [&amp;amp;freq](const int&amp;amp; a, const int&amp;amp; b) { return freq[a] &amp;lt; freq[b]; }; // Note that: here we need pass our lambda /comp_by_map/ to the // constructor of std::priority_queue.</description>
    </item>
    
    <item>
      <title>LeetCode101: 27. Remove Element</title>
      <link>https://notes.0081800.xyz/notes/20220408131130-leetcode101_27_remove_element/</link>
      <pubDate>Fri, 08 Apr 2022 13:11:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220408131130-leetcode101_27_remove_element/</guid>
      <description> tags: LeetCode101,In-place Travel array in reverse order, and record how many times need to swap, which is how many elements not equal val.
class Solution { public: int removeElement(vector&amp;lt;int&amp;gt;&amp;amp; nums, int val) { int k = 0; for (int j = nums.size() - 1; j &amp;gt;= 0; --j) { if (nums[j] == val) { for (int i = 0; i &amp;lt; k; ++i) { swap(nums[i + j], nums[j + i + 1]); } } else { k++; } } return k; } }; </description>
    </item>
    
    <item>
      <title>LeetCode101: 18. 4Sum</title>
      <link>https://notes.0081800.xyz/notes/20220408125015-leetcode101_18_4sum/</link>
      <pubDate>Fri, 08 Apr 2022 12:50:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220408125015-leetcode101_18_4sum/</guid>
      <description>tags: Two Pointers,Three Pointers,LeetCode101,Sorting Based on:
LeetCode101: 167. Two Sum II - Input Array Is Sorted LeetCode101: 15. 3Sum We create a new loop:
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; fourSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { sort(nums.begin(), nums.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; int T, S, r, l; for (int i = 0; i &amp;lt; nums.size(); ++i) { if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1]) { continue; } for (int j = i + 1; j &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>LeetCode101: 703. Kth Largest Element in a Stream</title>
      <link>https://notes.0081800.xyz/notes/20220408123913-leetcode101_703_kth_largest_element_in_a_stream/</link>
      <pubDate>Fri, 08 Apr 2022 12:39:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220408123913-leetcode101_703_kth_largest_element_in_a_stream/</guid>
      <description> tags: Priority Queue,LeetCode101 Using a min heap to keep k elements, top is the Kth largest element.
class KthLargest { private: // min heap priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, std::greater&amp;lt;int&amp;gt;&amp;gt; pq; int K; public: KthLargest(int k, vector&amp;lt;int&amp;gt;&amp;amp; nums) { K = k; for (auto n: nums) { add(n); } } int add(int val) { pq.push(val); while (pq.size() &amp;gt; K) { pq.pop(); } return pq.top(); } }; /** * Your KthLargest object will be instantiated and called as such: * KthLargest* obj = new KthLargest(k, nums); * int param_1 = obj-&amp;gt;add(val); */ </description>
    </item>
    
    <item>
      <title>LeetCode101: 1046. Last Stone Weight</title>
      <link>https://notes.0081800.xyz/notes/20220408070926-leetcode101_1046_last_stone_weight/</link>
      <pubDate>Fri, 08 Apr 2022 07:09:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220408070926-leetcode101_1046_last_stone_weight/</guid>
      <description> tags: Heap (data structure),LeetCode101 Find top k values, classical heap problems.
Here we need find top 2 values, and pop them from heap, then we will meet two cases:
If they are not same, put back the differ between them, continue. Otherwise, continue directly. </description>
    </item>
    
    <item>
      <title>LeetCode101: 167. Two Sum II - Input Array Is Sorted</title>
      <link>https://notes.0081800.xyz/notes/20220407081954-leetcode101_167_two_sum_ii_input_array_is_sorted/</link>
      <pubDate>Thu, 07 Apr 2022 08:19:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220407081954-leetcode101_167_two_sum_ii_input_array_is_sorted/</guid>
      <description> tags: LeetCode101,Sorting,Two Pointers Key ideas:
Move both sides to inwards. If the sum value less than target, move left pointer. Otherwise move right poinger. class Solution { public: vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; numbers, int target) { int S, l = 0, r = numbers.size() - 1; vector&amp;lt;int&amp;gt; res(2, 0); while (l &amp;lt; r) { S = numbers[l] + numbers[r]; if (S == target) { break; } if (S &amp;lt; target) { l++; } else { r--; } } res[0] = l + 1; res[1] = r + 1; return res; } }; </description>
    </item>
    
    <item>
      <title>LeetCode101: 16. 3Sum Closest</title>
      <link>https://notes.0081800.xyz/notes/20220407081015-leetcode101_16_3sum_closest/</link>
      <pubDate>Thu, 07 Apr 2022 08:10:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220407081015-leetcode101_16_3sum_closest/</guid>
      <description> tags: LeetCode101,Sorting,Two Pointers,Three Pointers Key ideas see LeetCode101: 15. 3Sum
class Solution { public: int threeSumClosest(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { sort(nums.begin(), nums.end()); int closest = INT_MAX, l, r, sum, T, res; for (int i = 0; i &amp;lt; nums.size(); i++) { l = i + 1; r = nums.size() - 1; T = target - nums[i]; while (l &amp;lt; r) { sum = nums[l] + nums[r]; if (abs(sum - T) &amp;lt; closest) { res = sum + nums[i]; closest = abs(sum - T); } if (sum == T) { return target; } if (sum &amp;lt; T) { l++; } else { r--; } } } return res; } }; </description>
    </item>
    
    <item>
      <title>LeetCode101: 15. 3Sum</title>
      <link>https://notes.0081800.xyz/notes/20220407080010-leetcode101_15_3sum/</link>
      <pubDate>Thu, 07 Apr 2022 08:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220407080010-leetcode101_15_3sum/</guid>
      <description>tags: LeetCode101,Sorting,Two Pointers,Three Pointers Key ideas:
Sort the nums first. Then, we travel the nums, pick current element as nums[i], and apply LeetCode101: 167. Two Sum II - Input Array Is Sorted to the remains. We skip the same numbers to avoid duplicate. class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; threeSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.begin(), nums.end()); int l, r, sum, T; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; for (int i = 0; i &amp;lt; nums.size(); i++) { // Skip same numbers to avoid duplicate if(i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i-1]) { continue; } l = i + 1; r = nums.</description>
    </item>
    
    <item>
      <title>Three Pointers</title>
      <link>https://notes.0081800.xyz/notes/20220407080033-three_pointers/</link>
      <pubDate>Thu, 07 Apr 2022 08:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220407080033-three_pointers/</guid>
      <description> tags: Two Pointers </description>
    </item>
    
    <item>
      <title>LeetCode101: 680. Valid Palindrome II</title>
      <link>https://notes.0081800.xyz/notes/20220402143729-leetcode101_680_valid_palindrome_ii/</link>
      <pubDate>Sat, 02 Apr 2022 14:37:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220402143729-leetcode101_680_valid_palindrome_ii/</guid>
      <description>tags: String,Two Pointers,LeetCode101 Two pointers move inwards, when we meet two different characters:
Remove left character to see if the remains string still satisfied a valid palindrome. Remove right character to see if the remains string still satisfied a valid palindrome. Returns true if either one above two is true.
class Solution { public: bool validPalindrome(string s) { for (int i = 0, j = s.size() -1; i &amp;lt; j; i++,j--) { if (s[i] !</description>
    </item>
    
    <item>
      <title>In-place Reverse</title>
      <link>https://notes.0081800.xyz/notes/20220401104307-in_place_reverse/</link>
      <pubDate>Fri, 01 Apr 2022 10:43:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220401104307-in_place_reverse/</guid>
      <description>tags: In-place WikiPedia: https://en.wikipedia.org/wiki/In-place%5Falgorithm Let see two examples before we go further:
As above we can see, to reverse a array in-place, we just need swap each two elements in the array from both side to middle.
The pseudo code from WikiPedia:
function reverse_in_place(a[0..n-1]) for i from 0 to floor((n-2)/2) tmp := a[i] a[i] := a[n − 1 − i] a[n − 1 − i] := tmp The loop travels the array to the middle and swap each other in the list, two points we must be noticed:</description>
    </item>
    
    <item>
      <title>In-place</title>
      <link>https://notes.0081800.xyz/notes/20220401104238-in_place/</link>
      <pubDate>Fri, 01 Apr 2022 10:42:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220401104238-in_place/</guid>
      <description> tags: Algorithm </description>
    </item>
    
    <item>
      <title>LeetCode101: 344. Reverse String</title>
      <link>https://notes.0081800.xyz/notes/20220401104229-leetcode101_344_reverse_string/</link>
      <pubDate>Fri, 01 Apr 2022 10:42:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220401104229-leetcode101_344_reverse_string/</guid>
      <description> tags: In-place,LeetCode101,In-place Reverse class Solution { public: void reverseString(vector&amp;lt;char&amp;gt;&amp;amp; s) { if (s.size() == 1) { return; } for (int i = 0; i &amp;lt;= (s.size() - 2) / 2; ++i) { swap(s[s.size() - 1 - i], s[i]); } } }; </description>
    </item>
    
    <item>
      <title>LeetCode101: 35. Search Insert Position</title>
      <link>https://notes.0081800.xyz/notes/20220330165507-leetcode101_35_search_insert_position/</link>
      <pubDate>Wed, 30 Mar 2022 16:55:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220330165507-leetcode101_35_search_insert_position/</guid>
      <description>tags: Binary Search,LeetCode101 There is three corner cases must be handled if we don&amp;rsquo;t find target in nums:
Return r + 1 if target is greater than right. Or return mid + 1 if target is greater than mid. Otherwise return mid. class Solution { public: int searchInsert(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int l = 0, r = nums.size() - 1; int mid = r / 2; while (l !</description>
    </item>
    
    <item>
      <title>LeetCode101: 74. Search a 2D Matrix</title>
      <link>https://notes.0081800.xyz/notes/20220330160157-leetcode101_74_search_a_2d_matrix/</link>
      <pubDate>Wed, 30 Mar 2022 16:01:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220330160157-leetcode101_74_search_a_2d_matrix/</guid>
      <description> tags: Divide-and-Conquer,LeetCode101,Binary Search class Solution { public: bool searchMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;matrix, int target) { int n = matrix.size(); int m = matrix[0].size(); int l = 0, r = m * n - 1; while (l != r){ int mid = l + (r - l) / 2; if (matrix[mid / m][mid % m] &amp;lt; target) l = mid + 1; else r = mid; } return matrix[r / m][r % m] == target; } }; </description>
    </item>
    
    <item>
      <title>Divide-and-Conquer</title>
      <link>https://notes.0081800.xyz/notes/20220330155829-divide_and_conquer/</link>
      <pubDate>Wed, 30 Mar 2022 15:58:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220330155829-divide_and_conquer/</guid>
      <description> tags: Algorithm WIKIEPEDIA: https://en.wikipedia.org/wiki/Divide-and-conquer%5Falgorithm The points should been noted:
The middle position is not (right - left) / 2, it must be left + ((right - left) / 2). </description>
    </item>
    
    <item>
      <title>LeetCode101: 136. Single Number</title>
      <link>https://notes.0081800.xyz/notes/20220330070916-leetcode101_136_single_number/</link>
      <pubDate>Wed, 30 Mar 2022 07:09:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220330070916-leetcode101_136_single_number/</guid>
      <description>tags: Bit Manipulation,Bitwise Operator: XOR According to bitwise operator XOR:
x ^ x = 0 y ^ 0 = y We apply the XOR operator to all the nums, all the same numbers will apply x ^ x = 0, and then y ^ 0 = y will result the single number.
class Solution { public: int singleNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int xorN = 0; for (auto iter = nums.begin(); iter !</description>
    </item>
    
    <item>
      <title>Bit Manipulation</title>
      <link>https://notes.0081800.xyz/notes/20220330070500-bit_manipulation/</link>
      <pubDate>Wed, 30 Mar 2022 07:05:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220330070500-bit_manipulation/</guid>
      <description> tags: Algorithm </description>
    </item>
    
    <item>
      <title>Bitwise Operator: XOR</title>
      <link>https://notes.0081800.xyz/notes/20220330070545-bitwise_operator_xor/</link>
      <pubDate>Wed, 30 Mar 2022 07:05:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220330070545-bitwise_operator_xor/</guid>
      <description> tags: Bitwise Operators 0101 (decimal 5) XOR 0011 (decimal 3) = 0110 (decimal 6)
0010 (decimal 2) XOR 1010 (decimal 10) = 1000 (decimal 8)
Useful features:
1 ^ 1 = 0 2 ^ 0 = 2 </description>
    </item>
    
    <item>
      <title>LeetCode101: 287. Find the Duplicate Number</title>
      <link>https://notes.0081800.xyz/notes/20220329181423-leetcode101_287_find_the_duplicate_number/</link>
      <pubDate>Tue, 29 Mar 2022 18:14:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220329181423-leetcode101_287_find_the_duplicate_number/</guid>
      <description>tags: Cycle detection,Fast &amp;amp; Slow Pointers,LeetCode101 Treat as A Linked List with circle According to the length of nums is n + 1, and integer range is [1, n], so we can treat each element as a index that point to some next value. For example:
[1,3,4,2,2] It can be treated as(format is element(index)):
1(0) -&amp;gt; 3(1) -&amp;gt; 2(3) -&amp;gt; 4(3) -&amp;gt; 2(4) -&amp;gt; 4(3)
We can see there is a circle in it, so:</description>
    </item>
    
    <item>
      <title>LeetCode101: 142. Linked List Cycle II</title>
      <link>https://notes.0081800.xyz/notes/20220329180222-leetcode101_142_linked_list_cycle_ii/</link>
      <pubDate>Tue, 29 Mar 2022 18:02:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220329180222-leetcode101_142_linked_list_cycle_ii/</guid>
      <description>tags: Cycle detection,Fast &amp;amp; Slow Pointers,LeetCode101 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { if (head == nullptr || head-&amp;gt;next == nullptr) { return nullptr; } // tortoise move 1 step auto slow = head-&amp;gt;next; // hare move 2 steps auto fast = head-&amp;gt;next-&amp;gt;next; while (slow !</description>
    </item>
    
    <item>
      <title>Fast &amp; Slow Pointers</title>
      <link>https://notes.0081800.xyz/notes/20220329171337-fast_slow_pointers/</link>
      <pubDate>Tue, 29 Mar 2022 17:13:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220329171337-fast_slow_pointers/</guid>
      <description> tags: Algorithm,Two Pointers </description>
    </item>
    
    <item>
      <title>Cycle detection</title>
      <link>https://notes.0081800.xyz/notes/20220329171237-cycle_detection/</link>
      <pubDate>Tue, 29 Mar 2022 17:12:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220329171237-cycle_detection/</guid>
      <description>tags: Algorithm,Linked List,Fast &amp;amp; Slow Pointers source: https://en.wikipedia.org/wiki/Cycle%5Fdetection Floyd&amp;rsquo;s tortoise and hare With two pointers:
tortoise move slow: move 1 step in each loop. hare move fast: move 2 steps in each loop. If there is a circle existed, tortoise and hare will meet eventually in the circle. Now both tortoise and hare are in the circle, how to figure out the beginning of the circle?
We put tortoise back to the beginning they both started.</description>
    </item>
    
    <item>
      <title>Tree</title>
      <link>https://notes.0081800.xyz/notes/20220329160804-tree/</link>
      <pubDate>Tue, 29 Mar 2022 16:08:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220329160804-tree/</guid>
      <description> tags: Data Structures </description>
    </item>
    
    <item>
      <title>Binary Tree</title>
      <link>https://notes.0081800.xyz/notes/20220329160754-binary_tree/</link>
      <pubDate>Tue, 29 Mar 2022 16:07:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220329160754-binary_tree/</guid>
      <description> tags: Tree </description>
    </item>
    
    <item>
      <title>Complete Binary Tree</title>
      <link>https://notes.0081800.xyz/notes/20220329160738-complete_binary_tree/</link>
      <pubDate>Tue, 29 Mar 2022 16:07:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220329160738-complete_binary_tree/</guid>
      <description>tags: Binary Tree,Tree A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible.</description>
    </item>
    
    <item>
      <title>Binary heap</title>
      <link>https://notes.0081800.xyz/notes/20220329160438-binary_heap/</link>
      <pubDate>Tue, 29 Mar 2022 16:04:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220329160438-binary_heap/</guid>
      <description>tags: Heap (data structure),Data Structures,Complete Binary Tree,Tree source: https://en.wikipedia.org/wiki/Binary%5Fheap Binary tree with two additional constraints:
Shape property: complete binary tree. Heap property: the key stored in each node is greater or equal(max-heaps) to or less than or equal to(min-heaps) the keys in the node&amp;rsquo;s children, according to some total order. Heap operations Insert Steps to add an element to a heap:
Add element to the bottom level of the heap at the leftmost open space.</description>
    </item>
    
    <item>
      <title>LeetCode101: 215. Kth Largest Element in an Array</title>
      <link>https://notes.0081800.xyz/notes/20220329072317-leetcode101_215_kth_largest_element_in_an_array/</link>
      <pubDate>Tue, 29 Mar 2022 07:23:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220329072317-leetcode101_215_kth_largest_element_in_an_array/</guid>
      <description> tags: Priority Queue,LeetCode101 Max heap priority queue class Solution { public: int findKthLargest(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { // max heap priority_queue&amp;lt;int&amp;gt; pq; for (auto iter = nums.begin(); iter != nums.end(); ++iter) { pq.push(*iter); } // The Kth largest element should let k &amp;gt; 1 not k &amp;gt; 0 for (; k &amp;gt; 1; --k) { pq.pop(); } return pq.top(); } }; </description>
    </item>
    
    <item>
      <title>LeetCode101: 1337. The K Weakest Rows in a Matrix</title>
      <link>https://notes.0081800.xyz/notes/20220329071403-leetcode101_1337_the_k_weakest_rows_in_a_matrix/</link>
      <pubDate>Tue, 29 Mar 2022 07:14:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220329071403-leetcode101_1337_the_k_weakest_rows_in_a_matrix/</guid>
      <description>tags: Priority Queue,LeetCode101 The key ideas:
Use a std::pair to hold {count, index}, so it can compare count first then the index. Use a min heap priority queue to get the K weakest rows. class Solution { public: vector&amp;lt;int&amp;gt; kWeakestRows(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; mat, int k) { // min heap priority_queue&amp;lt; std::pair&amp;lt;int, int&amp;gt;, vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt;, std::greater&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; pq; for (auto iter = mat.begin(); iter != mat.end(); ++iter) { int c = count((*iter).</description>
    </item>
    
    <item>
      <title>Priority Queue</title>
      <link>https://notes.0081800.xyz/notes/20220329070523-priority_queue/</link>
      <pubDate>Tue, 29 Mar 2022 07:05:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220329070523-priority_queue/</guid>
      <description> tags: Data Structures,Heap (data structure) The priority queue is solved:
The K smallest/largest/weakest X. </description>
    </item>
    
    <item>
      <title>How to Speak and Write Correctly</title>
      <link>https://notes.0081800.xyz/notes/20220328110642-how_to_speak_and_write_correctly/</link>
      <pubDate>Mon, 28 Mar 2022 11:06:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220328110642-how_to_speak_and_write_correctly/</guid>
      <description>tags: Learning English,读书笔记 source: Joseph Devlin. How to Speak and Write Correctly, 2007. http://archive.org/details/how_to_speak_and_write_correctly_librivox. I found this book in my Kindle on the subway to work this morning. And remembered that I downloaded it free from the Kindle store years ago. For some reasons, maybe my English was not good enough to read it, I haven&amp;rsquo;t read it yet. After read a little, I think it&amp;rsquo;s prefect for me for now.</description>
    </item>
    
    <item>
      <title>Heapsort</title>
      <link>https://notes.0081800.xyz/notes/20220328074013-heapsort/</link>
      <pubDate>Mon, 28 Mar 2022 07:40:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220328074013-heapsort/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Heap (data structure)</title>
      <link>https://notes.0081800.xyz/notes/20220328073805-heap_data_structure/</link>
      <pubDate>Mon, 28 Mar 2022 07:38:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220328073805-heap_data_structure/</guid>
      <description>tags: Data Structures,Tree WHAT is a heap? Tree-based data structure which is essentially an almost complete tree that statifies the heap property.
Max heap For any given node C, if P is a parent node of C, then the key(the value) of P is greater than or equal to the key of C.
Min heap The P is less than or equal to the key C.
When to use a heap?</description>
    </item>
    
    <item>
      <title>Sorting</title>
      <link>https://notes.0081800.xyz/notes/20220324120212-sorting/</link>
      <pubDate>Thu, 24 Mar 2022 12:02:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220324120212-sorting/</guid>
      <description> tags: Algorithm </description>
    </item>
    
    <item>
      <title>LeetCode101: 881. Boats to Save People</title>
      <link>https://notes.0081800.xyz/notes/20220324114305-881_boats_to_save_people/</link>
      <pubDate>Thu, 24 Mar 2022 11:43:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220324114305-881_boats_to_save_people/</guid>
      <description>tags: Hash Table,LeetCode101,Sorting,Two Pointers Intuition with HashMap class Solution { public: int numRescueBoats(vector&amp;lt;int&amp;gt;&amp;amp; people, int limit) { unordered_map&amp;lt;int, int&amp;gt; cntOfWeights; for (auto iter = people.begin(); iter != people.end(); ++iter) { cntOfWeights[*iter]++; } int r = 0; for (int i = 0; i &amp;lt; people.size(); i++) { if (cntOfWeights[people[i]] == 0) { continue; } cntOfWeights[people[i]]--; for (int j = (limit - people[i]); j &amp;gt; 0; --j) { if (cntOfWeights.find(j) != cntOfWeights.</description>
    </item>
    
    <item>
      <title>LeetCode101: 991. Broken Calculator</title>
      <link>https://notes.0081800.xyz/notes/20220323175835-leetcode101_991_broken_calculator/</link>
      <pubDate>Wed, 23 Mar 2022 17:58:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220323175835-leetcode101_991_broken_calculator/</guid>
      <description>tags: Math,backtracking,LeetCode101 Backtracking and stack overflow Intuition:
We can abstract all the operations to a Tree, then apply DFS on it.
For example: startValue=2, target=3, the tree looks like:
/* 2 /\ / \ / \ 1(-1) 4(x2) /\ /\--+ / \ / \ 0(-1) 2(x2) 3(-1) 8(x2) */ class Solution { public: int brokenCalc(int startValue, int target) { unordered_set&amp;lt;int&amp;gt; visited; return backtracking(0, startValue, target, visited); } int backtracking(int count, int val, int target, unordered_set&amp;lt;int&amp;gt; &amp;amp; visited) { if (val == target) { return count; } if (visited.</description>
    </item>
    
    <item>
      <title>LeetCode101: 1663. Smallest String With A Given Numeric Value</title>
      <link>https://notes.0081800.xyz/notes/20220322162250-leetcode101_1663_smallest_string_with_a_given_numeric_value/</link>
      <pubDate>Tue, 22 Mar 2022 16:22:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220322162250-leetcode101_1663_smallest_string_with_a_given_numeric_value/</guid>
      <description>tags: String,LeetCode101,Tricky Initialize a string that fills &#39;a&#39; in it. Then we turn it to the expected string from end to start.
The maximal value of each position in the string is 26. If we start from all elements is &#39;a&#39; in the string. Then the represent value of the string is n. If it&amp;rsquo;s not equal to k. Then we need turn the last character of string to r = k - n.</description>
    </item>
    
    <item>
      <title>LeetCode101: 12. Integer to Roman</title>
      <link>https://notes.0081800.xyz/notes/20220322155933-leetcode101_12_integer_to_roman/</link>
      <pubDate>Tue, 22 Mar 2022 15:59:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220322155933-leetcode101_12_integer_to_roman/</guid>
      <description>tags: Math,Hash Table,LeetCode101 class Solution { public: string intToRoman(int num) { vector&amp;lt;string&amp;gt; roman {&amp;#34;M&amp;#34;, &amp;#34;CM&amp;#34;, &amp;#34;D&amp;#34;, &amp;#34;CD&amp;#34;, &amp;#34;C&amp;#34;, &amp;#34;XC&amp;#34;, &amp;#34;L&amp;#34;, &amp;#34;XL&amp;#34;, &amp;#34;X&amp;#34;, &amp;#34;IX&amp;#34;, &amp;#34;V&amp;#34;, &amp;#34;IV&amp;#34;, &amp;#34;I&amp;#34;}; vector&amp;lt;int&amp;gt; integers {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 }; string r; int times = 0; for (int i = 0; i &amp;lt; integers.size(); ++i) { if (num &amp;gt;= integers[i]) { times = num / integers[i]; num -= times * integers[i]; for (int j = times; j &amp;gt; 0; --j) { r.</description>
    </item>
    
    <item>
      <title>LeetCode101: 11. Container With Most Water</title>
      <link>https://notes.0081800.xyz/notes/20220321183809-leetcode_11_container_with_most_water/</link>
      <pubDate>Mon, 21 Mar 2022 18:38:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220321183809-leetcode_11_container_with_most_water/</guid>
      <description> tags: Two Pointers,Tricky,LeetCode101 The key ideas are:
We start from two edges and move to the middle with two pointers. Move the pointer to the middle which side is smaller. class Solution { public: int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) { int i = 0, j = height.size() - 1; int water = 0; while (i &amp;lt; j) { water = max(water, (j - i) * min(height[i], height[j])); if (height[i] &amp;gt; height[j]) { --j; } else { ++i; } } return water; } }; </description>
    </item>
    
    <item>
      <title>LeetCode101: 316. Remove Duplicate Letters</title>
      <link>https://notes.0081800.xyz/notes/20220321174725-leetcode101_316_remove_duplicate_letters/</link>
      <pubDate>Mon, 21 Mar 2022 17:47:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220321174725-leetcode101_316_remove_duplicate_letters/</guid>
      <description>tags: String,LeetCode101,Stack,Hash Table,Hash Set I have solved this problem years before, LeetCode: 316.Remove Duplicate Letters, but still stuck on it.
The key idea is not only about stack, but also required a map to record how many same letters behind current one. Which helps us to decide if drop current letter or not, when the new letter is less than the top of stack, which means smaller in lexicographical order.</description>
    </item>
    
    <item>
      <title>LeetCode101: 763. Partition Labels</title>
      <link>https://notes.0081800.xyz/notes/20220321174504-leetcode101_763_partition_labels/</link>
      <pubDate>Mon, 21 Mar 2022 17:45:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220321174504-leetcode101_763_partition_labels/</guid>
      <description>tags: String,LeetCode101,Hash Set,Hash Table,Stack The key idea is similar to LeetCode101: 316. Remove Duplicate Letters, we use a HashMap to track how many letters which is same in the string. Then we use a HashSet to store appeared letters. When there is no more letters appeared in the HashSet, it&amp;rsquo;s time to partition.
class Solution { public: vector&amp;lt;int&amp;gt; partitionLabels(string s) { unordered_map&amp;lt;char, int&amp;gt; cntOfLetters; unordered_set&amp;lt;char&amp;gt; appearedLetters; vector&amp;lt;int&amp;gt; r; int count = 0; for (auto iter = s.</description>
    </item>
    
    <item>
      <title>String</title>
      <link>https://notes.0081800.xyz/notes/20220321174510-string/</link>
      <pubDate>Mon, 21 Mar 2022 17:45:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220321174510-string/</guid>
      <description> tags: Algorithm </description>
    </item>
    
    <item>
      <title>LeetCode101: 9. Palindrome Number</title>
      <link>https://notes.0081800.xyz/notes/20220318084438-leetcode101_9_palindrome_number/</link>
      <pubDate>Fri, 18 Mar 2022 08:44:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220318084438-leetcode101_9_palindrome_number/</guid>
      <description>tags: LeetCode101,Math The key idea is:
To use \(log10(10^n) = n\) to get how many digits in the number. Then we need iterate \(n + 1\) times to compare each side. The digit in the left is \(\frac{x}{10^{n-i}} \mod 10\). The digit in the right is \(\frac{x}{10^i} \mod 10\). class Solution { public: bool isPalindrome(int x) { if (x &amp;lt; 0) { return false; } // failed at here if (x &amp;lt; 10) { return true; } int n = log10(x); int ld = pow(10, n); // left div int rd = 1; // right div for (int i = 0; i &amp;lt; (n + 1) / 2; i++) { // left right if (x / ld % 10 !</description>
    </item>
    
    <item>
      <title>Math</title>
      <link>https://notes.0081800.xyz/notes/20220318084456-math/</link>
      <pubDate>Fri, 18 Mar 2022 08:44:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220318084456-math/</guid>
      <description> tags: Algorithm </description>
    </item>
    
    <item>
      <title>Integer Overflow</title>
      <link>https://notes.0081800.xyz/notes/20220318072424-integer_overflow/</link>
      <pubDate>Fri, 18 Mar 2022 07:24:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220318072424-integer_overflow/</guid>
      <description>tags: C/C++ In some problems, we need to detect is our result overflow in a 32-bit integer. The key ideas is check our value before it becomes bigger.
For example:
// INT_MAX 2147483647 // INT_MIN -2147483648 // INT_MAX&amp;#39;s suffix is 7 if (res &amp;gt; INT_MAX / 10 || (res == INT_MAX / 10 &amp;amp;&amp;amp; pop &amp;gt; 7)) { return 0; } // INT_MIN&amp;#39;s suffix is -8 if (res &amp;lt; INT_MIN / 10 || (res == INT_MIN / 10 &amp;amp;&amp;amp; pop &amp;lt; -8)) { return 0; } res = res * 10 + pop; Our final result need a 10 times current value and plus a value, then we check:</description>
    </item>
    
    <item>
      <title>LeetCode101: 8. String to Integer (atoi)</title>
      <link>https://notes.0081800.xyz/notes/20220318072345-leetcode101_8_string_to_integer_atoi/</link>
      <pubDate>Fri, 18 Mar 2022 07:23:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220318072345-leetcode101_8_string_to_integer_atoi/</guid>
      <description>tags: Tricky,LeetCode101,Integer Overflow The key idea is how to detect integer overflow, it&amp;rsquo;s same to: LeetCode101: 7. Reverse Integer.
class Solution { public: int myAtoi(string s) { auto iter = s.begin(); int base = 1, r = 0, p = 0; // Skip whitespace for (; iter != s.end() &amp;amp;&amp;amp; *iter == &amp;#39; &amp;#39;; ++iter) { } // negative or positive if (*iter == &amp;#39;-&amp;#39; || *iter == &amp;#39;+&amp;#39;) { if (*iter == &amp;#39;-&amp;#39;) { base = -1; } ++iter; } for (; iter !</description>
    </item>
    
    <item>
      <title>LeetCode101: 6. Zigzag Conversion</title>
      <link>https://notes.0081800.xyz/notes/20220317073333-leetcode101_6_zigzag_conversion/</link>
      <pubDate>Thu, 17 Mar 2022 07:33:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220317073333-leetcode101_6_zigzag_conversion/</guid>
      <description>tags: Tricky,LeetCode101 Make
R = total required rows d = R - 2 2 is contains head line and tail line that not need insert a character between two columns. r = current row offset, which starts from 0. c = current column offset, which starts from 0. We can use a formula to make columns, which is \(c(R+d)+r\).
For example, &amp;quot;PAYPALISHIRING&amp;quot;, numRows=3:
P A H N A P L S I I G Y I R The columns only the head and tail rows is correct should be:</description>
    </item>
    
    <item>
      <title>LeetCode101: 7. Reverse Integer</title>
      <link>https://notes.0081800.xyz/notes/20220316215304-leetcode101_7_reverse_integer/</link>
      <pubDate>Wed, 16 Mar 2022 21:53:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220316215304-leetcode101_7_reverse_integer/</guid>
      <description>tags: Tricky,Stack,LeetCode101,Integer Overflow The key is how to detect integer overflow without store to a larger size integer.
For this purpose, we could detect integer overflow before carry:
The maximal of INT_MAX before carry is \(\frac{INT\_MAX}{10}\). We continue compare pop with the suffix of INT_MAX, 7, if maximal before carry is equal to \(\frac{INT\_MAX}{10}\).
The minimal of INT_MIN before carry is \(\frac{INT\_MIN}{10}\) too. We continue compare pop with the suffix of INT_MIN, -8, if minimal before carry is equal to \(\frac{INT\_MIN}{10}\).</description>
    </item>
    
    <item>
      <title>LeetCode101: 946. Validate Stack Sequences</title>
      <link>https://notes.0081800.xyz/notes/20220316085247-leetcode101_946_validate_stack_sequences/</link>
      <pubDate>Wed, 16 Mar 2022 08:52:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220316085247-leetcode101_946_validate_stack_sequences/</guid>
      <description>tags: Stack Intuition for (int i = 0; i &amp;lt; pushed.size(); i++) { if (pushed[i] != popped[pushed.size() - 1 - i]) { return false; } } But the pop/push operations can happend in any sequence.
Stack Using a stack. Returns false, IF the next value neither the popped nor pushed.
In each sequence we must do a operation: push or pop. When to push:
stack is empty, or top of stack is not current popped value When to pop:</description>
    </item>
    
    <item>
      <title>LeetCode101: 1249. Minimum Remove to Make Valid Parentheses</title>
      <link>https://notes.0081800.xyz/notes/20220316080026-leetcode101_1249_minimum_remove_to_make_valid_parentheses/</link>
      <pubDate>Wed, 16 Mar 2022 08:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220316080026-leetcode101_1249_minimum_remove_to_make_valid_parentheses/</guid>
      <description>tags: Stack,LeetCode101 Stack class Solution { public: string minRemoveToMakeValid(string s) { stack&amp;lt;char&amp;gt; st; char open = &amp;#39;(&amp;#39;, close = &amp;#39;)&amp;#39;; int open_count = 0; string res; // forward to remove unnecessary close parentheses for (auto iter = s.begin(); iter != s.end(); ++iter) { if (*iter == open) { open_count++; } if (open_count == 0 &amp;amp;&amp;amp; *iter == close) { continue; } if (*iter == close) { open_count--; } st.push(*iter); } int close_count = 0; // backward to remove unnecessary open parentheses while (!</description>
    </item>
    
    <item>
      <title>LeetCode101: 769. Max Chunks To Make Sorted</title>
      <link>https://notes.0081800.xyz/notes/20220315152142-leetcode101_769_max_chunks_to_make_sorted/</link>
      <pubDate>Tue, 15 Mar 2022 15:21:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220315152142-leetcode101_769_max_chunks_to_make_sorted/</guid>
      <description>tags: Tricky,LeetCode101 original: 0, 2, 1, 4, 3, 5, 7, 6 max: 0, 2, 2, 4, 4, 5, 7, 7 sorted: 0, 1, 2, 3, 4, 5, 6, 7 index: 0, 1, 2, 3, 4, 5, 6, 7
As shown above, the position of break point is same to the position of max value of chunks. So here:
We track chunks&amp;rsquo;s max value. Break at the position of max value lives in sorted array, which means the index in this case.</description>
    </item>
    
    <item>
      <title>Tricky</title>
      <link>https://notes.0081800.xyz/notes/20220315152159-tricky/</link>
      <pubDate>Tue, 15 Mar 2022 15:21:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220315152159-tricky/</guid>
      <description> tags: Algorithm </description>
    </item>
    
    <item>
      <title>LeetCode101: 739. Daily Temperatures</title>
      <link>https://notes.0081800.xyz/notes/20220315112303-leetcode101_739_daily_temperatures/</link>
      <pubDate>Tue, 15 Mar 2022 11:23:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220315112303-leetcode101_739_daily_temperatures/</guid>
      <description>tags: Monotonic Stack,LeetCode101,LeetCode101: 496. Next Greater Element I Mono-descreasing stack class Solution { public: vector&amp;lt;int&amp;gt; dailyTemperatures(vector&amp;lt;int&amp;gt;&amp;amp; temperatures) { vector&amp;lt;int&amp;gt; res(temperatures.size(), 0); stack&amp;lt;int&amp;gt; st; for (int i = 0; i &amp;lt; temperatures.size(); i++) { while (!st.empty() &amp;amp;&amp;amp; temperatures[st.top()] &amp;lt; temperatures[i]) { res[st.top()] = i - st.top(); st.pop(); } st.push(i); } return res; } }; [73,74,75,71,69,72,76,73]</description>
    </item>
    
    <item>
      <title>LeetCode101: 654. Maximum Binary Tree</title>
      <link>https://notes.0081800.xyz/notes/20220315105116-leetcode101_654_maximum_binary_tree/</link>
      <pubDate>Tue, 15 Mar 2022 10:51:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220315105116-leetcode101_654_maximum_binary_tree/</guid>
      <description>tags: Monotonic Stack,LeetCode101,Binary Search Tree Mono-descreasing stack Key:
The largest number is the root, that we can observe in by iteration. We must clear the stack to fill the right side of BST after loop. The last popped element is the left of current node. From top to bottom, the top element is the right side of the element that under the top. class Solution { public: TreeNode* constructMaximumBinaryTree(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;TreeNode*&amp;gt; res(nums.</description>
    </item>
    
    <item>
      <title>LeetCode101: 581. Shortest Unsorted Continuous Subarray</title>
      <link>https://notes.0081800.xyz/notes/20220315071351-leetcode101_581_shortest_unsorted_continuous_subarray/</link>
      <pubDate>Tue, 15 Mar 2022 07:13:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220315071351-leetcode101_581_shortest_unsorted_continuous_subarray/</guid>
      <description>tags: Monotonic Stack,LeetCode101 Mono-increasing stack Key:
Some case should move backward as the new value we meeted is larger than it. When we meet 2 in the stack, and here we need move backward. Some case we need move forward, as the following values are the mono-increaing stack: [1, 2, 5, 3, 4] class Solution { public: int findUnsortedSubarray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { stack&amp;lt;int&amp;gt; st; // mono-increasing int left = -1, right = -2; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>LeetCode101: 503. Next Greater Element II</title>
      <link>https://notes.0081800.xyz/notes/20220315063008-leetcode101_503_next_greater_element_ii/</link>
      <pubDate>Tue, 15 Mar 2022 06:30:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220315063008-leetcode101_503_next_greater_element_ii/</guid>
      <description>tags: Monotonic Stack,LeetCode101 related: LeetCode101: 496. Next Greater Element I Mono-descreasing stack / normal order loop twice Loop twice to solve circular interger array Mono-descreasing stack to store index, avoid HashMap in Next Greater Element I, as there is a cicular array. class Solution { public: vector&amp;lt;int&amp;gt; nextGreaterElements(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; res(nums.size(), -1); stack&amp;lt;int&amp;gt; st; for (int j = 0, i = 0; j &amp;lt; nums.size() * 2; ++j) { i = j &amp;gt;= nums.</description>
    </item>
    
    <item>
      <title>LeetCode101: 496. Next Greater Element I</title>
      <link>https://notes.0081800.xyz/notes/20220314085847-leetcode101_496_next_greater_element_i/</link>
      <pubDate>Mon, 14 Mar 2022 08:58:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220314085847-leetcode101_496_next_greater_element_i/</guid>
      <description>tags: Monotonic Stack,Hash Table,LeetCode101 Mono-descreasing and reverse order travel class Solution { public: vector&amp;lt;int&amp;gt; nextGreaterElement(vector&amp;lt;int&amp;gt;&amp;amp; nums1, vector&amp;lt;int&amp;gt;&amp;amp; nums2) { // Mono-descreasing and reverse order travel. // The next greater of the popped value is the top of the stack, if it has any. // // For example: [1,3,4,2] // the stack goes: // [2] // [4] -&amp;gt; 2 // [4, 3, 1] stack&amp;lt;int&amp;gt; st; vector&amp;lt;int&amp;gt; res; unordered_map&amp;lt;int, int&amp;gt; m; for (int i = nums2.</description>
    </item>
    
    <item>
      <title>LeetCode101: 402. Remove K Digits</title>
      <link>https://notes.0081800.xyz/notes/20220314074324-leetcode101_402_remove_k_digits/</link>
      <pubDate>Mon, 14 Mar 2022 07:43:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220314074324-leetcode101_402_remove_k_digits/</guid>
      <description>tags: Monotonic Stack,LeetCode101 Mono-increasing stack and reverse order travel (Not Work) Notes:
We attempt to remove the most large numbers in the left, first, we use the right n numbers to meet the requirements, which is num.length - k and then, using a monotonic increasing stack to keep the result as samller as we can. (A monotonic increasing stack will remove larger elements before pushing.)
Also note that: the result&amp;rsquo;s length is not actually equal num.</description>
    </item>
    
    <item>
      <title>LeetCode101: 456. 132 Pattern</title>
      <link>https://notes.0081800.xyz/notes/20220313153222-456_132_pattern/</link>
      <pubDate>Sun, 13 Mar 2022 15:32:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220313153222-456_132_pattern/</guid>
      <description>tags: Monotonic Stack,LeetCode101,Tricky We travel the numbers in the reverse order:
Use a mono-increasing stack to find the largest number(3 in the 132 pattern), the value popped from stack is the second large number(2 in the 132 pattern), if any value less than the second large number, returns true. // Note: // // - subsequence is not contiguous, is i &amp;lt; j &amp;lt; k, not i + 1 = j, j + 1 = k // class Solution { public: bool find132pattern(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int K = INT_MIN; stack&amp;lt;int&amp;gt; mst; // mono-increasing stack for (int i = nums.</description>
    </item>
    
    <item>
      <title>Monotonic Stack</title>
      <link>https://notes.0081800.xyz/notes/20220313145125-monotonic_stack/</link>
      <pubDate>Sun, 13 Mar 2022 14:51:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220313145125-monotonic_stack/</guid>
      <description>tags: Data Structures,Stack source: “Monotonic Stack.” Accessed March 13, 2022. https://liuzhenglaichn.gitbook.io/algorithm/monotonic-stack. A monotonic stack is a stack whose elements are monotonically increasing or descreasing.
It&amp;rsquo;s not only about the order in the stack, it&amp;rsquo;s also about remove larger/smaller elements before pushing.
Monotonically descreasing we need to pop smaller elements from the stack before pushing a new element:
vector&amp;lt;int&amp;gt; nums; // fill nums stack&amp;lt;int&amp;gt; st; for (auto i = nums.size() - 1; i &amp;gt;= 0; i--) { while (!</description>
    </item>
    
    <item>
      <title>AVL Tree</title>
      <link>https://notes.0081800.xyz/notes/20220312215308-avl_tree/</link>
      <pubDate>Sat, 12 Mar 2022 21:53:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220312215308-avl_tree/</guid>
      <description> tags: Binary Search Tree,Binary Tree,Tree </description>
    </item>
    
    <item>
      <title>Binary Search Tree</title>
      <link>https://notes.0081800.xyz/notes/20220312215158-binary_search_tree/</link>
      <pubDate>Sat, 12 Mar 2022 21:51:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220312215158-binary_search_tree/</guid>
      <description> tags: Data Structures,Binary Tree,Tree </description>
    </item>
    
    <item>
      <title>Red-Black Tree</title>
      <link>https://notes.0081800.xyz/notes/20220312215140-red_black_tree/</link>
      <pubDate>Sat, 12 Mar 2022 21:51:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220312215140-red_black_tree/</guid>
      <description> tags: Binary Search Tree, AVL Tree,Tree </description>
    </item>
    
    <item>
      <title>set vs unordered_set in C&#43;&#43; STL</title>
      <link>https://notes.0081800.xyz/notes/20220312215003-set_vs_unordered_set_in_c_stl/</link>
      <pubDate>Sat, 12 Mar 2022 21:50:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220312215003-set_vs_unordered_set_in_c_stl/</guid>
      <description>tags: C/C++ source: GeeksforGeeks. “Set vs Unordered_set in C++ STL,” May 28, 2018. https://www.geeksforgeeks.org/set-vs-unordered_set-c-stl/. set Ordered set that implemented by a &amp;ldquo;Self balancing BST&amp;rdquo; like Red-Black Tree.
Extra find operations equal_range returns range of elements matching a specific key lower_bound returns an iterator to the first element not less than the given key upper_bound returns an iterator to the first element greater than the given key #include &amp;lt;iostream&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;assert.</description>
    </item>
    
    <item>
      <title>OrderedSet</title>
      <link>https://notes.0081800.xyz/notes/20220312213701-orderedset/</link>
      <pubDate>Sat, 12 Mar 2022 21:37:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220312213701-orderedset/</guid>
      <description>tags: C/C++,Java,Data Structures In C++ the set container is an ordered or sorted set, unordered_set is the normal set in C++. Differences between them please check set vs unordered_set in C++ STL.
In Java there is an java.util.SortedSet interface.</description>
    </item>
    
    <item>
      <title>LeetCode101: 220. Contains Duplicate III</title>
      <link>https://notes.0081800.xyz/notes/20220312212227-leetcode101_220_contains_duplicate_iii/</link>
      <pubDate>Sat, 12 Mar 2022 21:22:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220312212227-leetcode101_220_contains_duplicate_iii/</guid>
      <description>tags: Sliding Window,OrderedSet Use HashSet to attempt to meet the requirements in the window class Solution { public: bool containsNearbyAlmostDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k, int t) { auto left = 0; auto K = 0; set&amp;lt;long&amp;gt; hset; // set in cpp is an sorted set for (auto right = 0; right &amp;lt; nums.size(); right++) { K = right - left; if (K &amp;gt; k) { hset.erase(nums[left]); left++; } hset.insert(nums[right]); // some numbers are the same.</description>
    </item>
    
    <item>
      <title>LeetCode101: 219. Contains Duplicate II</title>
      <link>https://notes.0081800.xyz/notes/20220312073726-219_contains_duplicate_ii/</link>
      <pubDate>Sat, 12 Mar 2022 07:37:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220312073726-219_contains_duplicate_ii/</guid>
      <description>tags: Sliding Window,Hash Table,LeetCode101 This is an &amp;ldquo;near by&amp;rdquo; problem that can be solved by Sliding Window. The k in the problem is somehow means contiguous.
And using a HashTable to indicate that two values in the different position are equal.
The steps is following:
Find two values at each side of window are equal. Return true if the offset between their indices is less than or equal k. Otherwise set left to the new position and continue.</description>
    </item>
    
    <item>
      <title>Hash Table</title>
      <link>https://notes.0081800.xyz/notes/20220311221617-hash_table/</link>
      <pubDate>Fri, 11 Mar 2022 22:16:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220311221617-hash_table/</guid>
      <description> tags: Data Structures </description>
    </item>
    
    <item>
      <title>LeetCode101: 209. Minimum Size Subarray Sum</title>
      <link>https://notes.0081800.xyz/notes/20220311220839-209_minimum_size_subarray_sum/</link>
      <pubDate>Fri, 11 Mar 2022 22:08:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220311220839-209_minimum_size_subarray_sum/</guid>
      <description>tags: Sliding Window,LeetCode101 Key:
sum is greater than or equal to target Compute minimal must above slide left window, as decrease may cause sum less than target. See also 1695. Maximum Erasure Value class Solution { public: int minSubArrayLen(int target, vector&amp;lt;int&amp;gt;&amp;amp; nums) { int left = 0; int sum = 0; int minimal = INT_MAX; for (auto right = 0; right &amp;lt; nums.size(); right++) { sum += nums[right]; while (sum &amp;gt;= target) { minimal = min(minimal, right - left + 1); sum -= nums[left++]; } } return minimal == INT_MAX ?</description>
    </item>
    
    <item>
      <title>187. Repeated DNA Sequences</title>
      <link>https://notes.0081800.xyz/notes/20220311213000-187_repeated_dna_sequences/</link>
      <pubDate>Fri, 11 Mar 2022 21:30:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220311213000-187_repeated_dna_sequences/</guid>
      <description></description>
    </item>
    
    <item>
      <title>LeetCode101: 187. Repeated DNA Sequences</title>
      <link>https://notes.0081800.xyz/notes/20220311213045-187_repeated_dna_sequences/</link>
      <pubDate>Fri, 11 Mar 2022 21:30:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220311213045-187_repeated_dna_sequences/</guid>
      <description> tags: Sliding Window,LeetCode101,Hash Set Key:
Fixed size window, right should start from 9 class Solution { public: vector&amp;lt;string&amp;gt; findRepeatedDnaSequences(string s) { int left = 0; unordered_set&amp;lt;string&amp;gt; results; unordered_set&amp;lt;string&amp;gt; hset; for (auto right = 9; right &amp;lt; s.size(); right++) { string sub(s, left, 10); if (hset.find(sub) != hset.end()) { results.insert(sub); } hset.insert(sub); left++; } return vector&amp;lt;string&amp;gt;(results.begin(), results.end()); } }; </description>
    </item>
    
    <item>
      <title>Hash Set</title>
      <link>https://notes.0081800.xyz/notes/20220311183913-hash_set/</link>
      <pubDate>Fri, 11 Mar 2022 18:39:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220311183913-hash_set/</guid>
      <description> tags: Data Structures </description>
    </item>
    
    <item>
      <title>LeetCode101: 1695. Maximum Erasure Value</title>
      <link>https://notes.0081800.xyz/notes/20220311183843-1695_maximum_erasure_value/</link>
      <pubDate>Fri, 11 Mar 2022 18:38:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220311183843-1695_maximum_erasure_value/</guid>
      <description>tags: Sliding Window,LeetCode101,Hash Set Use HashMap to store indices See also: 3. Longest Substring Without Repeating Characters
class Solution { public: int maximumUniqueSubarray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int maximum = 0; int left = 0, right = 0; unordered_map&amp;lt;int, int&amp;gt; indices; for (; right &amp;lt; nums.size(); right++) { int n = nums[right]; if (indices.find(n) != indices.end() &amp;amp;&amp;amp; indices[n] + 1 &amp;gt; left) { left = indices[n] + 1; } maximum = max(maximum, std::accumulate(nums.</description>
    </item>
    
    <item>
      <title>An Introduction to Sliding Window Algorithms</title>
      <link>https://notes.0081800.xyz/notes/20220311083843-an_introduction_to_sliding_window_algorithms/</link>
      <pubDate>Fri, 11 Mar 2022 08:38:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220311083843-an_introduction_to_sliding_window_algorithms/</guid>
      <description>tags: Sliding Window source: Moore, Jordan. “An Introduction to Sliding Window Algorithms.” Medium, July 26, 2020. https://levelup.gitconnected.com/an-introduction-to-sliding-window-algorithms-5533c4fe1cc7. Efficientive algorithm:
Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away. &amp;ndash; Antoine de Saint-Exupéry
The following return values can use a sliding window:
Minimum value Maximum value Longest value Shortest value K-sized value And contiguous is one of the biggest clues.</description>
    </item>
    
    <item>
      <title>Window Sliding Technique</title>
      <link>https://notes.0081800.xyz/notes/20220311081613-window_sliding_technique/</link>
      <pubDate>Fri, 11 Mar 2022 08:16:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220311081613-window_sliding_technique/</guid>
      <description>tags: Sliding Window,Brute Force Approach source: GeeksforGeeks. “Window Sliding Technique,” April 16, 2017. https://www.geeksforgeeks.org/window-sliding-technique/. Use a Sliding Window to instead Brute Force Approach, improve time complexity big O from \(O(n^2)\) to \(O(n)\).</description>
    </item>
    
    <item>
      <title>Brute Force Approach</title>
      <link>https://notes.0081800.xyz/notes/20220311081528-brute_force_approach/</link>
      <pubDate>Fri, 11 Mar 2022 08:15:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220311081528-brute_force_approach/</guid>
      <description> tags: Algorithm </description>
    </item>
    
    <item>
      <title>Two Pointers</title>
      <link>https://notes.0081800.xyz/notes/20220311075423-two_pointer/</link>
      <pubDate>Fri, 11 Mar 2022 07:54:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220311075423-two_pointer/</guid>
      <description> tags: Algorithm </description>
    </item>
    
    <item>
      <title>Differences between Sliding Window and Two Pointers</title>
      <link>https://notes.0081800.xyz/notes/20220311075357-differences_between_sliding_window_and_two_pointer/</link>
      <pubDate>Fri, 11 Mar 2022 07:53:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220311075357-differences_between_sliding_window_and_two_pointer/</guid>
      <description>tags: Sliding Window,Two Pointers source: 力扣 LeetCode. “题解：借这个问题科普一下「滑动窗口」和「双指针」的区别 - 力扣（LeetCode）.” Accessed March 11, 2022. https://leetcode-cn.com/problems/get-equal-substrings-within-budget/solution/jie-zhe-ge-wen-ti-ke-pu-yi-xia-hua-dong-6128z/. https://stackoverflow.com/a/64078338 Two Pointer to slove the problem of two elements that two pointes pointed.
Sliding Window to slove the problem of all elements that in the window.</description>
    </item>
    
    <item>
      <title>LeetCode101: 3. Longest Substring Without Repeating Characters</title>
      <link>https://notes.0081800.xyz/notes/20220311074801-3_longest_substring_without_repeating_characters/</link>
      <pubDate>Fri, 11 Mar 2022 07:48:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220311074801-3_longest_substring_without_repeating_characters/</guid>
      <description>tags: Sliding Window,LeetCode101,Hash Table Use HashMap to store counts of letters Two points we should be noticed:
The length of substring should be (right - left) + 1, as one side must be counted.
We must decrese the number in the counts first, and then slide the left window, or we must decrese the wrong one, please compare between Wrong and Correct.
Wrong
left++; counts[s[left]]--; Correct
counts[s[left]]--; left++; The full code see:</description>
    </item>
    
    <item>
      <title>Sliding Window</title>
      <link>https://notes.0081800.xyz/notes/20220311074820-sliding_window/</link>
      <pubDate>Fri, 11 Mar 2022 07:48:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220311074820-sliding_window/</guid>
      <description> tags: Algorithm Slide right to move forward to find the solution. Slide left to keep the solution, and collect to the results. Must avoid left go to backward. </description>
    </item>
    
    <item>
      <title>445. Add Two Numbers II</title>
      <link>https://notes.0081800.xyz/notes/20220311073803-445_add_two_numbers_ii/</link>
      <pubDate>Fri, 11 Mar 2022 07:38:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220311073803-445_add_two_numbers_ii/</guid>
      <description></description>
    </item>
    
    <item>
      <title>LeetCode101: 445. Add Two Numbers II</title>
      <link>https://notes.0081800.xyz/notes/20220311073810-445_add_two_numbers_ii/</link>
      <pubDate>Fri, 11 Mar 2022 07:38:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220311073810-445_add_two_numbers_ii/</guid>
      <description>tags: Linked List,Stack, LeetCode101,2. Add Two Numbers 两数之和的进阶版，位高的数字在链表的头部，常规解法是通过「栈」进行反转链表，然后回退到2. Add Two Numbers的解法。</description>
    </item>
    
    <item>
      <title>Stack</title>
      <link>https://notes.0081800.xyz/notes/20220311073821-stack/</link>
      <pubDate>Fri, 11 Mar 2022 07:38:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220311073821-stack/</guid>
      <description> tags: Data Structures </description>
    </item>
    
    <item>
      <title>Linked List</title>
      <link>https://notes.0081800.xyz/notes/20220311070813-linked_list/</link>
      <pubDate>Fri, 11 Mar 2022 07:08:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220311070813-linked_list/</guid>
      <description> tags: Data Structures </description>
    </item>
    
    <item>
      <title>LeetCode101: 2. Add Two Numbers</title>
      <link>https://notes.0081800.xyz/notes/20220311070727-2_add_two_numbers/</link>
      <pubDate>Fri, 11 Mar 2022 07:07:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220311070727-2_add_two_numbers/</guid>
      <description>tags: Linked List, LeetCode101 正常的「链表」遍历操作，需要注意的就是不要在末尾忘记处理进位，如果 carry 大于 0 需要追加到结果链表末尾。</description>
    </item>
    
    <item>
      <title>Linked List</title>
      <link>https://notes.0081800.xyz/notes/20220311070749-linked_list/</link>
      <pubDate>Fri, 11 Mar 2022 07:07:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220311070749-linked_list/</guid>
      <description></description>
    </item>
    
    <item>
      <title>LeetCode101</title>
      <link>https://notes.0081800.xyz/notes/20220311065137-leetcode101/</link>
      <pubDate>Fri, 11 Mar 2022 06:51:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220311065137-leetcode101/</guid>
      <description>tags: Algorithm,Data Structures 又要开始找工作了，刷题、刷题、刷题！步骤：
按顺序找到题目 解题/学习 总结考察的点（树、双指针、回溯、DP、模拟现实、递归） 刷相同解法框架的题 一些模糊的感觉：
尝试不同的遍历顺序可能是解题关键，正序遍历不行试一下反序遍历，反之亦然！ 以上到达一定量之后在 LeetCode 创建一个新的 session 重新刷起。</description>
    </item>
    
    <item>
      <title>fork() is evil; vfork() is goodness; afork() would be better; clone() is stupid</title>
      <link>https://notes.0081800.xyz/notes/20220302114010-fork_is_evil_vfork_is_goodness_afork_would_be_better_clone_is_stupid/</link>
      <pubDate>Wed, 02 Mar 2022 11:40:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220302114010-fork_is_evil_vfork_is_goodness_afork_would_be_better_clone_is_stupid/</guid>
      <description> tags: Computer Systems,Linux source: 262588213843476. “Fork() Is Evil; Vfork() Is Goodness; Afork() Would Be Better; Clone() Is Stupid.” Gist. Accessed March 2, 2022. https://gist.github.com/nicowilliams/a8a07b0fc75df05f684c23c18d7db234. </description>
    </item>
    
    <item>
      <title>Podcast/YouTube: Lex Fridman</title>
      <link>https://notes.0081800.xyz/notes/20220228105442-podcast_youtube_lex_fridman/</link>
      <pubDate>Mon, 28 Feb 2022 10:54:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220228105442-podcast_youtube_lex_fridman/</guid>
      <description> tags: English Listening Practice source: https://www.youtube.com/channel/UCSHZKyawb77ixDdsGog4iWA </description>
    </item>
    
    <item>
      <title>English Listening Practice</title>
      <link>https://notes.0081800.xyz/notes/20220228104819-english_listening_practice/</link>
      <pubDate>Mon, 28 Feb 2022 10:48:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220228104819-english_listening_practice/</guid>
      <description> tags: Learning English </description>
    </item>
    
    <item>
      <title>的地得</title>
      <link>https://notes.0081800.xyz/notes/20220226070756-%E7%9A%84%E5%9C%B0%E5%BE%97/</link>
      <pubDate>Sat, 26 Feb 2022 07:07:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220226070756-%E7%9A%84%E5%9C%B0%E5%BE%97/</guid>
      <description> 物前白 动前土 行动后面双人来 </description>
    </item>
    
    <item>
      <title>Wealth</title>
      <link>https://notes.0081800.xyz/notes/20220221084730-wealth/</link>
      <pubDate>Mon, 21 Feb 2022 08:47:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220221084730-wealth/</guid>
      <description></description>
    </item>
    
    <item>
      <title>How To Get Rich (without getting lucky)</title>
      <link>https://notes.0081800.xyz/notes/20220221083059-how_to_get_rich_without_getting_lucky/</link>
      <pubDate>Mon, 21 Feb 2022 08:30:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220221083059-how_to_get_rich_without_getting_lucky/</guid>
      <description> tags: Financial Management,Wealth,English Listening Practice source: Naval. “How to Get Rich,” December 28, 2019. https://nav.al/rich. YouTube: https://www.youtube.com/watch?v=1-TZqOsVCNM </description>
    </item>
    
    <item>
      <title>Material Design</title>
      <link>https://notes.0081800.xyz/notes/20220212074018-material_design/</link>
      <pubDate>Sat, 12 Feb 2022 07:40:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220212074018-material_design/</guid>
      <description> tags: Design </description>
    </item>
    
    <item>
      <title>Material Design:  Tools for picking colors</title>
      <link>https://notes.0081800.xyz/notes/20220212074044-material_design_tools_for_picking_colors/</link>
      <pubDate>Sat, 12 Feb 2022 07:40:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220212074044-material_design_tools_for_picking_colors/</guid>
      <description> tags: Online Tools,Material Design,Design source: https://material.io/design/color/the-color-system.html#tools-for-picking-colors full: https://material.io/resources/color/#!/?view.left=0&amp;amp;view.right=0&amp;amp;primary.color=b3e4ff </description>
    </item>
    
    <item>
      <title>Design</title>
      <link>https://notes.0081800.xyz/notes/20220212073844-design/</link>
      <pubDate>Sat, 12 Feb 2022 07:38:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220212073844-design/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Material Design: The color system</title>
      <link>https://notes.0081800.xyz/notes/20220212073824-material_design_the_color_system/</link>
      <pubDate>Sat, 12 Feb 2022 07:38:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220212073824-material_design_the_color_system/</guid>
      <description>tags: Design,Material Design: Tools for picking colorsMaterial Design source: Material Design. “Material Design.” Accessed February 12, 2022. https://material.io/design/color/the-color-system.html#color-usage-and-palettes. Principles Hierarchical
Color indicates which elements are interactive, how they relate to other elements, and their level of prominence. Important elements should stand out the most.
Legible
Text and import elements, like icons, should meet legibility standards when appearing on colored backgrounds.
Expressive
Show brand colors at memorable moments that reinforce your brand&amp;rsquo;s style.</description>
    </item>
    
    <item>
      <title>GTK</title>
      <link>https://notes.0081800.xyz/notes/20220209130912-gtk/</link>
      <pubDate>Wed, 09 Feb 2022 13:09:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220209130912-gtk/</guid>
      <description></description>
    </item>
    
    <item>
      <title>GUI</title>
      <link>https://notes.0081800.xyz/notes/20220209130903-gui/</link>
      <pubDate>Wed, 09 Feb 2022 13:09:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220209130903-gui/</guid>
      <description></description>
    </item>
    
    <item>
      <title>GTK&#43; 3 Text Widget Overview</title>
      <link>https://notes.0081800.xyz/notes/20220209130852-gtk_3_text_widget_overview/</link>
      <pubDate>Wed, 09 Feb 2022 13:08:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220209130852-gtk_3_text_widget_overview/</guid>
      <description> tags: GUI,GTK source: “Text Widget Overview.” Accessed February 9, 2022. https://docs.huihoo.com/gtk/3.0.3/TextWidget.html. GtkTextBuffer for the text to edit. GtkTextIter to manipulate text, can&amp;rsquo;t be used to preserve positions across buffer modifications GtkTextMark can be used to preserve a position. GtkTextView to show GtkTextBuffer. GtkTextTagTable to control the appearence of text, like bold/color/etc. </description>
    </item>
    
    <item>
      <title>GitHub: antoyo/relm  – Idiomatic, GTK&#43;-based, GUI library, inspired by Elm, written in Rust</title>
      <link>https://notes.0081800.xyz/notes/20220208150754-github_antoyo_relm_idiomatic_gtk_based_gui_library_inspired_by_elm_written_in_rust/</link>
      <pubDate>Tue, 08 Feb 2022 15:07:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220208150754-github_antoyo_relm_idiomatic_gtk_based_gui_library_inspired_by_elm_written_in_rust/</guid>
      <description> tags: Rust GUI,Elm,GTK </description>
    </item>
    
    <item>
      <title>Elm</title>
      <link>https://notes.0081800.xyz/notes/20220208150622-elm/</link>
      <pubDate>Tue, 08 Feb 2022 15:06:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220208150622-elm/</guid>
      <description>source: https://elm-lang.org/ A delightful language for reliable web applications.</description>
    </item>
    
    <item>
      <title>GitHub: iced-rs/iced – A cross-platform GUI library for Rust, inspired by Elm</title>
      <link>https://notes.0081800.xyz/notes/20220208150550-github_iced_rs_iced_a_cross_platform_gui_library_for_rust_inspired_by_elm/</link>
      <pubDate>Tue, 08 Feb 2022 15:05:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220208150550-github_iced_rs_iced_a_cross_platform_gui_library_for_rust_inspired_by_elm/</guid>
      <description>tags: Rust GUI,Elm The most popular GUI library for Rust.</description>
    </item>
    
    <item>
      <title>Are we GUI Yet?</title>
      <link>https://notes.0081800.xyz/notes/20220208150415-are_we_gui_yet/</link>
      <pubDate>Tue, 08 Feb 2022 15:04:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220208150415-are_we_gui_yet/</guid>
      <description>tags: Rust GUI source: “Are We GUI Yet?” Accessed February 8, 2022. https://www.areweguiyet.com/. The answer is no, it seems the most popular GUI libraries are beta and not production ready.
GitHub: antoyo/relm &amp;ndash; Idiomatic, GTK+-based, GUI library, inspired by Elm, written in Rust GitHub: iced-rs/iced &amp;ndash; A cross-platform GUI library for Rust, inspired by Elm GitHub: linebender/druid &amp;ndash; A data-first Rust-native UI design toolkit. GitHub: redox-os/orbtk &amp;ndash; The Rust UI-Toolkit.</description>
    </item>
    
    <item>
      <title>GitHub: linebender/druid – A data-first Rust-native UI design toolkit.</title>
      <link>https://notes.0081800.xyz/notes/20220208133213-github_linebender_druid_a_data_first_rust_native_ui_design_toolkit/</link>
      <pubDate>Tue, 08 Feb 2022 13:32:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220208133213-github_linebender_druid_a_data_first_rust_native_ui_design_toolkit/</guid>
      <description> tags: Rust,Rust GUI Overview Platform Documentation Community Activity Most Activity Period Native UI Cross platform Leak 5.7k stars Yes 2019-2021 No Conclusion Use the the platform-native widgets or mimic them. (Relm, SixtyFPS) Embed easily into custom render pipelines. (Conrod) Adhere to a specific architectural style such as Elm. (Iced, Relm) Support rendering to HTML when targeting the web. (Iced, Moxie) </description>
    </item>
    
    <item>
      <title>GitHub: redox-os/orbtk –  The Rust UI-Toolkit.</title>
      <link>https://notes.0081800.xyz/notes/20220208121018-github_redox_os_orbtk_the_rust_ui_toolkit/</link>
      <pubDate>Tue, 08 Feb 2022 12:10:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220208121018-github_redox_os_orbtk_the_rust_ui_toolkit/</guid>
      <description> tags: Rust,Rust GUI Overview Platform Documentation Community Activity Most Activity Period Native UI Cross platform Leak 3.5k stars Kind of 2020 No Conclusion Highlights &amp;ndash; Cross platform Downsides &amp;ndash; Documentation leak and not in activity development. </description>
    </item>
    
    <item>
      <title>Rust GUI</title>
      <link>https://notes.0081800.xyz/notes/20220208121029-rust_gui/</link>
      <pubDate>Tue, 08 Feb 2022 12:10:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220208121029-rust_gui/</guid>
      <description> tags: Rust,GUI </description>
    </item>
    
    <item>
      <title>The Dark Side Of Smart Contracts</title>
      <link>https://notes.0081800.xyz/notes/20220208070254-the_dark_side_of_smart_contracts/</link>
      <pubDate>Tue, 08 Feb 2022 07:02:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220208070254-the_dark_side_of_smart_contracts/</guid>
      <description>tags: Smart contracts source: Business Tech Guides. “The Dark Side Of Smart Contracts.” Accessed February 7, 2022. https://businesstechguides.co/smart-contracts. WHAT are Smart Contracts? Blockchain-based programmes that execute agreements once certain criteria are fulfilled by all parties involved.
A self-executing piece of code. When it&amp;rsquo;s deployed on blockchain, meaning nobody controls it.
Analog a contract in the real world, for example, the contract you are signed with your landloard to lease an apartment.</description>
    </item>
    
    <item>
      <title>YouTube: 250. My Zettelkasten: An Author’s Digital Slip-Box Method Example (Using Plain-Text Software)</title>
      <link>https://notes.0081800.xyz/notes/20220123081120-youtube_250_my_zettelkasten_an_author_s_digital_slip_box_method_example_using_plain_text_software/</link>
      <pubDate>Sun, 23 Jan 2022 08:11:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220123081120-youtube_250_my_zettelkasten_an_author_s_digital_slip_box_method_example_using_plain_text_software/</guid>
      <description>tags: slip-box,PKM source: David Kadavy. 250. My Zettelkasten: An Author’s Digital Slip-Box Method Example (Using Plain-Text Software), 2021. https://www.youtube.com/watch?v=Ji96vbaCT-s. Using a GTD pattern to collect notes:
An Inbox to collect Fleeting Notes.
Review the Inbox periodically.
a. If it&amp;rsquo;s still interesting, then move it to the Permanent Notes. b. Otherwise move it to &amp;ldquo;Some day&amp;rdquo;</description>
    </item>
    
    <item>
      <title>为什么要定期回顾：避免「我学会了」的假象</title>
      <link>https://notes.0081800.xyz/notes/20220123080003-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AE%9A%E6%9C%9F%E5%9B%9E%E9%A1%BE_%E9%81%BF%E5%85%8D_%E6%88%91%E5%AD%A6%E4%BC%9A%E4%BA%86_%E7%9A%84%E5%81%87%E8%B1%A1/</link>
      <pubDate>Sun, 23 Jan 2022 08:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220123080003-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AE%9A%E6%9C%9F%E5%9B%9E%E9%A1%BE_%E9%81%BF%E5%85%8D_%E6%88%91%E5%AD%A6%E4%BC%9A%E4%BA%86_%E7%9A%84%E5%81%87%E8%B1%A1/</guid>
      <description>tags: slip-box,How to Take Smart Notes,PKM 参考：YouTube: 250. My Zettelkasten: An Author’s Digital Slip-Box Method Example (Using Plain-Text Software) 我身边有很多人包括我自己都很喜欢收藏文章、课程和教学视频等学习类资源，当然还包括给 GitHub 上的项目添加星星。一些更努力的人会在收藏后进行阅读并记录笔记，我们的学习焦虑被得到了满足。 然后呢？你会去看收藏的学习资源吗？会定期查看自己的笔记吗？我觉得这更像是一种自我欺骗或者麻痹，一种「我学会了」的假象被制造出来。
定期回顾总结可以避免这种假象，这是我最近实践 Luhmann 的 Zettelkasten 所学习到的。 先通过 Overaching workflow 记下所有我们需要关注的主题到 Inbox 中，然后通过回顾的方式来总结转化成自己的知识，记录到 PKM 中去。 也就是依然可以去“收藏”，但是要定期的去查看自己的收藏，最好不要太久以免忘记自己为什么收藏。 如果收藏了很多大部分已经没有兴趣了，可以参考 GTD 将内容整理到 Some day 中去，避免 Inbox 过大让我们产生畏惧感从而导致我们放弃。</description>
    </item>
    
    <item>
      <title>记笔记就像编相声</title>
      <link>https://notes.0081800.xyz/notes/20220123075328-%E8%AE%B0%E7%AC%94%E8%AE%B0%E5%B0%B1%E5%83%8F%E7%BC%96%E7%9B%B8%E5%A3%B0/</link>
      <pubDate>Sun, 23 Jan 2022 07:53:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220123075328-%E8%AE%B0%E7%AC%94%E8%AE%B0%E5%B0%B1%E5%83%8F%E7%BC%96%E7%9B%B8%E5%A3%B0/</guid>
      <description>tags: slip-box,How to Take Smart Notes source: 豆瓣. “记笔记就像编相声.” Accessed January 22, 2022. https://book.douban.com/review/12678970/. 通过「收集 -&amp;gt; 整理 -&amp;gt; 回顾 -&amp;gt; 输出」将听到的段子转化成自己的故事。所以说书中所说的 “Writing” 不能只局限于写作，应该扩展为输出更好。
比如我作为一个程序员，很多研究都是为了落地成为具体的产品或者技术方案，这个时候我就是在输出（Writing），而且有更加明显的反馈。 通过所学的知识能不能搭建具体的技术方案，实现具体的产品需求。
「输出」或者按照 “How to Take Smart Notes” 中说的 “Writing”。输出给了你一个明确的目标，让你在看到、听到、读到的时候有一个明确的目标， 驱动你用自己的语言将知识进行转化，并在其之上进行思考。</description>
    </item>
    
    <item>
      <title>The Four Underlying Principles of Taking Smart Notes</title>
      <link>https://notes.0081800.xyz/notes/20220123075024-the_four_underlying_priciples/</link>
      <pubDate>Sun, 23 Jan 2022 07:50:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220123075024-the_four_underlying_priciples/</guid>
      <description>tags: How to Take Smart Notes,slip-box,PKM source: Part 2: &amp;ldquo;THE FOUR UNDERLYING PRINCIPLES&amp;rdquo; from Ahrens, Sönke. How to Take Smart Notes: One Simple Technique to Boost Writing, Learning and Thinking: For Students, Academics and Nonfiction Book Writers. North Charleston, SC: CreateSpace, 2017. Writing Is the Only Thing That Matters Don&amp;rsquo;t be afraid to writing ideas down and push them public, as there is no private knowledge in the academia area, and there is no such thing as a history of unwritten ideas.</description>
    </item>
    
    <item>
      <title>Personal Knowledge Management</title>
      <link>https://notes.0081800.xyz/notes/20220122071820-personal_knowledge_management/</link>
      <pubDate>Sat, 22 Jan 2022 07:18:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220122071820-personal_knowledge_management/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Zettelkasten 卡片盒筆記法，建立知識連結網路來活用筆記</title>
      <link>https://notes.0081800.xyz/notes/20220120084941-zettelkasten_%E5%8D%A1%E7%89%87%E7%9B%92%E7%AD%86%E8%A8%98%E6%B3%95_%E5%BB%BA%E7%AB%8B%E7%9F%A5%E8%AD%98%E9%80%A3%E7%B5%90%E7%B6%B2%E8%B7%AF%E4%BE%86%E6%B4%BB%E7%94%A8%E7%AD%86%E8%A8%98/</link>
      <pubDate>Thu, 20 Jan 2022 08:49:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220120084941-zettelkasten_%E5%8D%A1%E7%89%87%E7%9B%92%E7%AD%86%E8%A8%98%E6%B3%95_%E5%BB%BA%E7%AB%8B%E7%9F%A5%E8%AD%98%E9%80%A3%E7%B5%90%E7%B6%B2%E8%B7%AF%E4%BE%86%E6%B4%BB%E7%94%A8%E7%AD%86%E8%A8%98/</guid>
      <description>tags: Zettelkasten,Note-Taking,How to Take Smart Notes source: 朱騏. “Zettelkasten卡片盒筆記法，建立知識連結網路來活用筆記.” PM的生產力工具箱 (blog), October 16, 2021. https://medium.com/pm%E7%9A%84%E7%94%9F%E7%94%A2%E5%8A%9B%E5%B7%A5%E5%85%B7%E7%AE%B1/zettelkasten%E5%8D%A1%E7%89%87%E7%9B%92%E7%AD%86%E8%A8%98%E6%B3%95-%E5%BB%BA%E7%AB%8B%E7%9F%A5%E8%AD%98%E9%80%A3%E7%B5%90%E7%B6%B2%E8%B7%AF%E4%BE%86%E6%B4%BB%E7%94%A8%E7%AD%86%E8%A8%98-f85a91729521. 文章中附上了一则视频更好的展现 Luhmann 如何管理文件笔记，同时建立了我对 Slip-box 的中文理解。完善了我脑中的一部分图像。</description>
    </item>
    
    <item>
      <title>GTD</title>
      <link>https://notes.0081800.xyz/notes/20220120080936-gtd/</link>
      <pubDate>Thu, 20 Jan 2022 08:09:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220120080936-gtd/</guid>
      <description></description>
    </item>
    
    <item>
      <title>slip-box</title>
      <link>https://notes.0081800.xyz/notes/20220120080920-slip_box/</link>
      <pubDate>Thu, 20 Jan 2022 08:09:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220120080920-slip_box/</guid>
      <description> tags: Note-Taking,Personal Knowledge Management </description>
    </item>
    
    <item>
      <title>Why Rust strings seem hard</title>
      <link>https://notes.0081800.xyz/notes/20220117170333-why_rust_strings_seem_hard/</link>
      <pubDate>Mon, 17 Jan 2022 17:03:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220117170333-why_rust_strings_seem_hard/</guid>
      <description> tags: Rust “Why Rust Strings Seem Hard | Brandon’s Website.” Accessed January 17, 2022. https://www.brandons.me/blog/why-rust-strings-seem-hard. </description>
    </item>
    
    <item>
      <title>Thread Safety</title>
      <link>https://notes.0081800.xyz/notes/20220117165224-thread_safety/</link>
      <pubDate>Mon, 17 Jan 2022 16:52:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220117165224-thread_safety/</guid>
      <description> tags: Computer Systems </description>
    </item>
    
    <item>
      <title>如何理解 Sync 和 Send?</title>
      <link>https://notes.0081800.xyz/notes/20220117165142-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3_sync_%E5%92%8C_send/</link>
      <pubDate>Mon, 17 Jan 2022 16:51:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220117165142-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3_sync_%E5%92%8C_send/</guid>
      <description> tags: Rust,Thread Safety source: Hexi. “如何理解 Sync 和 Send?” 李晨曦的博客 | Hexi Blog, May 5, 2019. https://hexilee.me/2019/05/05/how-to-understand-sync-and-send-in-rust/. 语义：
实现了 Send 的类型，可以安全地在线程间传递所有权。也就是说， 可以跨线程移动。 实现了 Sync 的类型， 可以安全地在线程间传递不可变借用。也就是说，可以跨线程共享。 </description>
    </item>
    
    <item>
      <title>The Little Book of Rust Macros</title>
      <link>https://notes.0081800.xyz/notes/20220117164736-the_little_book_of_rust_macros/</link>
      <pubDate>Mon, 17 Jan 2022 16:47:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220117164736-the_little_book_of_rust_macros/</guid>
      <description> tags: Rust,Rust Macro,Online Tutorial source: https://danielkeep.github.io/tlborm/book/index.html </description>
    </item>
    
    <item>
      <title>A half-hour to learn Rust</title>
      <link>https://notes.0081800.xyz/notes/20220117164630-a_half_hour_to_learn_rust/</link>
      <pubDate>Mon, 17 Jan 2022 16:46:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220117164630-a_half_hour_to_learn_rust/</guid>
      <description> tags: Rust,Online Tutorial source: fasterthanli.me. “A Half-Hour to Learn Rust.” Accessed January 17, 2022. https://fasterthanli.me/articles/a-half-hour-to-learn-rust. </description>
    </item>
    
    <item>
      <title>Rust Macro</title>
      <link>https://notes.0081800.xyz/notes/20220117164506-rust_macro/</link>
      <pubDate>Mon, 17 Jan 2022 16:45:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220117164506-rust_macro/</guid>
      <description> tags: Rust </description>
    </item>
    
    <item>
      <title>GitHub: dtolnay/proc-macro-workshop - Learn to write Rust procedural macros</title>
      <link>https://notes.0081800.xyz/notes/20220117164450-github_dtolnay_proc_macro_workshop_learn_to_write_rust_procedural_macros/</link>
      <pubDate>Mon, 17 Jan 2022 16:44:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220117164450-github_dtolnay_proc_macro_workshop_learn_to_write_rust_procedural_macros/</guid>
      <description> tags: Rust,Rust Macro,Learning </description>
    </item>
    
    <item>
      <title>GitHub: pingcap/talent-plan - open source training courses about distributed database and distributed systemes</title>
      <link>https://notes.0081800.xyz/notes/20220117164352-github_pingcap_talent_plan_open_source_training_courses_about_distributed_database_and_distributed_systemes/</link>
      <pubDate>Mon, 17 Jan 2022 16:43:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220117164352-github_pingcap_talent_plan_open_source_training_courses_about_distributed_database_and_distributed_systemes/</guid>
      <description> tags: Rust,Distributed Systems,Online Tutorial,Learning source: https://github.com/pingcap/talent-plan </description>
    </item>
    
    <item>
      <title>GitHub: rust-lang/rustlings – Small exercises to get you used to reading and writing Rust code!</title>
      <link>https://notes.0081800.xyz/notes/20220117164303-github_rust_lang_rustlings_small_exercises_to_get_you_used_to_reading_and_writing_rust_code/</link>
      <pubDate>Mon, 17 Jan 2022 16:43:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220117164303-github_rust_lang_rustlings_small_exercises_to_get_you_used_to_reading_and_writing_rust_code/</guid>
      <description> tags: Rust,Online Tutorial,Learning source: https://github.com/rust-lang/rustlings </description>
    </item>
    
    <item>
      <title>Blockchain: It&#39;s not still the early days</title>
      <link>https://notes.0081800.xyz/notes/20220117110536-blockchain_it_s_not_still_the_early_days/</link>
      <pubDate>Mon, 17 Jan 2022 11:05:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220117110536-blockchain_it_s_not_still_the_early_days/</guid>
      <description>tags: Blockchain,Web3 source: White, Molly. “It’s Not Still the Early Days.” Molly White, January 14, 2022. https://blog.mollywhite.net/its-not-still-the-early-days/. For blockchains, some thoughts are false, like:
&amp;ldquo;It&amp;rsquo;s the early days.&amp;rdquo; &amp;ldquo;Give it a chance.&amp;rdquo; The reason is long time have passed, but no bright changes happened, the long time means Bitcoin began to be used in 2009, and Ethereum lanched in 2015.
To compare:
Smartphones from 2009 to 2015: Nokia -&amp;gt; iPhone/Android.</description>
    </item>
    
    <item>
      <title>AQM</title>
      <link>https://notes.0081800.xyz/notes/20220114071913-aqm/</link>
      <pubDate>Fri, 14 Jan 2022 07:19:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220114071913-aqm/</guid>
      <description> tags: Network,Message Queue </description>
    </item>
    
    <item>
      <title>Message Queue</title>
      <link>https://notes.0081800.xyz/notes/20220114071952-message_queue/</link>
      <pubDate>Fri, 14 Jan 2022 07:19:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220114071952-message_queue/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Bufferbloat Dark Buffers in the Internet</title>
      <link>https://notes.0081800.xyz/notes/20220114070627-bufferbloat_dark_buffers_in_the_internet/</link>
      <pubDate>Fri, 14 Jan 2022 07:06:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220114070627-bufferbloat_dark_buffers_in_the_internet/</guid>
      <description> tags: Network,Bufferbloat source: “Bufferbloat - Dark Buffers in the Internet,” 2011, 36. </description>
    </item>
    
    <item>
      <title>Bufferbloat</title>
      <link>https://notes.0081800.xyz/notes/20220114070451-bufferbloat/</link>
      <pubDate>Fri, 14 Jan 2022 07:04:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220114070451-bufferbloat/</guid>
      <description> tags: Network </description>
    </item>
    
    <item>
      <title>5W1H</title>
      <link>https://notes.0081800.xyz/notes/20220112070827-5w1h/</link>
      <pubDate>Wed, 12 Jan 2022 07:08:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220112070827-5w1h/</guid>
      <description> tags: Learning Ask 6 questions to familiar a new thing:
Why What Where When Who How </description>
    </item>
    
    <item>
      <title>TCP Fast Open</title>
      <link>https://notes.0081800.xyz/notes/20220112070151-tcp_fast_open/</link>
      <pubDate>Wed, 12 Jan 2022 07:01:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220112070151-tcp_fast_open/</guid>
      <description>tags: TCP,Network,5W1H TCP Fast Open(TFO):
WHY TFO is proposed?
TCP Three-Way Handshake for every new TCP connection is too expensive.
WHAT is the TFO?
TCP Fast Open (TFO) is a mechanism that aims to reduce the latency penalty imposed on new TCP connections.
HOW the TFO reduce the latency on new TCP connections?
TFO allows data transfer within the SYN packet.
WHEN the TFO is avaiable.
TFO support is now avaiable in Linux 3.</description>
    </item>
    
    <item>
      <title>Controlling Queue Delay</title>
      <link>https://notes.0081800.xyz/notes/20220111081756-controlling_queue_delay/</link>
      <pubDate>Tue, 11 Jan 2022 08:17:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220111081756-controlling_queue_delay/</guid>
      <description>tags: CoDel,Network source: “Controlling Queue Delay - ACM Queue.” Accessed January 11, 2022. https://queue.acm.org/detail.cfm?id=2209336. Bufferbloat What is the bufferbloat? In the internet, large buffer is used everywhere:
PC Router/Swtich/ISP Server The large may cause delay.
Why the bufferbloat still with us and made increaingly critical by two trends?
Cheap memory. Complicate network paths. How to sloves the problem? AQM(active queue management) is the known solution, but it&amp;rsquo;s difficult to implement, so even it has been known two decades but still not been widely deployed.</description>
    </item>
    
    <item>
      <title>CoDel</title>
      <link>https://notes.0081800.xyz/notes/20220111081657-codel/</link>
      <pubDate>Tue, 11 Jan 2022 08:16:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220111081657-codel/</guid>
      <description> tags: Network,Bufferbloat,AQM </description>
    </item>
    
    <item>
      <title>Fun Bugs</title>
      <link>https://notes.0081800.xyz/notes/20220111072413-fun_bugs/</link>
      <pubDate>Tue, 11 Jan 2022 07:24:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220111072413-fun_bugs/</guid>
      <description> tags: Fun Story </description>
    </item>
    
    <item>
      <title>Fun Story</title>
      <link>https://notes.0081800.xyz/notes/20220111072424-fun_story/</link>
      <pubDate>Tue, 11 Jan 2022 07:24:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220111072424-fun_story/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Speed of Light: We can&#39;t send mail more than 500 miles</title>
      <link>https://notes.0081800.xyz/notes/20220111072354-speed_of_light_we_can_t_send_mail_more_than_500_miles/</link>
      <pubDate>Tue, 11 Jan 2022 07:23:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220111072354-speed_of_light_we_can_t_send_mail_more_than_500_miles/</guid>
      <description>tags: Networking 101: Primer on Latency and Bandwidth,Fun Bugs source: https://web.mit.edu/jemorris/humor/500-miles I remember this story when I&amp;rsquo;m reading the section &amp;ldquo;Speed of Light and Propagation Latency&amp;rdquo; in High Performance Browser Networking. It&amp;rsquo;s funny to record it.</description>
    </item>
    
    <item>
      <title>Networking 101: Primer on Latency and Bandwidth</title>
      <link>https://notes.0081800.xyz/notes/20220111071605-networking_101_primer_on_latency_and_bandwidth/</link>
      <pubDate>Tue, 11 Jan 2022 07:16:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220111071605-networking_101_primer_on_latency_and_bandwidth/</guid>
      <description> tags: High Performance Browser Networking,Network Defination:
Latency - Time cost between sending and receiving, lower is better. Bandwitdh - throughtput, higher is better. Things affect to Latency:
Distance of fiber, Speed of Light, that could be optimized by CDN. Bufferbloat of router, large buffer make queue delay, addressed by CoDel. ISP gateway. </description>
    </item>
    
    <item>
      <title>Reproducible Research Papers using Org-mode and R: A Guide</title>
      <link>https://notes.0081800.xyz/notes/20220110121108-reproducible_research_papers_using_org_mode_and_r_a_guide/</link>
      <pubDate>Mon, 10 Jan 2022 12:11:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220110121108-reproducible_research_papers_using_org_mode_and_r_a_guide/</guid>
      <description> tags: Org Mode,How to Write source: https://github.com/vikasrawal/orgpaper </description>
    </item>
    
    <item>
      <title>How to Take Smart Notes</title>
      <link>https://notes.0081800.xyz/notes/20220110110642-how_to_take_smart_notes/</link>
      <pubDate>Mon, 10 Jan 2022 11:06:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220110110642-how_to_take_smart_notes/</guid>
      <description> tags: Note-Taking,How to Write,Zettelkasten,读书笔记 source: Ahrens, Sönke. How to Take Smart Notes: One Simple Technique to Boost Writing, Learning and Thinking: For Students, Academics and Nonfiction Book Writers. North Charleston, SC: CreateSpace, 2017. </description>
    </item>
    
    <item>
      <title>HTTP</title>
      <link>https://notes.0081800.xyz/notes/20220110082953-http/</link>
      <pubDate>Mon, 10 Jan 2022 08:29:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220110082953-http/</guid>
      <description> tags: TCP </description>
    </item>
    
    <item>
      <title>GitHub: duckwork/titlecase.el -  Titlecase things in Emacs</title>
      <link>https://notes.0081800.xyz/notes/20220110071604-github_duckwork_titlecase_el_titlecase_things_in_emacs/</link>
      <pubDate>Mon, 10 Jan 2022 07:16:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220110071604-github_duckwork_titlecase_el_titlecase_things_in_emacs/</guid>
      <description> tags: Title Case,Emacs source: https://github.com/duckwork/titlecase.el </description>
    </item>
    
    <item>
      <title>Chicago Manual of Style: Chapter 8 Names, Terms, and Titles of Works</title>
      <link>https://notes.0081800.xyz/notes/20220110071319-chicago_manual_of_style_chaper_8_names_terms_and_titles_of_works/</link>
      <pubDate>Mon, 10 Jan 2022 07:13:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220110071319-chicago_manual_of_style_chaper_8_names_terms_and_titles_of_works/</guid>
      <description> tags: Learning English,Online: Title Case source: The Chicago Manual of Style. Seventeenth edition. Chicago: The University of Chicago Press, 2017. </description>
    </item>
    
    <item>
      <title>Online: Title Case</title>
      <link>https://notes.0081800.xyz/notes/20220110070643-online_title_case/</link>
      <pubDate>Mon, 10 Jan 2022 07:06:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220110070643-online_title_case/</guid>
      <description> tags: Online Tools,Title Case source: https://titlecase.com/ </description>
    </item>
    
    <item>
      <title>Title Case</title>
      <link>https://notes.0081800.xyz/notes/20220110070124-title_case/</link>
      <pubDate>Mon, 10 Jan 2022 07:01:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220110070124-title_case/</guid>
      <description> tags: Learning English,Writing </description>
    </item>
    
    <item>
      <title>The Programmer&#39;s Way to Write in Title Case Using Emacs Lisp</title>
      <link>https://notes.0081800.xyz/notes/20220110070044-the_programmer_s_way_to_write_in_title_case_using_emacs_lisp/</link>
      <pubDate>Mon, 10 Jan 2022 07:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220110070044-the_programmer_s_way_to_write_in_title_case_using_emacs_lisp/</guid>
      <description>tags: Learning English,Title Case source: “The Programmer’s Way to Write in Title Case Using Emacs Lisp.” Accessed January 10, 2022. https://hungyi.net/posts/programmers-way-to-title-case. Genernal correct title cased phrase:
Uppercase the first letter of most words
e.g. &amp;ldquo;There Is No Spoon&amp;rdquo;
Not capitalize &amp;lsquo;small&amp;rsquo; and &amp;lsquo;unimportant&amp;rsquo; words
e.g. &amp;ldquo;Long Live the King&amp;rdquo;
Always capitalize the first and the last words, even if they&amp;rsquo;re small
e.g. &amp;ldquo;The Land and Save We Live On&amp;rdquo;</description>
    </item>
    
    <item>
      <title>Patterns of Distributed Systems: Quorum</title>
      <link>https://notes.0081800.xyz/notes/20220107113911-patterns_of_distributed_systems_quorum/</link>
      <pubDate>Fri, 07 Jan 2022 11:39:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220107113911-patterns_of_distributed_systems_quorum/</guid>
      <description> tags: quorum,一致性，Distributed Systems,Patterns of Distributed Systems,Paxos,Patterns of Distributed Systems: Paxos source: martinfowler.com. “Quorum.” Accessed January 7, 2022. https://martinfowler.com/articles/patterns-of-distributed-systems/quorum.html. </description>
    </item>
    
    <item>
      <title>Patterns of Distributed Systems: Paxos</title>
      <link>https://notes.0081800.xyz/notes/20220107113056-patterns_of_distributed_systems_paxos/</link>
      <pubDate>Fri, 07 Jan 2022 11:30:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220107113056-patterns_of_distributed_systems_paxos/</guid>
      <description> tags: Paxos,分布式,Patterns of Distributed Systems source: martinfowler.com. “Paxos.” Accessed January 7, 2022. https://martinfowler.com/articles/patterns-of-distributed-systems/paxos.html. </description>
    </item>
    
    <item>
      <title>Career</title>
      <link>https://notes.0081800.xyz/notes/20220107110909-career/</link>
      <pubDate>Fri, 07 Jan 2022 11:09:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220107110909-career/</guid>
      <description></description>
    </item>
    
    <item>
      <title>How to quit like a boss</title>
      <link>https://notes.0081800.xyz/notes/20220107110859-how_to_quit_like_a_boss/</link>
      <pubDate>Fri, 07 Jan 2022 11:08:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220107110859-how_to_quit_like_a_boss/</guid>
      <description>tags: Career source: “How to Quit like a Boss.” Accessed January 7, 2022. https://jmsbrdy.com/blog/leaving-spring/. HN: https://news.ycombinator.com/item?id=29830296 From the article:
Avoid communication failures: your manager should not be surprised by your leaving.
Do have regular, clear, frank conversations about your career with your direct manager. Do tell your manager clearly if there’s something you’re looking for in your career which your current role isn’t providing. Don&amp;rsquo;t withhold concerns or aspirations from your manager.</description>
    </item>
    
    <item>
      <title>Crypto: the good, the bad and the ugly</title>
      <link>https://notes.0081800.xyz/notes/20220107103820-crypto_the_good_the_bad_and_the_ugly/</link>
      <pubDate>Fri, 07 Jan 2022 10:38:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220107103820-crypto_the_good_the_bad_and_the_ugly/</guid>
      <description>tags: Blockchain,Smart contracts,Web3 source: “Crypto: The Good, the Bad and the Ugly.” Accessed January 7, 2022. https://seldo.com/posts/crypto-the-good-the-bad-and-the-ugly. The good:
Smart contracts allows anybody to execute arbitrary code in the network. And use money to avoid abuse, as every action in the smart contract cost money(computing resource). Finaacial engineering: new money. Entertainment: NFT, a big dream(culture) for everybody who loves crypto. True cloud computing: Smart contracts again. Web3 The bad:</description>
    </item>
    
    <item>
      <title>Ethereum development</title>
      <link>https://notes.0081800.xyz/notes/20220107072021-ethereum_development/</link>
      <pubDate>Fri, 07 Jan 2022 07:20:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220107072021-ethereum_development/</guid>
      <description> tags: Ethereum </description>
    </item>
    
    <item>
      <title>Set up your local development environment</title>
      <link>https://notes.0081800.xyz/notes/20220107070826-set_up_your_local_development_environment/</link>
      <pubDate>Fri, 07 Jan 2022 07:08:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220107070826-set_up_your_local_development_environment/</guid>
      <description>tags: Smart contracts,Ethereum,Ethereum development source: ethereum.org. “Ethereum Local Development Setup.” Accessed January 7, 2022. https://ethereum.org. Local development node:
Use Hardhat to build the ethereum development environment.
And also there are some tools that based on Hardhat:
scaffold-eth: forkable Ethereum dev stack focused on fast product iterations Ganache: A tool for creating a local blockchain for fast Ethereum development.
Tools that based on Ganache:
Python based: brownie Testing tools:
Waffle: ethers.</description>
    </item>
    
    <item>
      <title>Ethereum: Deploying your first smart contract</title>
      <link>https://notes.0081800.xyz/notes/20220107070103-ethereum_deploying_your_first_smart_contract/</link>
      <pubDate>Fri, 07 Jan 2022 07:01:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220107070103-ethereum_deploying_your_first_smart_contract/</guid>
      <description> tags: Smart contracts,Ethereum,Ethereum development source: ethereum.org. “Deploying Your First Smart Contract.” Accessed January 7, 2022. https://ethereum.org. </description>
    </item>
    
    <item>
      <title>PoA</title>
      <link>https://notes.0081800.xyz/notes/20220107065931-poa/</link>
      <pubDate>Fri, 07 Jan 2022 06:59:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220107065931-poa/</guid>
      <description> tags: Blockchain Proof,Ethereum </description>
    </item>
    
    <item>
      <title>Wikipedia: Proof of authority</title>
      <link>https://notes.0081800.xyz/notes/20220107065917-wikipedia_proof_of_authority/</link>
      <pubDate>Fri, 07 Jan 2022 06:59:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220107065917-wikipedia_proof_of_authority/</guid>
      <description> tags: PoA source: https://en.wikipedia.org/wiki/Proof%5Fof%5Fauthority </description>
    </item>
    
    <item>
      <title>Comparison of Classical Test Theory and Item Response Theory and Their Applications to Test Development</title>
      <link>https://notes.0081800.xyz/notes/20220106173433-comparison_of_classical_test_theory_and_item_response_theory_and_their_applications_to_test_development/</link>
      <pubDate>Thu, 06 Jan 2022 17:34:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220106173433-comparison_of_classical_test_theory_and_item_response_theory_and_their_applications_to_test_development/</guid>
      <description> tags: IRT,CTT,Educational Measurement source: Hambleton, Ronald K, and Russell W Jones. “Comparison of Classical Test Theory and Item Response Theory and Their Applications to Test Development,” 1993, 11. </description>
    </item>
    
    <item>
      <title>CTT</title>
      <link>https://notes.0081800.xyz/notes/20220106173441-ctt/</link>
      <pubDate>Thu, 06 Jan 2022 17:34:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220106173441-ctt/</guid>
      <description> tags: Educational Measurement </description>
    </item>
    
    <item>
      <title>Educational</title>
      <link>https://notes.0081800.xyz/notes/20220106173353-educational/</link>
      <pubDate>Thu, 06 Jan 2022 17:33:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220106173353-educational/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Educational Measurement</title>
      <link>https://notes.0081800.xyz/notes/20220106173334-educational_measurement/</link>
      <pubDate>Thu, 06 Jan 2022 17:33:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220106173334-educational_measurement/</guid>
      <description> tags: Educational </description>
    </item>
    
    <item>
      <title>A Simple Guide to the Item Response Theory (IRT)</title>
      <link>https://notes.0081800.xyz/notes/20220106164610-a_simple_guide_to_the_item_response_theory_irt/</link>
      <pubDate>Thu, 06 Jan 2022 16:46:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220106164610-a_simple_guide_to_the_item_response_theory_irt/</guid>
      <description>tags: IRT,读书笔记 source: Yu, Chong Ho. “A Simple Guide to the Item Response Theory ( IRT ) and Rasch Modeling.” Accessed January 6, 2022. https://www.semanticscholar.org/paper/A-Simple-Guide-to-the-Item-Response-Theory-(-IRT-)-Yu/f42efb1bcf38f6650a8b16650e2811e8803cd4ec. IRT is about fitness or simplicity for test. There are two versions of IRT:
IRT - three parameters. Rasch modeling - one parameter only. Three parameters:
A - discrimination, how effectively this item can discriminate students&amp;rsquo;s proficient between highly and less. B - difficulty, or the threshold, tells us how easy or how difficult an item is.</description>
    </item>
    
    <item>
      <title>IRT</title>
      <link>https://notes.0081800.xyz/notes/20220106164620-irt/</link>
      <pubDate>Thu, 06 Jan 2022 16:46:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220106164620-irt/</guid>
      <description> tags: Algorithm,Bigdata,Educational Measurement </description>
    </item>
    
    <item>
      <title>How I took my SaaS from idea to sold in 14 months</title>
      <link>https://notes.0081800.xyz/notes/20220106121912-how_i_took_my_saas_from_idea_to_sold_in_14_months/</link>
      <pubDate>Thu, 06 Jan 2022 12:19:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220106121912-how_i_took_my_saas_from_idea_to_sold_in_14_months/</guid>
      <description>tags: Freelance source: “How I Took My SaaS from Idea to Sold in 14 Months | Masilotti.Com.” Accessed January 6, 2022. https://masilotti.com/idea-to-sold-in-14-months/. Building in public: teased new designs and features, documented decisions, UX with polls.</description>
    </item>
    
    <item>
      <title>Problems once solved by a metaclass can be solved by init_subclass</title>
      <link>https://notes.0081800.xyz/notes/20220106121656-problems_once_solved_by_a_metaclass_can_be_solved_by_init_subclass/</link>
      <pubDate>Thu, 06 Jan 2022 12:16:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220106121656-problems_once_solved_by_a_metaclass_can_be_solved_by_init_subclass/</guid>
      <description> tags: Python source: “init_subclass.” Accessed January 6, 2022. https://til.simonwillison.net/til/til/python_init-subclass.md. </description>
    </item>
    
    <item>
      <title>Rust Language Cheat Sheet</title>
      <link>https://notes.0081800.xyz/notes/20220105190301-rust_language_cheat_sheet/</link>
      <pubDate>Wed, 05 Jan 2022 19:03:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220105190301-rust_language_cheat_sheet/</guid>
      <description> tags: Rust,Online Tutorial source: https://cheats.rs/ </description>
    </item>
    
    <item>
      <title>Streaming</title>
      <link>https://notes.0081800.xyz/notes/20220105165615-streaming/</link>
      <pubDate>Wed, 05 Jan 2022 16:56:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220105165615-streaming/</guid>
      <description> tags: Bigdata </description>
    </item>
    
    <item>
      <title>Why local state is a fundamental primitive in stream processing</title>
      <link>https://notes.0081800.xyz/notes/20220105165604-why_local_state_is_a_fundamental_primitive_in_stream_processing/</link>
      <pubDate>Wed, 05 Jan 2022 16:56:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220105165604-why_local_state_is_a_fundamental_primitive_in_stream_processing/</guid>
      <description> tags: Bigdata,Streaming,Stateful Stream Processing source: Kreps, Jay. “Why Local State Is a Fundamental Primitive in Stream Processing - O’Reilly Radar.” Accessed January 5, 2022. http://radar.oreilly.com/2014/07/why-local-state-is-a-fundamental-primitive-in-stream-processing.html. Why
local state is much faster than a distribut database. local state can easily restore by some middleware like Kafka: by writing changes to a Kafka topic. </description>
    </item>
    
    <item>
      <title>Streaming 102: The world beyond batch</title>
      <link>https://notes.0081800.xyz/notes/20220105164146-streaming_102_the_world_beyond_batch/</link>
      <pubDate>Wed, 05 Jan 2022 16:41:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220105164146-streaming_102_the_world_beyond_batch/</guid>
      <description>tags: Bigdata,Flink,Dataflow Model,Streaming source: “Streaming 102: The World beyond Batch – O’Reilly.” Accessed January 5, 2022. https://www.oreilly.com/radar/the-world-beyond-batch-streaming-102/. Three more concepts:
Watermarks: Useful for event time windowing. All input data with event times less than watermark have been observed. Triggers: Signal for a window to produce output. Accumulation: The way to handle multiple results that are observed for the same window. Streaming 101 Redux What: Transformations Where: windowing Make a temporal boundary for a unbounded data source.</description>
    </item>
    
    <item>
      <title>Dataflow Model</title>
      <link>https://notes.0081800.xyz/notes/20220105163640-dataflow_model/</link>
      <pubDate>Wed, 05 Jan 2022 16:36:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220105163640-dataflow_model/</guid>
      <description> tags: Bigdata,Streaming source: Akidau, Tyler, Robert Bradshaw, Craig Chambers, Slava Chernyak, Rafael J. Fernández-Moctezuma, Reuven Lax, Sam McVeety, et al. “The Dataflow Model: A Practical Approach to Balancing Correctness, Latency, and Cost in Massive-Scale, Unbounded, out-of-Order Data Processing.” Proceedings of the VLDB Endowment 8, no. 12 (August 2015): 1792–1803. https://doi.org/10.14778/2824032.2824076. </description>
    </item>
    
    <item>
      <title>Streaming 101: The world beyond batch</title>
      <link>https://notes.0081800.xyz/notes/20220105163321-streaming_101_the_world_beyond_batch/</link>
      <pubDate>Wed, 05 Jan 2022 16:33:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220105163321-streaming_101_the_world_beyond_batch/</guid>
      <description>tags: Bigdata,Flink,Streaming source: Akidau, Tyler. “Streaming 101: The World beyond Batch.” O’Reilly Media, August 5, 2015. https://www.oreilly.com/radar/the-world-beyond-batch-streaming-101/. Streaming: a type of data processing engine that is designed with infinite data sets in mind. Other common uses of &amp;ldquo;streaming&amp;rdquo; that will be avoid in the rest of the post:
Unbounded data: A type of ever-growing, essentially infinite data set. Unbounded data processing: An ongoing mode of data processing, applied to the aforementioned type of unbounded data.</description>
    </item>
    
    <item>
      <title>DAOs, DACs, DAs and More: An Incomplete Terminology Guide</title>
      <link>https://notes.0081800.xyz/notes/20220105145433-daos_dacs_das_and_more_an_incomplete_terminology_guide/</link>
      <pubDate>Wed, 05 Jan 2022 14:54:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220105145433-daos_dacs_das_and_more_an_incomplete_terminology_guide/</guid>
      <description> tags: DAO,Web3 source: Foundation, Ethereum. “DAOs, DACs, DAs and More: An Incomplete Terminology Guide.” Accessed January 5, 2022. https://blog.ethereum.org/2014/05/06/daos-dacs-das-and-more-an-incomplete-terminology-guide/. </description>
    </item>
    
    <item>
      <title>Online Tutorial</title>
      <link>https://notes.0081800.xyz/notes/20220105144742-online_tutorial/</link>
      <pubDate>Wed, 05 Jan 2022 14:47:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220105144742-online_tutorial/</guid>
      <description></description>
    </item>
    
    <item>
      <title>DAO  Education: Level Up Your Knowledge of DAOs</title>
      <link>https://notes.0081800.xyz/notes/20220105144616-level_up_your_knowledge_of_daos/</link>
      <pubDate>Wed, 05 Jan 2022 14:46:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220105144616-level_up_your_knowledge_of_daos/</guid>
      <description> tags: DAO,Online Tutorial source: https://aragon.org/dao </description>
    </item>
    
    <item>
      <title>My writing finances, 2021</title>
      <link>https://notes.0081800.xyz/notes/20220105135009-my_writing_finances_2021/</link>
      <pubDate>Wed, 05 Jan 2022 13:50:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220105135009-my_writing_finances_2021/</guid>
      <description> tags: Freelance source: Dan. “My Writing Finances, 2021 | Dan Moren.” Accessed January 5, 2022. https://dmoren.com/2022/01/03/my-writing-finances-2021/. </description>
    </item>
    
    <item>
      <title>HN: I make $3K/mo from a browser extension!</title>
      <link>https://notes.0081800.xyz/notes/20220105134652-hn_i_make_3k_mo_from_a_browser_extension/</link>
      <pubDate>Wed, 05 Jan 2022 13:46:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220105134652-hn_i_make_3k_mo_from_a_browser_extension/</guid>
      <description> tags: Freelance source: “I Make $3K/Mo from a Browser Extension! (+ December 2021 Updates).” Accessed January 5, 2022. http://newsletter.tonydinh.com/issues/i-make-3k-mo-from-a-browser-extension-december-2021-updates-966892. HN: https://news.ycombinator.com/item?id=29803817 </description>
    </item>
    
    <item>
      <title>Web3/Crypto: Why Bother?</title>
      <link>https://notes.0081800.xyz/notes/20220105134324-web3_crypto_why_bother/</link>
      <pubDate>Wed, 05 Jan 2022 13:43:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220105134324-web3_crypto_why_bother/</guid>
      <description> tags: Web3 source: Continuations by Albert Wenger. “Web3/Crypto: Why Bother?” Accessed January 5, 2022. https://continuations.com/post/671863718643105792/web3crypto-why-bother. </description>
    </item>
    
    <item>
      <title>Skiff x Ethereum Naming Service</title>
      <link>https://notes.0081800.xyz/notes/20220105120811-skiff_x_ethereum_naming_service/</link>
      <pubDate>Wed, 05 Jan 2022 12:08:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220105120811-skiff_x_ethereum_naming_service/</guid>
      <description> tags: Ethereum,MetaMask,Online Tools source: https://www.skiff.org/updates/skiff-ens </description>
    </item>
    
    <item>
      <title>MetaMask</title>
      <link>https://notes.0081800.xyz/notes/20220105120401-metamask/</link>
      <pubDate>Wed, 05 Jan 2022 12:04:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220105120401-metamask/</guid>
      <description>tags: Web3,Online Tools,Real Problems That Web3 Solves, Part 1 source: https://metamask.io/ MetaMask has implemented private key login via a Chrome extension and now has 21 million users. In theory, something like this could have existed a long time ago. In practice, the existence of blockchains and the need for better UX for cryptocurrency incentivized much more investmenets in these tools.</description>
    </item>
    
    <item>
      <title>Real Problems That Web3 Solves, Part 1</title>
      <link>https://notes.0081800.xyz/notes/20220105114740-real_problems_that_web3_solves_part_1/</link>
      <pubDate>Wed, 05 Jan 2022 11:47:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220105114740-real_problems_that_web3_solves_part_1/</guid>
      <description>tags: Web3,Smart contracts source: Bill Prin’s Personal Page. “Real Problems That Web3 Solves, Part 1,” January 3, 2022. https://billprin.com/2022/01/03/real-problems-web3-solves.html. What exactly is the difference between Web3, blockchain, and cryptocurrency You can think of blockchain and cryptocurrency as technological implementation details, and Web3 as the communities, businesses, and social relationships that form on top of that technology. A similar analogy would be the original World Wide Web, which could have been construed as a rebrand of the underlying technologies of HTML over HTTP over TCP/IP.</description>
    </item>
    
    <item>
      <title>Smart contracts</title>
      <link>https://notes.0081800.xyz/notes/20220105113810-smart_contracts/</link>
      <pubDate>Wed, 05 Jan 2022 11:38:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220105113810-smart_contracts/</guid>
      <description>tags: Blockchain,Ethereum source: https://ethereum.org/en/developers/docs/smart-contracts/ A type of Ethereum account. Some code deployed and running in some VM, like Ethereum Virtual Machine.</description>
    </item>
    
    <item>
      <title>Decentralized autonomous organizations (DAOs)</title>
      <link>https://notes.0081800.xyz/notes/20220105112648-decentralized_autonomous_organizations_daos/</link>
      <pubDate>Wed, 05 Jan 2022 11:26:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220105112648-decentralized_autonomous_organizations_daos/</guid>
      <description>tags: Ethereum,Smart contracts,Blockchain,Web3 source: https://ethereum.org/en/dao/ Based on smart contracts and use tokens for voting. Tokens can be exchanged in the market.</description>
    </item>
    
    <item>
      <title>Neural Network From Scratch</title>
      <link>https://notes.0081800.xyz/notes/20220105105024-neural_network_from_scratch/</link>
      <pubDate>Wed, 05 Jan 2022 10:50:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220105105024-neural_network_from_scratch/</guid>
      <description> tags: AI,Deep Learning source: “Neural Network From Scratch.” Accessed January 5, 2022. https://sirupsen.com/napkin/neural-net. </description>
    </item>
    
    <item>
      <title>my personal note taking journey</title>
      <link>https://notes.0081800.xyz/notes/20220105104616-my_personal_note_taking_journey/</link>
      <pubDate>Wed, 05 Jan 2022 10:46:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220105104616-my_personal_note_taking_journey/</guid>
      <description> tags: Taking Notes,RoamResearch source: “My Personal Note Taking Journey.” Accessed January 5, 2022. https://phonetonote.com/blog/my-personal-note-taking-journey/. </description>
    </item>
    
    <item>
      <title>Zotero zotxt&#39;s api 500 as the specify style is not installed</title>
      <link>https://notes.0081800.xyz/notes/20220105090334-zotero_zotxt_500/</link>
      <pubDate>Wed, 05 Jan 2022 09:03:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220105090334-zotero_zotxt_500/</guid>
      <description>tags: Zotero,Emacs I got an error when I&amp;rsquo;m inserting Zotero ref to Emacs by M-x org-zotxt-insert-reference-link RET
[error] request--callback: peculiar error: 500 I got the error of zotxt by follow the instruction Debug Output Logging:
(5)(+0000003): HTTP/1.0 500 Internal Server Error X-Zotero-Version: 5.0.96.3 X-Zotero-Connector-API-Version: 2 Content-Type: text/plain; charset=UTF-8 csl is nullTypeError: csl is null buildBibliographyResponse/responseData&amp;lt;@resource://gre/modules/addons/XPIProvider.jsm -&amp;gt; jar:file:///Users/wanghui/Library/Application%20Support/Zotero/Profiles/34hkbjfm.default/extensions/zotxt@e6h.org.xpi!/bootstrap.js:220:9 buildBibliographyResponse@resource://gre/modules/addons/XPIProvider.jsm -&amp;gt; jar:file:///Users/wanghui/Library/Application%20Support/Zotero/Profiles/34hkbjfm.default/extensions/zotxt@e6h.org.xpi!/bootstrap.js:219:24 buildResponse/&amp;lt;@resource://gre/modules/addons/XPIProvider.jsm -&amp;gt; jar:file:///Users/wanghui/Library/Application%20Support/Zotero/Profiles/34hkbjfm.default/extensions/zotxt@e6h.org.xpi!/bootstrap.js:156:20 tryCatcher@resource://zotero/loader.jsm -&amp;gt; resource://zotero/bluebird/util.js:16:16 module.exports/Promise.prototype._settlePromiseFromHandler@resource://zotero/loader.jsm -&amp;gt; resource://zotero/bluebird/promise.js:547:13 module.</description>
    </item>
    
    <item>
      <title>Scientific Writing with Zotero and Org Mode</title>
      <link>https://notes.0081800.xyz/notes/20220105080634-scientific_writing_with_zotero_and_org_mode/</link>
      <pubDate>Wed, 05 Jan 2022 08:06:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220105080634-scientific_writing_with_zotero_and_org_mode/</guid>
      <description> tags: Org Mode,Taking Notes,Zotero,Research,Emacs source: “Scientific Writing with Zotero and Org Mode | Irreal.” Accessed January 5, 2022. https://irreal.org/blog/?p=5771. </description>
    </item>
    
    <item>
      <title>Research</title>
      <link>https://notes.0081800.xyz/notes/20220105065739-research/</link>
      <pubDate>Wed, 05 Jan 2022 06:57:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220105065739-research/</guid>
      <description></description>
    </item>
    
    <item>
      <title>A research workflow with Zotero and Org mode</title>
      <link>https://notes.0081800.xyz/notes/20220105065621-a_research_workflow_with_zotero_and_org_mode/</link>
      <pubDate>Wed, 05 Jan 2022 06:56:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220105065621-a_research_workflow_with_zotero_and_org_mode/</guid>
      <description>tags: Org Mode,Taking Notes,Zotero,Research,Emacs source: “A Research Workflow with Zotero and Org Mode | Mkbehr.Com.” Accessed January 5, 2022. http://www.mkbehr.com/posts/a-research-workflow-with-zotero-and-org-mode/. Gluing zotero and Org mode together with zotxt(zotxt-emacs).
Workflow:
Store papers into zotero by its browser plugin, that may also download the PDF. Create a page in Emacs and link to zotero via zotxt-emacs C-c &amp;quot; &amp;quot;. When I want to read the paper. Go to the page in Emacs and type C-c &amp;quot; a.</description>
    </item>
    
    <item>
      <title>Zotero</title>
      <link>https://notes.0081800.xyz/notes/20220105065640-zotero/</link>
      <pubDate>Wed, 05 Jan 2022 06:56:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220105065640-zotero/</guid>
      <description> tags: Tools,Learning,Taking Notes </description>
    </item>
    
    <item>
      <title>Deserializing JSON really fast</title>
      <link>https://notes.0081800.xyz/notes/20220104184242-deserializing_json_really_fast/</link>
      <pubDate>Tue, 04 Jan 2022 18:42:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104184242-deserializing_json_really_fast/</guid>
      <description> tags: Rust,优化,High Performance source: https://blog.datalust.co/deserializing-json-really-fast/ </description>
    </item>
    
    <item>
      <title>Database</title>
      <link>https://notes.0081800.xyz/notes/20220104184051-database/</link>
      <pubDate>Tue, 04 Jan 2022 18:40:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104184051-database/</guid>
      <description></description>
    </item>
    
    <item>
      <title>[译] RFC 1180：朴素 TCP/IP 教程（1991）</title>
      <link>https://notes.0081800.xyz/notes/20220104183852-%E8%AF%91_rfc_1180_%E6%9C%B4%E7%B4%A0_tcp_ip_%E6%95%99%E7%A8%8B_1991/</link>
      <pubDate>Tue, 04 Jan 2022 18:38:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104183852-%E8%AF%91_rfc_1180_%E6%9C%B4%E7%B4%A0_tcp_ip_%E6%95%99%E7%A8%8B_1991/</guid>
      <description> tags: TCP source: https://arthurchiao.art/blog/rfc1180-a-tcp-ip-tutorial-zh/ </description>
    </item>
    
    <item>
      <title>Assembly Nights</title>
      <link>https://notes.0081800.xyz/notes/20220104183330-assembly_nights/</link>
      <pubDate>Tue, 04 Jan 2022 18:33:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104183330-assembly_nights/</guid>
      <description> tags: Assembly,NASM Assembly Language Tutorials source: https://ratfactor.com/assembly-nights </description>
    </item>
    
    <item>
      <title>web3 is Centralized</title>
      <link>https://notes.0081800.xyz/notes/20220104183132-web3_is_centralized/</link>
      <pubDate>Tue, 04 Jan 2022 18:31:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104183132-web3_is_centralized/</guid>
      <description> tags: Web3 source: https://blog.wesleyac.com/posts/web3-centralized </description>
    </item>
    
    <item>
      <title>An Algorithm for Passing Programming Interviews</title>
      <link>https://notes.0081800.xyz/notes/20220104182458-an_algorithm_for_passing_programming_interviews/</link>
      <pubDate>Tue, 04 Jan 2022 18:24:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104182458-an_algorithm_for_passing_programming_interviews/</guid>
      <description> tags: Algorithm source: https://malisper.me/an-algorithm-for-passing-programming-interviews/ </description>
    </item>
    
    <item>
      <title>A not so gentle intro to web3</title>
      <link>https://notes.0081800.xyz/notes/20220104181901-a_not_so_gentle_intro_to_web3/</link>
      <pubDate>Tue, 04 Jan 2022 18:19:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104181901-a_not_so_gentle_intro_to_web3/</guid>
      <description> tags: Blockchain,Web3 source: https://www.kooslooijesteijn.net/blog/web3 </description>
    </item>
    
    <item>
      <title>Web3</title>
      <link>https://notes.0081800.xyz/notes/20220104181911-web3/</link>
      <pubDate>Tue, 04 Jan 2022 18:19:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104181911-web3/</guid>
      <description> tags: Blockchain </description>
    </item>
    
    <item>
      <title>Go Fuzzing</title>
      <link>https://notes.0081800.xyz/notes/20220104181647-go_fuzzing/</link>
      <pubDate>Tue, 04 Jan 2022 18:16:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104181647-go_fuzzing/</guid>
      <description> tags: Go source: https://tip.golang.org/doc/fuzz/ </description>
    </item>
    
    <item>
      <title>Bonsai offers freelance contracts, proposals, invoices</title>
      <link>https://notes.0081800.xyz/notes/20220104181343-bonsai_offers_freelance_contracts_proposals_invoices/</link>
      <pubDate>Tue, 04 Jan 2022 18:13:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104181343-bonsai_offers_freelance_contracts_proposals_invoices/</guid>
      <description> tags: Freelance source: https://www.hellobonsai.com/ HN: https://news.ycombinator.com/item?id=29782097 </description>
    </item>
    
    <item>
      <title>Assembly</title>
      <link>https://notes.0081800.xyz/notes/20220104180603-assembly/</link>
      <pubDate>Tue, 04 Jan 2022 18:06:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104180603-assembly/</guid>
      <description> tags: Computer Systems </description>
    </item>
    
    <item>
      <title>NASM Assembly Language Tutorials</title>
      <link>https://notes.0081800.xyz/notes/20220104180539-nasm_assembly_language_tutorials/</link>
      <pubDate>Tue, 04 Jan 2022 18:05:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104180539-nasm_assembly_language_tutorials/</guid>
      <description> tags: Computer Systems,Assembly,Linux,Online Tutorial source: “NASM Assembly Language Tutorials - Asmtutor.Com.” Accessed January 5, 2022. https://asmtutor.com/. </description>
    </item>
    
    <item>
      <title>Microstartup</title>
      <link>https://notes.0081800.xyz/notes/20220104175722-microstartup/</link>
      <pubDate>Tue, 04 Jan 2022 17:57:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104175722-microstartup/</guid>
      <description> tags: Freelance </description>
    </item>
    
    <item>
      <title>HN: My Microstartups make $500/day while I&#39;m sleeping</title>
      <link>https://notes.0081800.xyz/notes/20220104175332-hn_my_microstartups_make_500_day_while_i_m_sleeping/</link>
      <pubDate>Tue, 04 Jan 2022 17:53:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104175332-hn_my_microstartups_make_500_day_while_i_m_sleeping/</guid>
      <description>tags: Freelance,Microstartup source: https://news.ycombinator.com/item?id=29790964 Comments:
Related:
&amp;ldquo;Tell HN: My Microstartups make $500/day while I&amp;rsquo;m sleeping&amp;rdquo; (this): https://news.ycombinator.com/item?id=29790964
&amp;ldquo;AMA: I make $100K+ ARR from my microstartups&amp;rdquo; (3 months ago): https://news.ycombinator.com/item?id=28561132
&amp;ldquo;Show HN: I passed up an opportunity to make $200K from my microstartup&amp;rdquo; (2020): https://twitter.com/1HaKr/status/1301142901510995969
&amp;ldquo;Show HN: My Indie Hacker goal - Earn $100 a day to keep your desk job away&amp;rdquo; (2020): https://news.ycombinator.com/item?id=24304674
&amp;ldquo;Show HN: I made $9000 posting on Hacker News about my microstartup&amp;rdquo; (2020): https://news.</description>
    </item>
    
    <item>
      <title>Ledger, the first peer-reviewed journal dedicated to the study of blockchains and cryptocurrencies!</title>
      <link>https://notes.0081800.xyz/notes/20220104174944-ledger_the_first_peer_reviewed_journal_dedicated_to_the_study_of_blockchains_and_cryptocurrencies/</link>
      <pubDate>Tue, 04 Jan 2022 17:49:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104174944-ledger_the_first_peer_reviewed_journal_dedicated_to_the_study_of_blockchains_and_cryptocurrencies/</guid>
      <description> tags: Blockchain </description>
    </item>
    
    <item>
      <title>Privoxy socks5 to HTTP</title>
      <link>https://notes.0081800.xyz/notes/20220104163050-privoxy_socks5_to_http/</link>
      <pubDate>Tue, 04 Jan 2022 16:30:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104163050-privoxy_socks5_to_http/</guid>
      <description> tags: Privoxy,Over the Wall source: https://wiki.archlinux.org/title/Privoxy%5F(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E8%BD%AC%E5%8F%91%E5%8D%8F%E8%AE%AE </description>
    </item>
    
    <item>
      <title>Privoxy</title>
      <link>https://notes.0081800.xyz/notes/20220104162722-privoxy/</link>
      <pubDate>Tue, 04 Jan 2022 16:27:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104162722-privoxy/</guid>
      <description> tags: Tools,Unix home: https://www.privoxy.org/ </description>
    </item>
    
    <item>
      <title>Tools</title>
      <link>https://notes.0081800.xyz/notes/20220104162549-tools/</link>
      <pubDate>Tue, 04 Jan 2022 16:25:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104162549-tools/</guid>
      <description></description>
    </item>
    
    <item>
      <title>HTTPs</title>
      <link>https://notes.0081800.xyz/notes/20220104162448-https/</link>
      <pubDate>Tue, 04 Jan 2022 16:24:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104162448-https/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Beam</title>
      <link>https://notes.0081800.xyz/notes/20220104150531-beam/</link>
      <pubDate>Tue, 04 Jan 2022 15:05:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104150531-beam/</guid>
      <description> tags: Bigdata source: https://beam.apache.org/ </description>
    </item>
    
    <item>
      <title>Flink: Keyed State</title>
      <link>https://notes.0081800.xyz/notes/20220104120927-flink_keyed_state/</link>
      <pubDate>Tue, 04 Jan 2022 12:09:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104120927-flink_keyed_state/</guid>
      <description>tags: Flink State Snapshots source: https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/concepts/stateful-stream-processing/#keyed-state Keyed state is maintained in what can be thought of as an embedded key/value store.</description>
    </item>
    
    <item>
      <title>Flink: Exactly Once Guarantees</title>
      <link>https://notes.0081800.xyz/notes/20220104113644-flink_exactly_once_guarantees/</link>
      <pubDate>Tue, 04 Jan 2022 11:36:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104113644-flink_exactly_once_guarantees/</guid>
      <description>tags: Flink State Snapshots,Fault Tolerance via State Snapshots source: https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/learn-flink/fault%5Ftolerance/#exactly-once-guarantees Depending on the choices you make, Flink possiable outcomes:
Flink makes no effort to recover from failures (at most once) Nothing is lost, but you may experience duplicated results (at least once) Nothing is lost or duplicated (exactly once) Given that Flink recovers from faults by rewinding and replaying the source data streams, when the ideal situation is described as exactly once this does not mean that every event will be processed exactly once.</description>
    </item>
    
    <item>
      <title>Wikipedia: Chandy–Lamport algorithm</title>
      <link>https://notes.0081800.xyz/notes/20220104112626-wikipedia_chandy_lamport_algorithm/</link>
      <pubDate>Tue, 04 Jan 2022 11:26:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104112626-wikipedia_chandy_lamport_algorithm/</guid>
      <description> tags: 分布式 source: https://en.wikipedia.org/wiki/Chandy%E2%80%93Lamport%5Falgorithm </description>
    </item>
    
    <item>
      <title>Flink: How does State Snapshotting Work?</title>
      <link>https://notes.0081800.xyz/notes/20220104112527-flink_how_does_state_snapshotting_work/</link>
      <pubDate>Tue, 04 Jan 2022 11:25:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104112527-flink_how_does_state_snapshotting_work/</guid>
      <description>tags: Fault Tolerance via State Snapshots,Flink State Snapshots,Wikipedia: Chandy–Lamport algorithm source: https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/learn-flink/fault%5Ftolerance/#how-does-state-snapshotting-work Workflow:
Checkpoint coordinator (part of the job manager) instructs a task manager to begin a checkpoint.
Insert numbered checkpoint barriers into their streams of all the sources record their offsets.
checkpoint barriers flow through the job graph, indicating the part of the stream before and after each checkpoint.
Checkpoint n will contain the state of each operator that resulted from having consumed every event before checkpoint barrier n, and none of the events after it.</description>
    </item>
    
    <item>
      <title>Flink Checkpoint</title>
      <link>https://notes.0081800.xyz/notes/20220104112356-flink_checkpoint/</link>
      <pubDate>Tue, 04 Jan 2022 11:23:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104112356-flink_checkpoint/</guid>
      <description>tags: Flink State Snapshots,Fault Tolerance via State Snapshots a snapshot taken automatically by Flink for the purpose of being able to recover from faults. Checkpoints can be incremental, and are optimized for being restored quickly.</description>
    </item>
    
    <item>
      <title>Flink Savepoint</title>
      <link>https://notes.0081800.xyz/notes/20220104112301-flink_savepoint/</link>
      <pubDate>Tue, 04 Jan 2022 11:23:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104112301-flink_savepoint/</guid>
      <description>tags: Flink State Snapshots a snapshot triggered manually by a user (or an API call) for some operational purpose, such as a stateful redeploy/upgrade/rescaling operation. Savepoints are always complete, and are optimized for operational flexibility.</description>
    </item>
    
    <item>
      <title>Flink Checkpoint Storage</title>
      <link>https://notes.0081800.xyz/notes/20220104111922-flink_checkpoint_storage/</link>
      <pubDate>Tue, 04 Jan 2022 11:19:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104111922-flink_checkpoint_storage/</guid>
      <description> tags: Flink State Snapshots,Fault Tolerance via State Snapshots,Flink Checkpoint source: https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/learn-flink/fault%5Ftolerance/#checkpoint-storage Flink periodically takes persistent snapshots of all the state in every operator and copies these snapshots somewhere more durable, such as a distributed file system. In the event of the failure, Flink can restore the complete state of your application and resume processing as though nothing had gone wrong.
Two implementations:
A distributed file system. JobManager’s heap. </description>
    </item>
    
    <item>
      <title>State Backends</title>
      <link>https://notes.0081800.xyz/notes/20220104111432-state_backends/</link>
      <pubDate>Tue, 04 Jan 2022 11:14:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104111432-state_backends/</guid>
      <description>tags: Flink State Snapshots,Fault Tolerance via State Snapshots,Stateful Stream Processing Two implementations of state backends are available:
RocksDB An embedded key/value store keeps its working state on disk.
Overhead Accesses and updates involve serialization and deserialization.
Java heap-based state backend Keeps its working state in memory, on the Java heap.
Risk Large amount state will cause OOM.
Conclusion Both of these state backends are able to do asynchronous snapshotting, meaning that they can take a snapshot without impeding the ongoing stream processing.</description>
    </item>
    
    <item>
      <title>Fault Tolerance via State Snapshots</title>
      <link>https://notes.0081800.xyz/notes/20220104111325-fault_tolerance_via_state_snapshots/</link>
      <pubDate>Tue, 04 Jan 2022 11:13:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104111325-fault_tolerance_via_state_snapshots/</guid>
      <description> tags: Flink State Snapshots,Stateful Stream Processing source: https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/learn-flink/fault%5Ftolerance/ </description>
    </item>
    
    <item>
      <title>Flink State Snapshots</title>
      <link>https://notes.0081800.xyz/notes/20220104111119-flink_state_snapshots/</link>
      <pubDate>Tue, 04 Jan 2022 11:11:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104111119-flink_state_snapshots/</guid>
      <description> tags: Stateful Stream Processing </description>
    </item>
    
    <item>
      <title>Stateful Stream Processing</title>
      <link>https://notes.0081800.xyz/notes/20220104105853-stateful_stream_processing/</link>
      <pubDate>Tue, 04 Jan 2022 10:58:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104105853-stateful_stream_processing/</guid>
      <description>tags: Stream processing,Flink source: https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/learn-flink/overview/#stateful-stream-processing https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/concepts/stateful-stream-processing/ This means that how one event is handled can depend on the accumulated effect of all the events that came before it.
How the stateful streaming processing works on a distributed cluster? The set of parallel instances of a stateful operator is effectively a sharded key-value store. Each parallel instance is responsible for handling events for a specific group of keys, and the state for those keys is kept locally.</description>
    </item>
    
    <item>
      <title>Timely Stream Processing</title>
      <link>https://notes.0081800.xyz/notes/20220104105829-timely_stream_processing/</link>
      <pubDate>Tue, 04 Jan 2022 10:58:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104105829-timely_stream_processing/</guid>
      <description>tags: Stream processing,Flink source: https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/learn-flink/overview/#timely-stream-processing Flink timely stream processing support by using event timestamps that are recorded in data stream, rather than using the clocks of the machines processing the data.</description>
    </item>
    
    <item>
      <title>Flink Redistributing</title>
      <link>https://notes.0081800.xyz/notes/20220104105758-flink_redistributing/</link>
      <pubDate>Tue, 04 Jan 2022 10:57:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104105758-flink_redistributing/</guid>
      <description>tags: Flink Parallel Dataflows Redistributing streams (as between map() and keyBy/window above, as well as between keyBy/window and Sink) change the partitioning of streams. Each operator subtask sends data to different target subtasks, depending on the selected transformation. Examples are keyBy() (which re-partitions by hashing the key), broadcast(), or rebalance() (which re-partitions randomly). In a redistributing exchange the ordering among the elements is only preserved within each pair of sending and receiving subtasks (for example, subtask[1] of map() and subtask[2] of keyBy/window).</description>
    </item>
    
    <item>
      <title>One-to-one</title>
      <link>https://notes.0081800.xyz/notes/20220104105704-one_to_one/</link>
      <pubDate>Tue, 04 Jan 2022 10:57:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104105704-one_to_one/</guid>
      <description>tags: Flink Parallel Dataflows One-to-one streams (for example between the Source and the map() operators in the figure above) preserve the partitioning and ordering of the elements. That means that subtask[1] of the map() operator will see the same elements in the same order as they were produced by subtask[1] of the Source operator.</description>
    </item>
    
    <item>
      <title>Flink Parallel Dataflows</title>
      <link>https://notes.0081800.xyz/notes/20220104105628-flink_parallel_dataflows/</link>
      <pubDate>Tue, 04 Jan 2022 10:56:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104105628-flink_parallel_dataflows/</guid>
      <description>tags: Flink Streams can transport data between two operators in a one-to-one (or forwarding) pattern, or in a redistributing pattern:</description>
    </item>
    
    <item>
      <title>Stream processing</title>
      <link>https://notes.0081800.xyz/notes/20220104105119-stream_processing/</link>
      <pubDate>Tue, 04 Jan 2022 10:51:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104105119-stream_processing/</guid>
      <description>tags: Flink Stream processing, on the other hand, involves unbounded data streams. Conceptually, at least, the input may never end, and so you are forced to continuously process the data as it arrives.</description>
    </item>
    
    <item>
      <title>Batch processing</title>
      <link>https://notes.0081800.xyz/notes/20220104105030-batch_processing/</link>
      <pubDate>Tue, 04 Jan 2022 10:50:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104105030-batch_processing/</guid>
      <description>tags: Spark Batch processing is the paradigm at work when you process a bounded data stream. In this mode of operation you can choose to ingest the entire dataset before producing any results, which means that it is possible, for example, to sort the data, compute global statistics, or produce a final report that summarizes all of the input.</description>
    </item>
    
    <item>
      <title>Flink实时计算-深入理解 Checkpoint和Savepoint</title>
      <link>https://notes.0081800.xyz/notes/20220104104436-flink%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97_%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3_checkpoint%E5%92%8Csavepoint/</link>
      <pubDate>Tue, 04 Jan 2022 10:44:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104104436-flink%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97_%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3_checkpoint%E5%92%8Csavepoint/</guid>
      <description></description>
    </item>
    
    <item>
      <title>知乎：Flink实时计算-深入理解 Checkpoint和Savepoint</title>
      <link>https://notes.0081800.xyz/notes/20220104104450-%E7%9F%A5%E4%B9%8E_flink%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97_%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3_checkpoint%E5%92%8Csavepoint/</link>
      <pubDate>Tue, 04 Jan 2022 10:44:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104104450-%E7%9F%A5%E4%B9%8E_flink%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97_%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3_checkpoint%E5%92%8Csavepoint/</guid>
      <description> tags: Flink,Flink State Snapshots,Flink Checkpoint,Flink Savepoint source: https://zhuanlan.zhihu.com/p/79526638 </description>
    </item>
    
    <item>
      <title>GitHub: 像小说一样品读 Linux 0.11 核心代码</title>
      <link>https://notes.0081800.xyz/notes/20220104104331-github_%E5%83%8F%E5%B0%8F%E8%AF%B4%E4%B8%80%E6%A0%B7%E5%93%81%E8%AF%BB_linux_0_11_%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Tue, 04 Jan 2022 10:43:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104104331-github_%E5%83%8F%E5%B0%8F%E8%AF%B4%E4%B8%80%E6%A0%B7%E5%93%81%E8%AF%BB_linux_0_11_%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81/</guid>
      <description> tags: Linux source: https://github.com/sunym1993/flash-linux0.11-talk </description>
    </item>
    
    <item>
      <title>Audio: The lost talks from Linus Torvalds at DECUS&#39;94</title>
      <link>https://notes.0081800.xyz/notes/20220104104134-audio_the_lost_talks_from_linus_torvalds_at_decus_94/</link>
      <pubDate>Tue, 04 Jan 2022 10:41:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104104134-audio_the_lost_talks_from_linus_torvalds_at_decus_94/</guid>
      <description> tags: Linux source: https://archive.org/details/199405-decusnew-orleans/1994050DECUSNewOrleansLinuxImplementationIssuesInLinux.ogg </description>
    </item>
    
    <item>
      <title>Linux</title>
      <link>https://notes.0081800.xyz/notes/20220104103936-linux/</link>
      <pubDate>Tue, 04 Jan 2022 10:39:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104103936-linux/</guid>
      <description> tags: Operating system </description>
    </item>
    
    <item>
      <title>Ethereum: Shard chains</title>
      <link>https://notes.0081800.xyz/notes/20220104083051-ethereum_shard_chains/</link>
      <pubDate>Tue, 04 Jan 2022 08:30:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104083051-ethereum_shard_chains/</guid>
      <description>tags: Ethereum,Proof-of-stake source: https://ethereum.org/en/eth2/shard-chains/ Sharding is the process of splitting a database horizontally to spread the load – it’s a common concept in computer science. In an Ethereum context, sharding will reduce network congestion and increase transactions per second by creating new chains, known as “shards”.
This is important for reasons other than scalability.</description>
    </item>
    
    <item>
      <title>Ethereum: The Beacon Chain</title>
      <link>https://notes.0081800.xyz/notes/20220104082350-ethereum_the_beacon_chain/</link>
      <pubDate>Tue, 04 Jan 2022 08:23:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104082350-ethereum_the_beacon_chain/</guid>
      <description>tags: Ethereum,Proof-of-stake source: https://ethereum.org/en/eth2/beacon-chain/ Extra coordination for the Ethereum: Shard chains.
The beacon chain receives state information from shards and makes it available for other shards, allowing the network to stay in sync. The beacon chain will also manage the validators from registering their stake deposits to issuing their rewards and penalties.</description>
    </item>
    
    <item>
      <title>How does Ethereum&#39;s proof-of-stake work?</title>
      <link>https://notes.0081800.xyz/notes/20220104082123-how_does_ehtereum_s_proof_of_stake_work/</link>
      <pubDate>Tue, 04 Jan 2022 08:21:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104082123-how_does_ehtereum_s_proof_of_stake_work/</guid>
      <description>tags: Ethereum,Proof-of-stake source: https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/#how-does-pos-work When you submit a transaction on a shard, a validator will be responsible for adding your transaction to a shard block. Validators are algorithmically chosen by Ethereum: The Beacon Chain to propose new blocks.
Attestation
If a validator isn&amp;rsquo;t chosen to propose a new shard block, they&amp;rsquo;ll have to attest to another validator&amp;rsquo;s proposal and confirm that everything looks as it should. It&amp;rsquo;s the attestation that is recorded in the beacon chain rather than the transaction itself.</description>
    </item>
    
    <item>
      <title>ETH</title>
      <link>https://notes.0081800.xyz/notes/20220104081524-eth/</link>
      <pubDate>Tue, 04 Jan 2022 08:15:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104081524-eth/</guid>
      <description> tags: Ethereum </description>
    </item>
    
    <item>
      <title>Proof-of-history</title>
      <link>https://notes.0081800.xyz/notes/20220104081314-proof_of_history/</link>
      <pubDate>Tue, 04 Jan 2022 08:13:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104081314-proof_of_history/</guid>
      <description>tags: Blockchain Proof,Solana,Proof-of-stake Solana is a Proof of Stake network. This short phrase - &amp;ldquo;Proof of Stake&amp;rdquo; - represents a much larger concept with considerable complexity behind it, and even more so for Solana, which adds the unique properties of Proof of History to the mix to enable fast, low-latency transactions while still maintaining censorship resistance.</description>
    </item>
    
    <item>
      <title>Proof-of-stake</title>
      <link>https://notes.0081800.xyz/notes/20220104071052-proof_of_stake/</link>
      <pubDate>Tue, 04 Jan 2022 07:10:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104071052-proof_of_stake/</guid>
      <description>tags: Blockchain,Blockchain Proof,Ethereum,Solana source: https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/ Proof workflow:
Users stake money(ETH) to become a validator.
Validators are chosen at random to create blocks and are responsible for checking and confirming blocks they don&amp;rsquo;t create.
user&amp;rsquo;s stake is also used as a way to incentivise good validator behavior. For example, a user can lose a portion of their stake for things like going offline (failing to validate) or their entire stake for deliberate collusion.</description>
    </item>
    
    <item>
      <title>Proof-of-work</title>
      <link>https://notes.0081800.xyz/notes/20220104070857-proof_of_work/</link>
      <pubDate>Tue, 04 Jan 2022 07:08:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104070857-proof_of_work/</guid>
      <description>tags: Blockchain Proof,Blockchain,Ethereum source: https://ethereum.org/en/developers/docs/consensus-mechanisms/pow/ Wikipedia: https://en.wikipedia.org/wiki/Proof%5Fof%5Fwork A key feature of proof-of-work schemes is their asymmetry: the work – the computation – must be moderately hard (yet feasible) on the prover or requester side but easy to check for the verifier or service provider.
With a hash function, let&amp;rsquo;s say SHA-1. For example, to do PoW, we need to generate a SHA-1 hash of the given data that must begins 52 binary zeros, that is 13 hexadecimal zeros:</description>
    </item>
    
    <item>
      <title>Blockchain Proof</title>
      <link>https://notes.0081800.xyz/notes/20220104070749-blockchain_proof/</link>
      <pubDate>Tue, 04 Jan 2022 07:07:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104070749-blockchain_proof/</guid>
      <description> tags: Blockchain </description>
    </item>
    
    <item>
      <title>Shinobi Systems&#39; Solana Proof of Stake &#43; Proof of History Primer</title>
      <link>https://notes.0081800.xyz/notes/20220104070408-shinobi_systems_solana_proof_of_stake_proof_of_history_primer/</link>
      <pubDate>Tue, 04 Jan 2022 07:04:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220104070408-shinobi_systems_solana_proof_of_stake_proof_of_history_primer/</guid>
      <description> tags: Blockchain,Solana,Proof-of-stake,Proof-of-history source: “Shinobi Systems’ Solana Proof of Stake + Proof of History Primer.” Accessed January 5, 2022. https://www.shinobi-systems.com/primer.html. </description>
    </item>
    
    <item>
      <title>Blockchain Demo</title>
      <link>https://notes.0081800.xyz/notes/20220103082057-blockchain_demo/</link>
      <pubDate>Mon, 03 Jan 2022 08:20:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220103082057-blockchain_demo/</guid>
      <description> tags: Video: Blockchain 101 - A Visual Demo，区块链, Online Tools source: https://andersbrownworth.com/blockchain/hash </description>
    </item>
    
    <item>
      <title>Video: Blockchain 101 - A Visual Demo</title>
      <link>https://notes.0081800.xyz/notes/20220103081929-video_blockchain_101_a_visual_demo/</link>
      <pubDate>Mon, 03 Jan 2022 08:19:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220103081929-video_blockchain_101_a_visual_demo/</guid>
      <description>tags: 区块链 source: https://youtu.be/%5F160oMzblY8 It&amp;rsquo;s like Git but not support merge. The progress of changing blocks like git rebase.</description>
    </item>
    
    <item>
      <title>C/C&#43;&#43; 多态</title>
      <link>https://notes.0081800.xyz/notes/20220102074500-c_c_%E5%A4%9A%E6%80%81/</link>
      <pubDate>Sun, 02 Jan 2022 07:45:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220102074500-c_c_%E5%A4%9A%E6%80%81/</guid>
      <description>tags: C/C++ 只能通过抽象类的指针或引用调用动态解析子类函数，虚函数表示需要动态解析，纯虚函数必须被子类覆盖，否则无法实例化。</description>
    </item>
    
    <item>
      <title>JavaScript</title>
      <link>https://notes.0081800.xyz/notes/20220102073737-javascript/</link>
      <pubDate>Sun, 02 Jan 2022 07:37:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220102073737-javascript/</guid>
      <description> tags: Programming Language </description>
    </item>
    
    <item>
      <title>Swift</title>
      <link>https://notes.0081800.xyz/notes/20220102073640-swift/</link>
      <pubDate>Sun, 02 Jan 2022 07:36:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220102073640-swift/</guid>
      <description> tags: Programming Language </description>
    </item>
    
    <item>
      <title>《深入理解计算机系统》读书笔记</title>
      <link>https://notes.0081800.xyz/notes/20220102072835-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 02 Jan 2022 07:28:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220102072835-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description> tags: Computer Systems,读书笔记 </description>
    </item>
    
    <item>
      <title>SO: What is the difference between iter and into_iter?</title>
      <link>https://notes.0081800.xyz/notes/20220101082142-so_what_is_the_difference_between_iter_and_into_iter/</link>
      <pubDate>Sat, 01 Jan 2022 08:21:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220101082142-so_what_is_the_difference_between_iter_and_into_iter/</guid>
      <description> tags: Rust source: https://stackoverflow.com/a/34745885/2873718 </description>
    </item>
    
    <item>
      <title>GitHub: Rust Memory Container Cheat-sheet</title>
      <link>https://notes.0081800.xyz/notes/20220101082045-github_rust_memory_container_cheat_sheet/</link>
      <pubDate>Sat, 01 Jan 2022 08:20:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220101082045-github_rust_memory_container_cheat_sheet/</guid>
      <description> tags: Rust Wrapper Types,Rust source: Rust Memory Container Cheat-sheet </description>
    </item>
    
    <item>
      <title>Wrapper Types in Rust: Choosing Your Guarantees</title>
      <link>https://notes.0081800.xyz/notes/20220101081950-wrapper_types_in_rust_choosing_your_guarantees/</link>
      <pubDate>Sat, 01 Jan 2022 08:19:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220101081950-wrapper_types_in_rust_choosing_your_guarantees/</guid>
      <description> tags: Rust,Rust Wrapper Types source: https://manishearth.github.io/blog/2015/05/27/wrapper-types-in-rust-choosing-your-guarantees/ </description>
    </item>
    
    <item>
      <title>GitHub: Internal details of Tokio from code to designs</title>
      <link>https://notes.0081800.xyz/notes/20220101081722-github_internal_details_of_tokio_from_code_to_designs/</link>
      <pubDate>Sat, 01 Jan 2022 08:17:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220101081722-github_internal_details_of_tokio_from_code_to_designs/</guid>
      <description> tags: Tokio source: https://github.com/tony612/tokio-internals </description>
    </item>
    
    <item>
      <title>PAPER: Raft</title>
      <link>https://notes.0081800.xyz/notes/20220101080713-paper_raft/</link>
      <pubDate>Sat, 01 Jan 2022 08:07:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220101080713-paper_raft/</guid>
      <description> tags: Raft source: https://web.stanford.edu/~ouster/cgi-bin/papers/OngaroPhD.pdf </description>
    </item>
    
    <item>
      <title>PAPER: Time, Clocks, and the Ordering of Events in a Distributed System</title>
      <link>https://notes.0081800.xyz/notes/20220101080622-paper_time_clocks_and_the_ordering_of_events_in_a_distributed_system/</link>
      <pubDate>Sat, 01 Jan 2022 08:06:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220101080622-paper_time_clocks_and_the_ordering_of_events_in_a_distributed_system/</guid>
      <description> tags: 分布式,一致性 source: https://lamport.azurewebsites.net/pubs/time-clocks.pdf </description>
    </item>
    
    <item>
      <title>CSDN:  理解这两点，也就理解了paxos协议的精髓</title>
      <link>https://notes.0081800.xyz/notes/20220101080340-csdn_%E7%90%86%E8%A7%A3%E8%BF%99%E4%B8%A4%E7%82%B9_%E4%B9%9F%E5%B0%B1%E7%90%86%E8%A7%A3%E4%BA%86paxos%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%B2%BE%E9%AB%93/</link>
      <pubDate>Sat, 01 Jan 2022 08:03:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220101080340-csdn_%E7%90%86%E8%A7%A3%E8%BF%99%E4%B8%A4%E7%82%B9_%E4%B9%9F%E5%B0%B1%E7%90%86%E8%A7%A3%E4%BA%86paxos%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%B2%BE%E9%AB%93/</guid>
      <description> tags: Paxos source: https://blog.csdn.net/qq%5F35440678/article/details/78080431 </description>
    </item>
    
    <item>
      <title>GitHub: raft-rs</title>
      <link>https://notes.0081800.xyz/notes/20220101080223-github_raft_rs/</link>
      <pubDate>Sat, 01 Jan 2022 08:02:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220101080223-github_raft_rs/</guid>
      <description> tags: Rust,Raft source: https://github.com/tikv/raft-rs </description>
    </item>
    
    <item>
      <title>Raft Understandable Distributed Consensus</title>
      <link>https://notes.0081800.xyz/notes/20220101080054-raft_understandable_distributed_consensus/</link>
      <pubDate>Sat, 01 Jan 2022 08:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220101080054-raft_understandable_distributed_consensus/</guid>
      <description> tags: Raft,分布式，分布式共识，Online Tools source: http://thesecretlivesofdata.com/raft/ </description>
    </item>
    
    <item>
      <title>Distributed consensus (blockchain) simulation and visualization</title>
      <link>https://notes.0081800.xyz/notes/20220101075156-distributed_consensus_blockchain_simulation_and_visualization/</link>
      <pubDate>Sat, 01 Jan 2022 07:51:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20220101075156-distributed_consensus_blockchain_simulation_and_visualization/</guid>
      <description> tags: 分布式共识,Online Tools,区块链 source: https://web3scout.github.io/forcecons-sim/ </description>
    </item>
    
    <item>
      <title>Org-roam export backlinks on Hugo</title>
      <link>https://notes.0081800.xyz/notes/20211231142642-org_roam_export_backlinks_on_hugo/</link>
      <pubDate>Fri, 31 Dec 2021 14:26:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20211231142642-org_roam_export_backlinks_on_hugo/</guid>
      <description>tags: org-roam, Org Mode source: https://seds.nl/notes/org%5Froam%5Fexport%5Fbacklinks%5Fon%5Fhugo/ https://seds.nl/notes/export%5Forg%5Froam%5Fbacklinks%5Fwith%5Fgohugo/ 利用 hugo 的 partial template layouts/partials/backlinks.html
{{ $re := $.File.BaseFileName }} {{ $backlinks := slice }} {{ range .Site.AllPages }} {{ if and (findRE $re .RawContent) (not (eq $re .File.BaseFileName)) }} {{ $backlinks = $backlinks | append . }} {{ end }} {{ end }} &amp;lt;hr&amp;gt; {{ if gt (len $backlinks) 0 }} &amp;lt;div class=&amp;#34;bl-section&amp;#34;&amp;gt; &amp;lt;h4&amp;gt;Links to this note&amp;lt;/h4&amp;gt; &amp;lt;div class=&amp;#34;backlinks&amp;#34;&amp;gt; &amp;lt;ul&amp;gt; {{ range $backlinks }} &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;{{ .</description>
    </item>
    
    <item>
      <title>Online Tools</title>
      <link>https://notes.0081800.xyz/notes/20211231123329-online_tools/</link>
      <pubDate>Fri, 31 Dec 2021 12:33:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20211231123329-online_tools/</guid>
      <description> tags: Tools </description>
    </item>
    
    <item>
      <title>RoamResearch</title>
      <link>https://notes.0081800.xyz/notes/20211231123253-roamresearch/</link>
      <pubDate>Fri, 31 Dec 2021 12:32:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20211231123253-roamresearch/</guid>
      <description> tags: Taking Notes,Online Tools </description>
    </item>
    
    <item>
      <title>Roam: Why I Love It and How I Use It</title>
      <link>https://notes.0081800.xyz/notes/20211231122919-roam_why_i_love_it_and_how_i_use_it/</link>
      <pubDate>Fri, 31 Dec 2021 12:29:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20211231122919-roam_why_i_love_it_and_how_i_use_it/</guid>
      <description> tags: Learning,Taking Notes source: https://www.nateliason.com/blog/roam </description>
    </item>
    
    <item>
      <title>How To Take Smart Notes: 10 Principles to Revolutionize Your Note-Taking and Writing</title>
      <link>https://notes.0081800.xyz/notes/20211231122658-how_to_take_smart_notes_10_principles_to_revolutionize_your_note_taking_and_writing/</link>
      <pubDate>Fri, 31 Dec 2021 12:26:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20211231122658-how_to_take_smart_notes_10_principles_to_revolutionize_your_note_taking_and_writing/</guid>
      <description>tags: Learning,Taking Notes,RoamResearch source: https://fortelabs.co/blog/how-to-take-smart-notes/ Luhmann’s slip-box: build second brain context &amp;ndash; its network of associations, relationships, and connections to other information.
But Luhmann often remarked that he never forced himself to do anything he didn’t feel like doing: “I only do what is easy. I only write when I immediately know how to do it. If I falter for a moment, I put the matter aside and do something else” (Luhmann et al.</description>
    </item>
    
    <item>
      <title>How To Take Smart Notes With Org-mode</title>
      <link>https://notes.0081800.xyz/notes/20211231122318-how_to_take_smart_notes_with_org_mode/</link>
      <pubDate>Fri, 31 Dec 2021 12:23:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20211231122318-how_to_take_smart_notes_with_org_mode/</guid>
      <description>tags: Learning,Taking Notes,org-roam,Org Mode source: https://blog.jethro.dev/posts/how%5Fto%5Ftake%5Fsmart%5Fnotes%5Forg/ Notes aren’t a record of my thinking process. They are my thinking process. – Richard Feynman
The primary purpose of note-taking should not be for storing ideas, but for developing them. When we take notes, we should ask: “In what context do I want to see this note again?”
Note-taking for writing:
Find topic/research question Research/find literature Read and take notes Draw conclusions / outline text Write Two types of notes:</description>
    </item>
    
    <item>
      <title>Learning</title>
      <link>https://notes.0081800.xyz/notes/20211231122121-learning/</link>
      <pubDate>Fri, 31 Dec 2021 12:21:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20211231122121-learning/</guid>
      <description></description>
    </item>
    
    <item>
      <title>读书笔记</title>
      <link>https://notes.0081800.xyz/notes/20211210181234-%E8%AF%BB%E8%BF%87%E7%9A%84%E4%B9%A6/</link>
      <pubDate>Fri, 10 Dec 2021 18:12:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20211210181234-%E8%AF%BB%E8%BF%87%E7%9A%84%E4%B9%A6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>加解密</title>
      <link>https://notes.0081800.xyz/notes/20211009104957-%E5%8A%A0%E8%A7%A3%E5%AF%86/</link>
      <pubDate>Sat, 09 Oct 2021 10:49:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20211009104957-%E5%8A%A0%E8%A7%A3%E5%AF%86/</guid>
      <description>证书 [译] 写给工程师：关于证书（certificate）和公钥基础设施（PKI）的一切（SmallStep, 2018）</description>
    </item>
    
    <item>
      <title>英语读音规则</title>
      <link>https://notes.0081800.xyz/notes/20210925202345-%E8%8B%B1%E8%AF%AD%E8%AF%BB%E9%9F%B3%E8%A7%84%E5%88%99/</link>
      <pubDate>Sat, 25 Sep 2021 20:23:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210925202345-%E8%8B%B1%E8%AF%AD%E8%AF%BB%E9%9F%B3%E8%A7%84%E5%88%99/</guid>
      <description> tags: Learning English 一般现在时第三人称单音形规则 一般过去时音形规则 </description>
    </item>
    
    <item>
      <title>英语词法</title>
      <link>https://notes.0081800.xyz/notes/20210921092250-%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B3%95/</link>
      <pubDate>Tue, 21 Sep 2021 09:22:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210921092250-%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B3%95/</guid>
      <description>tags: Learning English 比较级 形容词/副词比较级 常规单音节词 -er fast -&amp;gt; faster small -&amp;gt; smaller nice -&amp;gt; nicer large -&amp;gt; larger（删除词尾不发音的 e） -y -&amp;gt; -ier busy -&amp;gt; busier pretty -&amp;gt; prettier 短元音 + 辅音：重写辅音 -er big -&amp;gt; bigger hot -&amp;gt; hotter 多音节： more + diffcult -&amp;gt; more difficult interesting -&amp;gt; more interesting careful /kɛəful/ -&amp;gt; more careful -y 二音节词（-ly副词除外）：常不加 more busy -&amp;gt; busier pretty -&amp;gt; prettier quickly -&amp;gt; more quickly 特殊 much/many -&amp;gt; more little -&amp;gt; less good/well -&amp;gt; better bad -&amp;gt; worse 代词比较级 more less 比较级修饰 a little/ a bit + 比较级 更&amp;hellip;一点 much / a lot / far + 比较级 更&amp;hellip;得多 英语常见词用法 open/close 静态和动态 open When do you open(v.</description>
    </item>
    
    <item>
      <title>流利英语</title>
      <link>https://notes.0081800.xyz/notes/20210921091537-%E6%B5%81%E5%88%A9%E8%8B%B1%E8%AF%AD/</link>
      <pubDate>Tue, 21 Sep 2021 09:15:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210921091537-%E6%B5%81%E5%88%A9%E8%8B%B1%E8%AF%AD/</guid>
      <description>tags: Learning English 连读 变音 /d/ + /j/ = /dʒj/ Woul~d y~ou like to try int on? /t/ + /j/ = /tʃj/ What abou~t you~? 词尾辅音 + 词首元音 I~t i~s A glas~s o~f water 还原 r RP
he~r i~deas Whe~re is i~t? 语块切割 Chunking 语块（Chunk） 能表达实际含义且语义不割裂的词串。
语块切割（Chunking） 根据说话节奏将句子自然切割为若干语块。
语块语连读 同一语块内能连则连。
吞音 基本原则 同一语块内，音同则吞。
示例 Excuse me, Coul~d you~ tell me how I can get to Pret A Monger?
get to -&amp;gt; geto</description>
    </item>
    
    <item>
      <title>英语习语</title>
      <link>https://notes.0081800.xyz/notes/20210920081734-%E8%8B%B1%E8%AF%AD%E4%B9%A0%E8%AF%AD/</link>
      <pubDate>Mon, 20 Sep 2021 08:17:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210920081734-%E8%8B%B1%E8%AF%AD%E4%B9%A0%E8%AF%AD/</guid>
      <description>tags: Learning English Give me a hand come in 有 come in all/different colors/size come on 「随意」鼓动、鼓励、催促 come to 总计 Excuse me 抱歉/引起注意 by the way/BTW 顺便说一下 shame on sb.! sb. 可耻 make it 成功达成 do/try one&amp;rsquo;s best (to do sth.) 尽最大努力做某事 sure thing no problem.
礼貌请求 礼貌程度 please &amp;gt; please 疑问句 &amp;gt; 肯定句 could &amp;gt; would &amp;gt; can 示例：
Show me (please) Can you show me? Can you show me please?</description>
    </item>
    
    <item>
      <title>英语语法结构</title>
      <link>https://notes.0081800.xyz/notes/20210920081114-%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 20 Sep 2021 08:11:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210920081114-%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84/</guid>
      <description>tags: Learning English 双宾语 例句：I want to buy a birthday gift for my sister. 结构：buy sth. for sb. 双宾语：by sb. sth. buy my sister a birthday gift. Can I buy a drink for you? Can I buy you a drink? 双宾语限制 第二个宾语必须为名词，不能是人称代词（pron.）。
下面语句不能使用双宾语
I want to buy you it.(X)
双宾语动词 bring/give/tell/sell/ask/show Bring it to me Bring me a present. Give it to me Give me the pen. tell the story to me tell me the story email the photo to me email me the photo sell the handbag to her sell her the handbag ask sb.</description>
    </item>
    
    <item>
      <title>英语常用词</title>
      <link>https://notes.0081800.xyz/notes/20210920075833-%E8%8B%B1%E8%AF%AD%E5%B8%B8%E7%94%A8%E8%AF%8D/</link>
      <pubDate>Mon, 20 Sep 2021 07:58:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210920075833-%E8%8B%B1%E8%AF%AD%E5%B8%B8%E7%94%A8%E8%AF%8D/</guid>
      <description> tags: Learning English seem 表示似乎 It seems to be very popular nowdays. 用作委婉 背景：the man in the photo。 对比以下两句
He is in good health He seems to be in good health(这句是错的 He seems in good health) 表示犹豫 That&amp;rsquo;s not right That doesn&amp;rsquo;t seem right That doesn&amp;rsquo;t seem to be right </description>
    </item>
    
    <item>
      <title>英语短语</title>
      <link>https://notes.0081800.xyz/notes/20210920075417-%E8%8B%B1%E8%AF%AD%E7%9F%AD%E8%AF%AD/</link>
      <pubDate>Mon, 20 Sep 2021 07:54:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210920075417-%E8%8B%B1%E8%AF%AD%E7%9F%AD%E8%AF%AD/</guid>
      <description>tags: Learning English shape ʃeip be in great/good shape stay/keep in (good) shape 英语表示次数范围 five times a month once two weeks 英语表示尺码 loose /luːs/ 松的 tight /tait/ 紧的 what/how about 提议 What/How about some coffee? What/How about you? 穿衣：try on/take off/put on n.: try on sth I&amp;rsquo;d like to try on the shoes. pron.: try sth. on I&amp;rsquo;d like to try them on. think of 认为 sth. 怎么样 What do you think of my new shirt?</description>
    </item>
    
    <item>
      <title>英语词性</title>
      <link>https://notes.0081800.xyz/notes/20210920073442-%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%80%A7/</link>
      <pubDate>Mon, 20 Sep 2021 07:34:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210920073442-%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%80%A7/</guid>
      <description>tags: Learning English 副词 adv/adverb 是指在句子中表示行为或状态特征的词，用以修饰动词、形容词、其他副词或全句，表示时间、地点、程度、方式等概念。 副词可分为：时间副词、频率副词、地点副词、方式副词、程度副词、疑问副词、连接副词、关系副词、表顺序的副词以及表完成的副词。
频率副词 always usually often sometimes about 表示大约大约修饰数量。
形容词 adj 形容词后缀 -ful helpful useful thankful 形容词后缀 -ed interested excited 形容词后缀 -ing interesting exciting 动词 verb 情态动词 modal verb.
can(could)/may(might)/must/need/to/shall(should)/will(would).
动名词 形式 v.-ing 动词的名词化。
语法：名词 语意：动词
形变规则 特殊 1 -e：去 e 加 ing live -&amp;gt; living give -&amp;gt; giving 特殊 2 短元音 + 一辅音：重复最后一个字母加 ing jog -&amp;gt; jogging swim -&amp;gt; swimming 常规：直接加 ing do -&amp;gt; doing study -&amp;gt; studying 词性 I usually go swimming.</description>
    </item>
    
    <item>
      <title>英语时态</title>
      <link>https://notes.0081800.xyz/notes/20210920073034-%E8%8B%B1%E8%AF%AD%E6%97%B6%E6%80%81/</link>
      <pubDate>Mon, 20 Sep 2021 07:30:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210920073034-%E8%8B%B1%E8%AF%AD%E6%97%B6%E6%80%81/</guid>
      <description>tags: Learning English 通过动词变化来区分时间 通过动词变化来区分时间。
I am walking in the rain. 正在 I will walk in the rain. 将要 I walk in the rain sometings. 一般状态、重复、常态 一般现在时 表示：
当前的一般状态
重复或习惯动作
am/is/are（be 动词）：是，处于某状态
do/does（实意动词）：具体动作
(X): am/is/are + do/des 一般现在时不能 am/is/are 跟动词实意动词
一般现在时第三人称单音形规则 tags: 英语读音规则 一般现在时第三人称单数动词需要变形，需要注意变形后的读音
清对清 /s/ works helps 非清则浊 /z/ lives sees goes does /dʌz/ 组合 /dz/ /ts/ meets needs 近似音 -es /iz/ introduces fishes 现在进行时 当前正在发生的事情或动作，表示当前正在发生或者近将来。
I&amp;rsquo;m looking for a shirt.</description>
    </item>
    
    <item>
      <title>Linux kernel</title>
      <link>https://notes.0081800.xyz/notes/20210907142848-linux_kernel/</link>
      <pubDate>Tue, 07 Sep 2021 14:28:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210907142848-linux_kernel/</guid>
      <description>tags: Linux Linux I/O Linux I/O 演进 阻塞式：read()/write() 非阻塞式：select()/poll()/epoll()，不支持文件 I/O Thread Pool Direct I/O（数据软件）：绕过 page cache 异步 IO（Linux AIO）：早起进支持文件 I/O，近期支持了 epoll 支持非文件 I/O Linux io_uring [译] Linux 异步 I/O 框架 io_uring：基本原理、程序示例与性能压测 对比 Linux AIO：
重新设计实现真正的是不。 支持任何类型的 I/O：cached files、direct-access files 甚至 blocking sockets。 灵活、可扩展：基于 io_uring 能够重写 Linux 的每个系统调用。 原理及核心数据结构：SQ/CQ/SQE/CQE 每个 io_uring 实例都有两个环形队列，在内核和应用程序之间共享：
提交队列：submission queue（SQ） 完成队列：completion queue（CQ） 这两个队列：
都是单生产者、单消费者，size 是 2 的幂次； 提供无锁接口（lock-less access interface），内部使用内存屏障做同步（coordinated with memory barrers）。 使用方式：
请求 应用创建 SQ entries（SQE），更新 SQ tail； 内核消费 SQE，更新 SQ head 完成 内核为完成一个或多个请求创建 CQ enries（CQE），更新 CQ tail； 应用消费 CQE，更新 CQ head 完成事件（completion events）可能以任意顺序到达，到总是与特定的 SQE 相关联的。 消费 CQE 过程无需切换到内核态 带来的好处 支持批处理 支持文件 I/O 系统调用：read、write、send、recv、accept、opentat、stat、专用的一些系统调用，如 fallocate 不再局限于数据库应用 应对现在硬件架构：将硬件架构本身作为一个网络（多核多 CPU 是一个基础网络、CPU 之间是一个网络、CPU 和磁盘 I/O 之间又是一个网络） 三种工作模式 中断驱动模式（interrupt driven）：默认模式。可通过 io_uring_enter() 提交 I/O 请求，然后直接检查 CQ 状态判断是否完成。</description>
    </item>
    
    <item>
      <title>Scala lsp-metals</title>
      <link>https://notes.0081800.xyz/notes/20210906151915-scala_lsp_metals/</link>
      <pubDate>Mon, 06 Sep 2021 15:19:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210906151915-scala_lsp_metals/</guid>
      <description> tags: Emacs,LSP 如果无法正常补全三方库，应该是 bloop 服务没有正常启动：
创建 ~/Library/Caches/org.scalameta.metals/bsp.trace.json 开启跟踪 查看项目目录下 metals.log </description>
    </item>
    
    <item>
      <title>领域模式</title>
      <link>https://notes.0081800.xyz/notes/20210903080049-%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 03 Sep 2021 08:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210903080049-%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%BC%8F/</guid>
      <description>tags: DDD,《领域驱动设计》读书笔记 领域基础模式 模式：UBIQUITOUS LANGUAGE 在同领域专家、开发人员和项目管理沟通的过程中建立并使用 UBIQUITOUS LANGUAGE，，并在模型实现时依然使用 UBIQUITOUS LANGUAGE 来让设计与沟通相一致（中文语境下稍显困难），UBIQUITOUS LANGUAGE 让知识消化后直接驱动变更模型。
应用 UBIQUITOUS LANGUAGE 需要大声的建模。
模式：MODEL-DRIVEN DESIGN 严格按照模型来编写代码，让模型与实际系统相结合。 不再分离「分析模型」和程序设计，而是寻求一种能够满足这两方面需求的单一模型。 工具：面向对象编程语言、UML等。 更好的支持 UBIQUITOUS LANGUAGE. 模式：HANDS-ON MODELER 开发设计和模型设计紧密合作，避免模型设计者不参与编写和程序设计者不参与模型设计。 每一个开发人员都必须不同程度的参与模型讨论并且与领域专家保持联系，模型设计者及时通过 UBIQUITOUS LANGUAGE 与接触代码的人及时交换关于模型的想法。 领域模式构造块 模式：LAYERED ARCHITECTURE 分层架构是实现 DDD 的基础，分层架构将不同的层次的实现分开，自上倒下应分为：
用户界面层 应用层 领域层（模型的精髓） 基础设施层 核心在于要将领域层单独出来实现 MODEL-DRIVEN DESIGN，对业务进行建模封装业务规则。调用规则也只能自上而下的调用，不能反向调用。
领域层（或模型层）分离出来之后使得模型足够丰富，结构足够清晰，可以捕捉到基本的业务知识，并有效的使用这些知识。
模式：ENTITY 用于跟踪对象的状态，有唯一标识符，在系统中是可变的，两个对象是否一个通过唯一标识来判断，不是靠它们的属性定义。
模式：VALUE OBJECT 区别与 ENTITY ，没有唯一标识，仅记录状态，一般设计为不可变用于共享 VALUE OBJECT，两个对象是否一个通过对象属性的值来判断。
模式：SERVICE 没有状态，但又需要建模的对象，只包含动作。用于一些不适合建模为对象的领域概念。
与领域概念相关的操作不是 ENTITY 或 VALUE OBJECT 的一个自然组成部署 接口是根据领域模型的其他元素定义的。 操作是无状态的 模式：MODULE（或 PACKAGE） 根据对象的意义划分领域模型，低耦合高内聚。按照模式或者对象生命周期或者其他方式划分都是错误的。
模式：AGGREGATE 划分模型边界，统一对关联模型的创建、修改、复制和销毁。一般选定一个 ENTITY 对象作为 AGGREGATE 的「根」，同时对事务应用一组规则：</description>
    </item>
    
    <item>
      <title>Airflow</title>
      <link>https://notes.0081800.xyz/notes/20210902153221-airflow/</link>
      <pubDate>Thu, 02 Sep 2021 15:32:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210902153221-airflow/</guid>
      <description>案例 Airflow powers AI。
Airflow SSO 接入 公司 SSO 系统不是基于开源标准，而是一套自定义的方式，目前网上没有成熟的解决方案，通过查看 Flask-AppBuilder 和 Airflow 的代码发现可以扩展 flask_appbuilder.security.views.AuthRemoteUserView 并通过自定义的 SecurityManager 指定 authremoteuserview 来实现，去掉具体 SSO 逻辑后的代码如下：
from urllib.parse import urlencode from urllib.parse import urljoin import requests from flask import flash from flask import redirect from flask import request from flask_appbuilder.baseviews import expose from flask_appbuilder.security.views import AuthRemoteUserView try: from airflow.www.security import AirflowSecurityManager except ImportError: AirflowSecurityManager = None __version__ = &amp;#34;0.1.0&amp;#34; AUTHORIZE_URL = &amp;#34;https://example.com/sso/login&amp;#34; ACCESS_TOKEN_URL = &amp;#34;https://example.</description>
    </item>
    
    <item>
      <title>Spark</title>
      <link>https://notes.0081800.xyz/notes/20210827080540-spark/</link>
      <pubDate>Fri, 27 Aug 2021 08:05:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210827080540-spark/</guid>
      <description>tags: Bigdata Spark 编程语言选择 毋庸置疑，Python 应该是最简单也是大部分的选择，但是如果有依赖那么将要付出额外的心智负担（Spark 管理 Python 依赖）。 JVM 语言的依赖组织方式则具有天然的优势，可以将依赖（排除 Spark 生态之后）都 bundle 进 Jar 包里。 其中 Scala 兼具简单和 JVM 的优势，但是它「不流行」。
Spark Driver &amp;amp; Executor Driver 执行 spark-commit 客户端，创建 SparkContext 执行 main 函数。 Executor Spark Worker 上的线程 See also:
Understanding the working of Spark Driver and Executor Cluster Mode Overview Spark 代码执行 我在配置 Spark 的时候就在好奇，从观察上看部分代码应该是执行在 Driver 上部分代码会执行在 Executer，这让我很好奇。 但是我通过学习 Spark RDD 学习到了一些知识。
以下代码是在 Executor 上执行的：
Transformations 和 Actions 是执行在 Spark 集群的。 传递给 Transformations 和 Actions 的闭包函数也是执行在 Spark 集群上的。 其他额外的代码都是执行在 Driver 上的，所以想要在 Driver 打印日志需要上使用 collect：</description>
    </item>
    
    <item>
      <title>Scala</title>
      <link>https://notes.0081800.xyz/notes/20210827073626-scala/</link>
      <pubDate>Fri, 27 Aug 2021 07:36:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210827073626-scala/</guid>
      <description>tags: Programming Language Scala 学习资源 Scala Book Scala 这么好的语言为什么不流行 HN：Scala 为什么不流行 Reddit：Scala 为什么不流行 结论：Java 人才更多且成本更低。
Scala 工具 sbt sbt new 无法处理替换过的 SSH 会导致 Auth fail，一个 workaround 就是手动 clone 项目然后：
sbt new file:///path/to/template.g8 sbt 国内加速 ~/.sbt/repositories:
[repositories] local nexus-aliyun:https://maven.aliyun.com/nexus/content/groups/public nexus-aliyun-ivy:https://maven.aliyun.com/nexus/content/groups/public/, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext] typesafe: https://repo.typesafe.com/typesafe/ivy-releases/, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext], bootOnly Unique Scala Rust from Scala Rust 和 Scala 有很多想通的地方，Rust 应该从 Scala 借鉴了很多：
可变量和不可变量 模式匹配 Trait 内置类型 val b: Byte = 1 val x: Int = 1 val l: Long = 1 val s: Short = 1 val d: Double = 2.</description>
    </item>
    
    <item>
      <title>SVG 绘制工具</title>
      <link>https://notes.0081800.xyz/notes/20210825081520-svg_%E7%BB%98%E5%88%B6%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Wed, 25 Aug 2021 08:15:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210825081520-svg_%E7%BB%98%E5%88%B6%E5%B7%A5%E5%85%B7/</guid>
      <description> https://inkscape.org/ </description>
    </item>
    
    <item>
      <title>设计</title>
      <link>https://notes.0081800.xyz/notes/20210825081459-%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Wed, 25 Aug 2021 08:14:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210825081459-%E8%AE%BE%E8%AE%A1/</guid>
      <description>SVG SVG 绘制工具</description>
    </item>
    
    <item>
      <title>Graphviz</title>
      <link>https://notes.0081800.xyz/notes/20210824065326-graphviz/</link>
      <pubDate>Tue, 24 Aug 2021 06:53:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210824065326-graphviz/</guid>
      <description>Graphviz 教程 https://www2.eecs.berkeley.edu/Pubs/TechRpts/2013/EECS-2013-176.pdf Graphviz Examples https://graphviz.org/gallery/ Graphviz 绘制思维导图 Graphviz Online Tools 一个手绘风格的在线绘图工具：https://sketchviz.com/new Gaphviz Playground：http://magjac.com/graphviz-visual-editor/ </description>
    </item>
    
    <item>
      <title>LeetCode: 98. Validate Binary Search Tree</title>
      <link>https://notes.0081800.xyz/notes/20210818070934-leetcode_98_validate_binary_search_tree/</link>
      <pubDate>Wed, 18 Aug 2021 07:09:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210818070934-leetcode_98_validate_binary_search_tree/</guid>
      <description>tags: LeetCode https://leetcode.com/problems/validate-binary-search-tree/
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isValidBST(TreeNode* root) { if (root == nullptr || (root-&amp;gt;left == nullptr &amp;amp;&amp;amp; root-&amp;gt;right == nullptr)) { return true; } if (root-&amp;gt;left !</description>
    </item>
    
    <item>
      <title>LeetCode: 113. Path Sum II</title>
      <link>https://notes.0081800.xyz/notes/20210816083017-leetcode_113_path_sum_ii/</link>
      <pubDate>Mon, 16 Aug 2021 08:30:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210816083017-leetcode_113_path_sum_ii/</guid>
      <description>tags: LeetCode,backtracking https://leetcode.com/problems/path-sum-ii/
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; pathSum(TreeNode* root, int targetSum) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; r; if (root == nullptr) { return r; } if (root-&amp;gt;left !</description>
    </item>
    
    <item>
      <title>LeetCode: 112. Path Sum</title>
      <link>https://notes.0081800.xyz/notes/20210816074540-leetcode_112_path_sum/</link>
      <pubDate>Mon, 16 Aug 2021 07:45:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210816074540-leetcode_112_path_sum/</guid>
      <description>tags: LeetCode https://leetcode.com/problems/path-sum/
递归版
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool hasPathSum(TreeNode* root, int targetSum) { if (root == nullptr) { return false; } return pathSum(root, 0, targetSum); } bool pathSum(TreeNode* node, int sum, int targetSum) { sum += node-&amp;gt;val; if (node-&amp;gt;left == nullptr &amp;amp;&amp;amp; node-&amp;gt;right == nullptr) { if (sum == targetSum) { return true; } } if (node-&amp;gt;left !</description>
    </item>
    
    <item>
      <title>LeetCode: 79. Word Search</title>
      <link>https://notes.0081800.xyz/notes/20210815081516-leetcode_79_word_search/</link>
      <pubDate>Sun, 15 Aug 2021 08:15:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210815081516-leetcode_79_word_search/</guid>
      <description>tags: LeetCode 79. Word Search
class Solution { public: bool exist(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board, string word) { backtracking(board, word, 0, 0); return res; } private: string track; bool res = false; enum Direction { right, down, up, left, }; /** * @param dir: 0: right, 1: down, 2: up, 3: left */ void backtracking(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board, string word, int row, int col) { if (track == word || res) { res = true; return; } for (int i = row; i &amp;lt; board.</description>
    </item>
    
    <item>
      <title>Event Store</title>
      <link>https://notes.0081800.xyz/notes/20210814072447-event_store/</link>
      <pubDate>Sat, 14 Aug 2021 07:24:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210814072447-event_store/</guid>
      <description></description>
    </item>
    
    <item>
      <title>领域驱动设计</title>
      <link>https://notes.0081800.xyz/notes/20210814071825-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Sat, 14 Aug 2021 07:18:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210814071825-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</guid>
      <description> 《领域驱动设计》读书笔记 </description>
    </item>
    
    <item>
      <title>High Performance Browser Networking</title>
      <link>https://notes.0081800.xyz/notes/20210813080226-high_performance_browser_networking/</link>
      <pubDate>Fri, 13 Aug 2021 08:02:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210813080226-high_performance_browser_networking/</guid>
      <description>tags: 计划读的书,HTTP,High Performance,Network 在线： https://hpbn.co/ source: Grigorik, Ilya. High-Performance Browser Networking. Beijing ; Sebastopol, CA: O’Reilly, 2013. “Good developers know how things work. Great developers know why things work.”</description>
    </item>
    
    <item>
      <title>预写日志</title>
      <link>https://notes.0081800.xyz/notes/20210813074328-%E9%A2%84%E5%86%99%E6%97%A5%E5%BF%97/</link>
      <pubDate>Fri, 13 Aug 2021 07:43:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210813074328-%E9%A2%84%E5%86%99%E6%97%A5%E5%BF%97/</guid>
      <description>预写日志（write-ahead log，WAL），也称为重做日志。
一个仅支持追加修改的文件，每个 B-tree 的修改必须先更新 WAL 然后再修改数本身的页。 当数据库在崩溃后恢复时，该日志用于将 B-tree 恢复到最近一致的状态。</description>
    </item>
    
    <item>
      <title>RabbitMQ</title>
      <link>https://notes.0081800.xyz/notes/20210813073438-rabbitmq/</link>
      <pubDate>Fri, 13 Aug 2021 07:34:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210813073438-rabbitmq/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Twitter DistributedLog</title>
      <link>https://notes.0081800.xyz/notes/20210813073412-twitter_distributedlog/</link>
      <pubDate>Fri, 13 Aug 2021 07:34:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210813073412-twitter_distributedlog/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Amazon Kinesis Streams</title>
      <link>https://notes.0081800.xyz/notes/20210813073357-amazon_kinesis_streams/</link>
      <pubDate>Fri, 13 Aug 2021 07:33:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210813073357-amazon_kinesis_streams/</guid>
      <description></description>
    </item>
    
    <item>
      <title>消息队列</title>
      <link>https://notes.0081800.xyz/notes/20210813072847-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link>
      <pubDate>Fri, 13 Aug 2021 07:28:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210813072847-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid>
      <description>AMQP/JMS 风格的消息代理 将单个消息分配给消费者，消费者在成功处理后确认每条消息。消息被确认后从代理中删除。 适合作为一种异步 RPC。
RabbitMQ ActiveMQ HornetQ Qpid TIBCO Enterprise MEssage Service IBM MQ Azure Service Bus Google Cloud Pub/Sub 多个消费者 负载均衡式 每一条消息都只被传递给其中一个消费者。
扇出式 每条消息都被传递给所有消费者。
确认和重新传递 为了确保消息不会丢失，消息代理使用确认：客户端必须在处理完消息后显式的告诉代理，以便代理可以将其从队列中移除。
如果客户端的连接关闭或超时，而代理没有收到确认，则认为消息未处理，因此它将消息重新传递给另一个消费者。
消息顺序性 即使消息代理试图保留消息顺序（标准要求），负载均衡与重新传递的组合也不可避免地导致消息被重新排序。
基于日志的消息代理 代理将分区中的所有消息分配给相同的消费者节点，并始终以相同的顺序发送消息。 通过分区机制来实现并行（写在多个磁盘上突破磁盘带宽），消费者通过检查他们处理的最后一条消息的偏移量来跟踪进度。 代理将消息保存在磁盘上，因此如果有必要，可以回退并重新读取旧消息。 代表性的有：
Kafka Amazon Kinesis Streams Twitter DistributedLog 基于日志的消息存储 参照 LSM-Tree 和 B-tree 的 WAL，可以使用相同的结构来实现消息代理： 生产者通过将消息追加到日志的末尾来发送消息，消费者通过依次读取日志来接收消息。 如果消费者读到日志的末尾，它就开始等待新消息被追加的通知。
通过对日志进行分区突破单个磁盘所能体能的带宽吞吐上线。
代理为每个消息分区分配了一个单调递增的序列号或偏移量，保证了分区内的消息完全有序。
消费者偏移量：记录哪些消息已经被处理，减少 ACK 开销 磁盘空间：分段，定期删除 消费者跟不上生产者：增加 LAG 报警 重新处理消息：重置偏移量 </description>
    </item>
    
    <item>
      <title>Networking 101: Building Blocks of TCP</title>
      <link>https://notes.0081800.xyz/notes/20210813071739-networking_101_building_blocks_of_tcp/</link>
      <pubDate>Fri, 13 Aug 2021 07:17:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210813071739-networking_101_building_blocks_of_tcp/</guid>
      <description>tags: TCP,High Performance Browser Networking 原文链接：https://hpbn.co/building-blocks-of-tcp/。 Overview The 4th version of RFC 675, and final two seperate RFCs:
RFC 791 - Internet Protocol(IPv4) RFC 793 - Transmission Control Protocol TCP provides:
Effective abstraction. A reliable network running over unreliable channel. Hiding most the complexity of network communication: retransmission of lost data, in-order delivery, congestion control and avoidance, data integrity, and more. Three-Way Handhsake Sequence numbers are important for keep in-order delivery, and they are picked randomly from both sides for security reasons.</description>
    </item>
    
    <item>
      <title>TCP</title>
      <link>https://notes.0081800.xyz/notes/20210813071635-tcp/</link>
      <pubDate>Fri, 13 Aug 2021 07:16:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210813071635-tcp/</guid>
      <description> tags: Network </description>
    </item>
    
    <item>
      <title>背压</title>
      <link>https://notes.0081800.xyz/notes/20210813071452-%E8%83%8C%E5%8E%8B/</link>
      <pubDate>Fri, 13 Aug 2021 07:14:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210813071452-%E8%83%8C%E5%8E%8B/</guid>
      <description>阻止生产者发送更多的消息。使用背压的场景：
Unix 管道 TCP </description>
    </item>
    
    <item>
      <title>流处理系统</title>
      <link>https://notes.0081800.xyz/notes/20210813065446-%E6%B5%81%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Fri, 13 Aug 2021 06:54:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210813065446-%E6%B5%81%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F/</guid>
      <description>发送事件流 消息系统 生产者速度比消费者快：丢弃消息、将消息缓存在队列、激活背压。 节点崩溃或者暂时历险，是否会有消息丢失？ 生产者与消息系统之间的直接消息传递 UDP 组播：广泛应用于金融股票 无代理消息库：ZerroMQ 和 nanomsg StatsD 和 Brubeck 使用 UDP 传递消息 HTTP、RPC 接口 消息代理 参见：AMQP/JMS 风格的消息代理。 也称消息队列。
消息对比与数据库对比 多个消费者 确认和重传机制 分区日志 参见： 基于日志的消息代理。
数据库与流 保持系统同步 变更数据捕获 变更数据捕获（Change Data Capture，CDC）记录了写入数据库的所有更改，并以可复制到其他系统的形式来提取数据。 如果在写入时立即将更改作为一种流来发布，那么 CDC 就更有趣来。
实现变更数据捕获 解析复制日志，并将解析的内容发送到事件流中进行 replay。
初始快照 replay 日志占用空间过大，需要进行截断，截断之前的进行初始快照保存。
日志压缩 参考哈希索引。
对变更流的 API 支持 数据库开始支持将变更流作为标准接口。
事件溯源 一种在领域驱动设计社区中开发的技术，与 CDC 最大的区别在于事件溯源在不同抽象层次上应用了将所有对应用程序状态的更改保存为更改事件日志：
CDC 中：应用程序以数据可变方式来操纵数据库，从数据库中提取较低级的变更日志，从而确保从数据库提取写入顺序与实际写入顺序相匹配。写入数据库的程序不需要知道 CDC 正在发生。 事件溯源中：应用程序的写入逻辑是基于写入事件日志的不可变事件构建的。事件存储仅支持追加，不鼓励甚至禁止更新或删除操作。事件旨在反映在应用程序级别所发生的事情，而不是低级别的状态改变。 专门的数据库 Event Store 来支持使用事件溯源的应用程序。
从事件中导出当前状态：真正对用户有意义 命令和事件 命令经过校验后转化为事件。
状态，流与不可变性 流处理 事件中的数据写入数据库、缓存、搜索索引或类似的存储系统，提供给客户端查询。 通过某种方式将事件推送给用户，如电子邮件、短信等。 处理一个或多个输入流产生过一个或多个输出流。 流处理适用场景 复杂事件处理 复杂事件处理（Complex Event Processing，CEP）尤其适用需要搜索特定的事件模式。 实现：Esper、IBM Info Sphere Streams、Apama、TIBCO StreamBase 和 SQLstream。</description>
    </item>
    
    <item>
      <title>Why MapReduce is making a comeback</title>
      <link>https://notes.0081800.xyz/notes/20210811111926-why_mapreduce_is_making_a_comeback/</link>
      <pubDate>Wed, 11 Aug 2021 11:19:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210811111926-why_mapreduce_is_making_a_comeback/</guid>
      <description>原文链接：Why MapReduce is making a comeback。</description>
    </item>
    
    <item>
      <title>When Zero Cost Abstractions Aren&#39;t Zero Cost</title>
      <link>https://notes.0081800.xyz/notes/20210810151736-when_zero_cost_abstractions_aren_t_zero_cost/</link>
      <pubDate>Tue, 10 Aug 2021 15:17:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210810151736-when_zero_cost_abstractions_aren_t_zero_cost/</guid>
      <description> tags: Rust 原文：When Zero Cost Abstractions Aren&amp;rsquo;t Zero Cost </description>
    </item>
    
    <item>
      <title>弹性分布式数据集</title>
      <link>https://notes.0081800.xyz/notes/20210810072604-%E5%BC%B9%E6%80%A7%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E9%9B%86/</link>
      <pubDate>Tue, 10 Aug 2021 07:26:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210810072604-%E5%BC%B9%E6%80%A7%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E9%9B%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title>HBase</title>
      <link>https://notes.0081800.xyz/notes/20210810071455-hbase/</link>
      <pubDate>Tue, 10 Aug 2021 07:14:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210810071455-hbase/</guid>
      <description>基于 Hadoop 分布式文件系统使用 SSTables 和 LSM-Tree 实现随机访问的 OLTP 数据库。</description>
    </item>
    
    <item>
      <title>大规模并行处理</title>
      <link>https://notes.0081800.xyz/notes/20210810070530-%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/</link>
      <pubDate>Tue, 10 Aug 2021 07:05:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210810070530-%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/</guid>
      <description>MPP 数据库 Gamma 数据库机器 Teradata Tandem NonStop SQL </description>
    </item>
    
    <item>
      <title>Clock Synchronization with Chris Perl</title>
      <link>https://notes.0081800.xyz/notes/20210809103849-clock_synchronization_with_chris_perl/</link>
      <pubDate>Mon, 09 Aug 2021 10:38:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210809103849-clock_synchronization_with_chris_perl/</guid>
      <description>tags: 分布式,一致性,Clock Synchronization,Multicast source: https://signalsandthreads.com/clock-synchronization/ Electronic Oscillator: Computer itself to Dervie its Notion of Time Computer&amp;rsquo;s clock are based on a 1 MHz electronic oscillator circuit, that is oscillating at some frequency, and driving an interrupt. So the operating system can use it to derive its notion of time. It helps computer to keep the time correct.
But a bad oscillator could be influenced by the heat of CPU, like compiling Linux kernel, etc.</description>
    </item>
    
    <item>
      <title>Hive</title>
      <link>https://notes.0081800.xyz/notes/20210809080723-hive/</link>
      <pubDate>Mon, 09 Aug 2021 08:07:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210809080723-hive/</guid>
      <description> tags: Bigdata bucketed map join </description>
    </item>
    
    <item>
      <title>Hadoop</title>
      <link>https://notes.0081800.xyz/notes/20210809073407-hadoop/</link>
      <pubDate>Mon, 09 Aug 2021 07:34:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210809073407-hadoop/</guid>
      <description>tags: Bigdata Hadoop Distributed File System MapReduce MapReduce shuffle 按照 reducer 分区，排序和将数据分区从 mapper 复制到 reducer。（令人困惑的术语，并不完全与洗牌一样，在 MapReduce 中其实没有随机性）。
MapReduce 的分布式执行 Hadoop MapReduce 并行化基于数据分区实现：
输入：通常是 HDFS 中的一个目录。 分区：每个文件或文件块都被视为一个单独的分区。 处理：每个分区由单独的 map 任务来处理。 每个 mapper 都会尽量实现计算靠近数据。 代码复制：JAR 文件。 Reduce 任务的计算也被分隔成块，可以不必与 mapper 任务数量相同，MapReduce 框架使用关键字的哈希值来确保具有相同关键字的键值对都在相同的 reduce 任务中处理。 键值对必须进行排序，排序是分阶段进行的： 每个 map 任务都基于关键字哈希值，按照 reducer 对输出进行分块。 每个分区都被写入 mapper 程序所在的本地磁盘上的已排序文件，参见 SSTables 和 LSM-Tree。 reducer 与每个 mapper 相连接：MapReduce 调度器会在 mapper 写入经过排序的输出文件后，通知 reducer 开始从 mapper 中获取输出文件，框架进行 MapReduce shuffle。 reducer 任务从 mapper 中获取文件并将它们合并在一起，同时保持数据的排序。不同 mapper 使用相同的关键字生成记录，会在合并后的 reducer 输入中位于相邻的位置。 reducer 可以使用任意逻辑来处理这些记录，并且生成任意数量的输出记录。记录被写入分布式文件系统中的文件。 MapReduce 工作流调度器 Oozie Azkaban Luigi Airflow Pinball 对比分布式数据库 MapReduce 中的并行处理和并行 join 算法已经在十多年前所谓的大规模并行处理（MPP）数据库中实现了。</description>
    </item>
    
    <item>
      <title>Tokio</title>
      <link>https://notes.0081800.xyz/notes/20210808083146-tokio/</link>
      <pubDate>Sun, 08 Aug 2021 08:31:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210808083146-tokio/</guid>
      <description> tags: Rust </description>
    </item>
    
    <item>
      <title>分布式文件系统</title>
      <link>https://notes.0081800.xyz/notes/20210808080733-%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Sun, 08 Aug 2021 08:07:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210808080733-%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid>
      <description> tags: 分布式 </description>
    </item>
    
    <item>
      <title>网络连接存储</title>
      <link>https://notes.0081800.xyz/notes/20210808075738-%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E5%AD%98%E5%82%A8/</link>
      <pubDate>Sun, 08 Aug 2021 07:57:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210808075738-%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E5%AD%98%E5%82%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Hadoop Distributed File System</title>
      <link>https://notes.0081800.xyz/notes/20210808075530-hadoop_distributed_file_system/</link>
      <pubDate>Sun, 08 Aug 2021 07:55:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210808075530-hadoop_distributed_file_system/</guid>
      <description>tags: Bigdata,分布式文件系统 与网络连接存储（NAS）和 存储区域网络（SAN）架构相比，HDFS 基于无共享原则，无需定制硬件和特殊网络基础设施（光纤）。
HDFS 创建了一个庞大的文件系统，来充分利用每个守护进程机器上的磁盘资源。
HDFS 包含一个在每台机器上运行的守护进程，并会开放一个网络服务以允许其他节点访问存储在该机器上的文件。 名为 NameNode 的中央服务器会跟踪哪个文件块存储在哪个服务器上。 考虑容错，文件快块复制到多台机器上，或者像 Reed-Solomon 代码中这样的纠删码方案（类似 RAID，但无需特殊硬件）。 提供很好的扩展性，配合商业硬件和开源软件，可以运行在上万台机器，容量达几百 PB。 计算靠近数据 只要有足够的空闲内存和 CPU 资源，MapReduce 调度器会尝试在输入文件的副本的某台机器上运行 mapper 任务。</description>
    </item>
    
    <item>
      <title>Emacs Easter egg</title>
      <link>https://notes.0081800.xyz/notes/20210808075104-emacs_easter_egg/</link>
      <pubDate>Sun, 08 Aug 2021 07:51:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210808075104-emacs_easter_egg/</guid>
      <description>tags: Emacs M-x life RET 康威生命游戏（Conway&amp;rsquo;s Game of Life）</description>
    </item>
    
    <item>
      <title>数据库</title>
      <link>https://notes.0081800.xyz/notes/20210805082720-%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Thu, 05 Aug 2021 08:27:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210805082720-%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description> tags: 技术 数据库作为一个长期发展的技术，但是在中国相对处于一个起步阶段，相关人才比较少。近年能够看得到的技术：
TiDB 分布式关系型数据库 TDengine 面向 IoT 的 OLAP 数据库 相关创业公司：
神策 https://zhuanlan.zhihu.com/p/396433354 </description>
    </item>
    
    <item>
      <title>批处理系统</title>
      <link>https://notes.0081800.xyz/notes/20210805074336-%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Thu, 05 Aug 2021 07:43:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210805074336-%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F/</guid>
      <description>MapReduce MapReduce 与分布式文件系统 MapReduce 就像分布在上千台机器上的 Unix 工具。
MapReduce 作业通常不会修改输入，除了输出外没有任何副作用。 MapReduce 作业在分布式文件系统上读写。（Unix 工具 stdin、stdout），如 HDFS（Hadoop Distributed File System)等（GlusterFS、QFS、Amazon S3、Azure Blob 和 OpenStack Swift）。 MapReduce 作业执行 MapReduce 是一个编程框架，可以使用它编写代码处理 HDFS 等分布式文件系统中的大型数据集。
要创建 MapReduce 作业需要实现两个回调函数： mapper 和 reducer （另请参阅 MapReduce 查询）:
Mapper: 每个输入记录都会调用一次，从输入记录提取任意数量的关键字和值（可以为空），不保留任何状态，可以独立处理。 Reducer: MapReduce 框架使用 Mapper 生成的键值对，收集同一个关键字的所有值，并使用迭代器调用 reducer 以使用该值的集合。 Reducer 可以生成输出记录。 MapReduce 分布式执行 参见 Hadoop 的 MapReduce 的分布式执行。
MapReduce 工作流 将 MapReduce 作业链接到工作流是非常普遍的，作业的输出作为下一个作业的输入。通过目录名隐式的完成：
第一个作业必须配置将其输出写入 HDFS 中指定目录； 第二个作业必须配置读取相同的目录名作为输入。 目前已经开发了处理依赖管理的 MapReduce 工作流调度器。
Reduce 端的 join 与分组 批处理的背景下讨论 join，主要解决数据集内存在关联的所有事件。 假设 join 两张表：用户和活动事件。</description>
    </item>
    
    <item>
      <title>LeetCode: 37. Sudoku Solver</title>
      <link>https://notes.0081800.xyz/notes/20210805073600-leetcode_37_sudoku_solver/</link>
      <pubDate>Thu, 05 Aug 2021 07:36:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210805073600-leetcode_37_sudoku_solver/</guid>
      <description> tags: LeetCode </description>
    </item>
    
    <item>
      <title>LeetCode: 36. Valid Sudoku</title>
      <link>https://notes.0081800.xyz/notes/20210805070351-leetcode_36_valid_sudoku/</link>
      <pubDate>Thu, 05 Aug 2021 07:03:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210805070351-leetcode_36_valid_sudoku/</guid>
      <description>tags: LeetCode https://leetcode.com/problems/valid-sudoku/
&amp;lt;- high -- low -&amp;gt; +------------------- wow(row(i):0,col(j):0) 0 -&amp;gt; [ 0010, 0010 ] | 1 -&amp;gt; [ 0000, 0000 ] | 2 -&amp;gt; [ 0000, 0000 ] | | +--------------- wow(row(i):0,col(j):1) 0 -&amp;gt; [ 0010 | 1 = 0011, 0010 ] | | 1 -&amp;gt; [ 0000, 0000 | 1 = 0001 ] | | 2 -&amp;gt; [ 0000, 0000 ] | | | | +----------- wow(row(i):0,col(j):2) 0 -&amp;gt; [ 0011 | 3 = 0100, 0010 ] | | | 1 -&amp;gt; [ 0000, 0001 ] | | | 2 -&amp;gt; [ 0000, 0000 | 3 = 0100 ] +---+---+---+ | 2 | 1 | 3 | +---+---+---+ ----| 3 | 2 | 1 | | +---+---+---+ | | 1 | 3 | 2 | | +---+---+---+ |- wow(row(i):1,col(j):0) 0 -&amp;gt; [0010 | 3 = 0110, 0010] +---------------------+ 1 -&amp;gt; [0000, 0001 | 3 = 0101] 2 -&amp;gt; [0000, 0100] class Solution { public: bool isValidSudoku(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board) { vector&amp;lt;int&amp;gt; wow(9,0); int mux1; int mux2; int mux3; int box_index; for(int i=0;i&amp;lt;9;i++){ for(int j=0;j&amp;lt;9;j++){ if(board[i][j] == &amp;#39;.</description>
    </item>
    
    <item>
      <title>区块链</title>
      <link>https://notes.0081800.xyz/notes/20210804115349-%E5%8C%BA%E5%9D%97%E9%93%BE/</link>
      <pubDate>Wed, 04 Aug 2021 11:53:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210804115349-%E5%8C%BA%E5%9D%97%E9%93%BE/</guid>
      <description> tags: 分布式共识,技术概念 </description>
    </item>
    
    <item>
      <title>LeetCode: 40. Combination Sum II</title>
      <link>https://notes.0081800.xyz/notes/20210804071039-leetcode_40_combination_sum_ii/</link>
      <pubDate>Wed, 04 Aug 2021 07:10:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210804071039-leetcode_40_combination_sum_ii/</guid>
      <description>tags: LeetCode source: https://leetcode.com/problems/combination-sum-ii/ LeetCode: 39. Combination Sum 的进阶。元素不在唯一且每一个元素只能出现一次。对结果进行排序然后通过 set 对结果进行去重：
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combinationSum2(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target) { sort(candidates.begin(), candidates.end()); backtracking(candidates, 0, 0, target); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; r; for (auto t : res) { r.push_back(t); } return r; } private: set&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; vector&amp;lt;int&amp;gt; track; map&amp;lt;int, bool&amp;gt; visited; void backtracking(vector&amp;lt;int&amp;gt;&amp;amp; condidates, int start, int n, int target) { if (n == target) { res.insert(track); return; } if (n &amp;gt; target) { return; } int c = 0; int sz = condidates.</description>
    </item>
    
    <item>
      <title>LeetCode: 39. Combination Sum</title>
      <link>https://notes.0081800.xyz/notes/20210804064757-leetcode_39_combination_sum/</link>
      <pubDate>Wed, 04 Aug 2021 06:47:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210804064757-leetcode_39_combination_sum/</guid>
      <description>tags: LeetCode source: https://leetcode.com/problems/combination-sum/ class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combinationSum(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target) { backtracking(candidates, 0, target); return res; } private: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; vector&amp;lt;int&amp;gt; track; void backtracking(vector&amp;lt;int&amp;gt; &amp;amp; candidates, int n, int target) { if (n == target) { res.push_back(track); return; } // this is new if (n &amp;gt; target) { return; } for (auto c : candidates) { track.push_back(c); backtracking(candidates, n + c, target); track.pop_back(); } } }; 问题：会有不同顺序但是元素相同的数组，如何快速高效的进行过滤？</description>
    </item>
    
    <item>
      <title>LeetCode: 52. N-Queens II</title>
      <link>https://notes.0081800.xyz/notes/20210803074630-leetcode_52_n_queens_ii/</link>
      <pubDate>Tue, 03 Aug 2021 07:46:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210803074630-leetcode_52_n_queens_ii/</guid>
      <description>tags: LeetCode,backtracking source: https://leetcode.com/problems/n-queens-ii/ 参见：LeetCode: 51. N-Queens</description>
    </item>
    
    <item>
      <title>回溯算法</title>
      <link>https://notes.0081800.xyz/notes/20210803065050-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</link>
      <pubDate>Tue, 03 Aug 2021 06:50:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210803065050-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</guid>
      <description> tags: Algorithm,Brute Force Approach </description>
    </item>
    
    <item>
      <title>工业云</title>
      <link>https://notes.0081800.xyz/notes/20210802193422-%E5%B7%A5%E4%B8%9A%E4%BA%91/</link>
      <pubDate>Mon, 02 Aug 2021 19:34:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210802193422-%E5%B7%A5%E4%B8%9A%E4%BA%91/</guid>
      <description>tags: 技术概念 创业公司有：积梦智能。</description>
    </item>
    
    <item>
      <title>云原生</title>
      <link>https://notes.0081800.xyz/notes/20210802193059-%E4%BA%91%E5%8E%9F%E7%94%9F/</link>
      <pubDate>Mon, 02 Aug 2021 19:30:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210802193059-%E4%BA%91%E5%8E%9F%E7%94%9F/</guid>
      <description> tags: 技术概念 </description>
    </item>
    
    <item>
      <title>云计算</title>
      <link>https://notes.0081800.xyz/notes/20210802193038-%E4%BA%91%E8%AE%A1%E7%AE%97/</link>
      <pubDate>Mon, 02 Aug 2021 19:30:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210802193038-%E4%BA%91%E8%AE%A1%E7%AE%97/</guid>
      <description> tags: 技术概念 </description>
    </item>
    
    <item>
      <title>技术概念</title>
      <link>https://notes.0081800.xyz/notes/20210802193020-%E6%8A%80%E6%9C%AF%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Mon, 02 Aug 2021 19:30:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210802193020-%E6%8A%80%E6%9C%AF%E6%A6%82%E5%BF%B5/</guid>
      <description>tags: 技术 目前互联网领域里比较热门的概念和方向。</description>
    </item>
    
    <item>
      <title>边缘计算</title>
      <link>https://notes.0081800.xyz/notes/20210802193049-%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/</link>
      <pubDate>Mon, 02 Aug 2021 19:30:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210802193049-%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/</guid>
      <description> tags: 技术概念 </description>
    </item>
    
    <item>
      <title>LeetCode: 51. N-Queens</title>
      <link>https://notes.0081800.xyz/notes/20210802073234-leetcode_51_n_queues/</link>
      <pubDate>Mon, 02 Aug 2021 07:32:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210802073234-leetcode_51_n_queues/</guid>
      <description>tags: LeetCode,backtracking source: https://leetcode.com/problems/n-queens/ 一旦一个 Queue 被放置，那么横轴、纵轴、对角线都不再允许放置。我们按行进行遍历，所以我们需要跟踪以下位置是否已经放置 Queue：
纵轴（Column）：cols 主对角线（Positive Diagonal）：posDiag 次对角线（Negative Diagonal）：negDiag 纵轴很好记录，但是对角线比较困难，我们先来看一下对角线的特征，假设横轴为 r 纵轴为 c ，
r - c 在正对角线是一致的：
斜对角线 r + c 是一致的:
class Solution { public: vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; solveNQueens(int n) { for (int r = 0; r &amp;lt; n; r++) { string col = string(n, &amp;#39;.&amp;#39;); track.push_back(col); } backtracking(0, n); return res; } private: set&amp;lt;int&amp;gt; cols; // c set&amp;lt;int&amp;gt; posDiag; // r - c set&amp;lt;int&amp;gt; negDiag; // r + c vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; res; vector&amp;lt;string&amp;gt; track; void backtracking(int r, int n) { if (r == n) { res.</description>
    </item>
    
    <item>
      <title>Multi-Paxios</title>
      <link>https://notes.0081800.xyz/notes/20210731075851-multi_paxios/</link>
      <pubDate>Sat, 31 Jul 2021 07:58:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210731075851-multi_paxios/</guid>
      <description> tags: 分布式共识,Paxos </description>
    </item>
    
    <item>
      <title>Zab</title>
      <link>https://notes.0081800.xyz/notes/20210731075206-zab/</link>
      <pubDate>Sat, 31 Jul 2021 07:52:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210731075206-zab/</guid>
      <description> tags: 分布式共识 </description>
    </item>
    
    <item>
      <title>Paxos</title>
      <link>https://notes.0081800.xyz/notes/20210731075140-paxos/</link>
      <pubDate>Sat, 31 Jul 2021 07:51:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210731075140-paxos/</guid>
      <description> tags: 分布式共识,分布式 </description>
    </item>
    
    <item>
      <title>Raft</title>
      <link>https://notes.0081800.xyz/notes/20210731075154-raft/</link>
      <pubDate>Sat, 31 Jul 2021 07:51:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210731075154-raft/</guid>
      <description> tags: 共识算法，分布式共识 </description>
    </item>
    
    <item>
      <title>VSR</title>
      <link>https://notes.0081800.xyz/notes/20210731075128-vsr/</link>
      <pubDate>Sat, 31 Jul 2021 07:51:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210731075128-vsr/</guid>
      <description> tags: Incomplete，分布式，共识算法 </description>
    </item>
    
    <item>
      <title>链式复制</title>
      <link>https://notes.0081800.xyz/notes/20210728071508-%E9%93%BE%E5%BC%8F%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Wed, 28 Jul 2021 07:15:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210728071508-%E9%93%BE%E5%BC%8F%E5%A4%8D%E5%88%B6/</guid>
      <description> tags: 分布式,Incomplete </description>
    </item>
    
    <item>
      <title>比较-设置</title>
      <link>https://notes.0081800.xyz/notes/20210728070407-%E6%AF%94%E8%BE%83_%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Wed, 28 Jul 2021 07:04:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210728070407-%E6%AF%94%E8%BE%83_%E8%AE%BE%E7%BD%AE/</guid>
      <description>利用底层指令集实现比较设置等原子操作。
See also：https://zh.wikipedia.org/wiki/%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2</description>
    </item>
    
    <item>
      <title>全序</title>
      <link>https://notes.0081800.xyz/notes/20210727073548-%E5%85%A8%E5%BA%8F/</link>
      <pubDate>Tue, 27 Jul 2021 07:35:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210727073548-%E5%85%A8%E5%BA%8F/</guid>
      <description></description>
    </item>
    
    <item>
      <title>macOS 签名 GDB</title>
      <link>https://notes.0081800.xyz/notes/20210726181021-macos_%E7%AD%BE%E5%90%8D_gdb/</link>
      <pubDate>Mon, 26 Jul 2021 18:10:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210726181021-macos_%E7%AD%BE%E5%90%8D_gdb/</guid>
      <description>tags: GDB,macOS macOS 下通过 GDB 调试程序会出现：
Unable to find Mach task port for process-id 1375: (os/kern) failure (0x5). (please check gdb is codesigned - see taskgated(8)) 需要通过 Keychain Access Application 创建证书： code-sign-cert
需要对 gdb 进行签名，首先创建 gdb-entitlement.xml ：
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;!DOCTYPE plist PUBLIC &amp;#34;-//Apple//DTD PLIST 1.0//EN&amp;#34; &amp;#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;#34;&amp;gt; &amp;lt;plist version=&amp;#34;1.0&amp;#34;&amp;gt; &amp;lt;dict&amp;gt; &amp;lt;key&amp;gt;com.apple.security.cs.debugger&amp;lt;/key&amp;gt; &amp;lt;true/&amp;gt; &amp;lt;/dict&amp;gt; 运行签名
codesign --entitlements gdb-entitlement.xml -fs code-sign-cert $(which gdb) See also: PermissionsDarwin。</description>
    </item>
    
    <item>
      <title>偏序</title>
      <link>https://notes.0081800.xyz/notes/20210726080332-%E5%81%8F%E5%BA%8F/</link>
      <pubDate>Mon, 26 Jul 2021 08:03:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210726080332-%E5%81%8F%E5%BA%8F/</guid>
      <description>偏序集合（英语：Partiallyordered set，简写poset）是数学中，特别是序理论中，指配备了部分排序关系的集合。 这
See also: 偏序关系</description>
    </item>
    
    <item>
      <title>CAP 理论</title>
      <link>https://notes.0081800.xyz/notes/20210726072940-cap_%E7%90%86%E8%AE%BA/</link>
      <pubDate>Mon, 26 Jul 2021 07:29:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210726072940-cap_%E7%90%86%E8%AE%BA/</guid>
      <description>CAP 最初作为一个经验法则提出（20 世纪 70 年代），并没有准确的定义，目的也只是帮助大家深入探讨数据库设计的权衡之道。它由 Eric Brewer 于 2000 年正式命名。
解释一 CAP 定理：不要求线性化的应用更能容忍网络故障。
只要不可靠才诶黄哦，都会发生违背线性化的风险。我们可以做如下权衡：
如果应用要求线性化，一旦发生网络分区，则必须等待网络修复，或者直接返回错误。结果为服务不可用（保证一致性或者线性化）。 如果应用不要求线性化，且每个可副本独立处理请求。此时服务可用，但结果行为不符合线性化（保证高可用）。 解释二 一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。系统只能支持两个特性。
这里的分区指网络分区（即网络故障）。
不过，这种理解存在误导性，网络分区是一种故障，不管喜欢还是不喜欢，它都可能发生，所以无法选择或逃避分区问题。
网络正常的时候，系统可以同时保证一致性（线性化）和可用性。而一旦发生了网络故障，必须要么选择线性（一致性），要么可用性。 也就是“网络分区的情况下”是选择一致还是可用。</description>
    </item>
    
    <item>
      <title>一致性与共识</title>
      <link>https://notes.0081800.xyz/notes/20210725072621-%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/</link>
      <pubDate>Sun, 25 Jul 2021 07:26:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210725072621-%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/</guid>
      <description>tags: 分布式共识,一致性 一致性保证 分布式一致性主要针对延迟和故障等问题来协调副本之间的状态。
线性化：最强一致性模型 顺序保证：保证时间顺序，特别是因果关系和全局顺序 最终一致性：一种非常弱的保证，参见最终一致性效应 可线性化 分布式语义下对寄存器（单个对象）顺序的读写。应区别与可串行化。
可串行化针对不同事务的隔离，用来确保事务执行的结果与串形执行的结果相同 可线性化是读写寄存器（单个对象）的最新值的保证。 线性化依赖的条件 加锁与主节点选举 每个启动节点都试图获得锁，其中只有一个可以成功成为主节点。通过加锁来保证主节点选举「线性化」。
约束与唯一性保证 同一个用户名、电子邮件或系统中文件名需要唯一性的保证，也应该进行「线性化」。
跨通道的时间依赖 系统中存在其他通信渠道也需要「线性化」。
实现线性化系统 主从复制（部分支持可线性化） 共识算法（可线性化） 多主复制（不可线性化） 无主复制（可能不可线性化） 线性化与Quorum 一致性 Dynamo 风格的复制模型，读写遵从严格的 quorum 是无法支持可线性化的。
线性化的代价 多主复制和主从复制，网络中断都会导致同步暂停，从而无法保证客户端要求的线性化读写。
CAP 理论 可线性化与网络延迟 很少有系统真正满足线性化，现代多个 CPU 对同一个内存地址的读写都不能满足（参见硬件内存模型），如果需要强一致则需要内存屏障（栅栏）指令。
之所以放弃线性化的原因就是性能，而不是为了容错。由于网络延迟的不确定性，无论是否发生网络故障，线性化对性能的影响都是巨大的。
顺序保证 顺序与因果关系 顺序有助于保持因果关系。
因果顺序并非全序：因果关系是小范围集合的偏序，可线性化是一个全序操作。 可线性化强于因果一致性 捕获因果依赖关系：检测并发写 序列号排序 非因果序列发生器 适用于系统不存在唯一主节点。
每个节点都独立产生自己的一组序列号：一个奇数一个偶数，或者切入节点唯一标识符。 用足够高的分辨率的墙上时间戳附加到每个操作上。 预先分配区间范围，并及时扩容。 Lamport 时间戳 可以产生因果关系一致的序列号。Lamport 时间戳是一个值对 （计数器，节点 ID） ：
节点 ID：每个节点都有一个唯一标志符。 计数器：每个节点都有一个计数器记录各自处理的请求总数。 优点：
两个节点可能存在相同的计数器，但是时间戳中的节点 ID 可以确保每个时间戳都是唯一的。 保证全序：比较两个 Lamport 时间戳，计数器较大的时间戳越大，计数器相同则节点 ID 大的那个时间戳越大。 通过节点排序保证了全局因果关系。Lamport 不同于版本矢量：</description>
    </item>
    
    <item>
      <title>拜占庭故障</title>
      <link>https://notes.0081800.xyz/notes/20210722080226-%E6%8B%9C%E5%8D%A0%E5%BA%AD%E6%95%85%E9%9A%9C/</link>
      <pubDate>Thu, 22 Jul 2021 08:02:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210722080226-%E6%8B%9C%E5%8D%A0%E5%BA%AD%E6%95%85%E9%9A%9C/</guid>
      <description>节点撒谎伪造 Fencing 令牌，或者部分节点故障、不遵从协议、干扰网络或者恶意攻击，则为「拜占庭故障」。 如果系统仍可以继续运行，那么我们称之为「拜占庭式容错系统」。</description>
    </item>
    
    <item>
      <title>Fencing 令牌</title>
      <link>https://notes.0081800.xyz/notes/20210722075942-fencing_%E4%BB%A4%E7%89%8C/</link>
      <pubDate>Thu, 22 Jul 2021 07:59:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210722075942-fencing_%E4%BB%A4%E7%89%8C/</guid>
      <description>Fencing（围栏）锁，每次锁服务授予锁时，同时返回 fencing 令牌，每次客户端发送写请求，都必须包含所持有的 fencing 令牌。
fencing 令牌单调递增，如果低版本的写入后到达，发现已经有高版本的 fencing 令牌写入，则拒绝此次写入。</description>
    </item>
    
    <item>
      <title>单调时钟与墙上时钟</title>
      <link>https://notes.0081800.xyz/notes/20210722073012-%E5%8D%95%E8%B0%83%E6%97%B6%E9%92%9F%E4%B8%8E%E5%A2%99%E4%B8%8A%E6%97%B6%E9%92%9F/</link>
      <pubDate>Thu, 22 Jul 2021 07:30:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210722073012-%E5%8D%95%E8%B0%83%E6%97%B6%E9%92%9F%E4%B8%8E%E5%A2%99%E4%B8%8A%E6%97%B6%E9%92%9F/</guid>
      <description>墙上时钟 根据某个日历返回当前的日期与时间。
Linux 上的 clock_gettime(CLOCK_REALTIME) Java 中的 System.currentTimeMills() 会返回 1970-01-01（UTC）的时间戳（秒和毫秒）。
墙上时钟会和 NTP 服务器同步产生跳跃导致一些奇怪的问题。
单调时钟 更适合测量持续时间段（时间间隔），如超时或服务的响应时间。保证总是向前（不会出现墙上时钟的回拨现象）。
Linux 上的 clock_gettime(CLOCK_MONOTONIC) Java 中的 System.nanoTime() 单调时钟多个节点的对比没有任何意义，多路 CPU 可能有单独的计时器，且不与其他 CPU 进行同步。由操作系统进行补偿它们之间的偏差。
NTP 检测到本地石英比时间服务器更快或者更慢，NTP 会调整本地石英的震动频率（摆动），最大幅度为 0.05%。 NTP 并不会直接调整单调时钟向前或回拨 。</description>
    </item>
    
    <item>
      <title>LeetCode: 47. Permutations II</title>
      <link>https://notes.0081800.xyz/notes/20210721073657-leetcode_47_permutations_ii/</link>
      <pubDate>Wed, 21 Jul 2021 07:36:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210721073657-leetcode_47_permutations_ii/</guid>
      <description>tags: LeetCode,backtracking 视频解析：https://www.youtube.com/watch?v=s7AvT7cGdSo
在 LeetCode: 46. Permutations 的基础上增加重复的元素。感觉不能依赖于 track + map 的去重逻辑回溯。
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permuteUnique(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; } }; 数据特征：
Value: 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, Index: 2, 1, 0, 1, 0, 2, 1, 0, 1, 0, 2, 1, 0, 1, 0, class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permuteUnique(vector&amp;lt;int&amp;gt;&amp;amp; nums) { set&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ret; int n, i; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; perms; if (nums.</description>
    </item>
    
    <item>
      <title>分布式系统挑战</title>
      <link>https://notes.0081800.xyz/notes/20210721063222-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%8C%91%E6%88%98/</link>
      <pubDate>Wed, 21 Jul 2021 06:32:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210721063222-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%8C%91%E6%88%98/</guid>
      <description>tags: 分布式 故障与部分失效 单节点一般是要么工作要么失效，但是分布式系统多节点面临部分失效，大大提高了分布式系统的复杂性。
单节点软件特性：
硬件正常工作时，相同的操作通常总会产生相同的结果，即确定性。 如果发生了某种内部错误，我们宁愿使计算机全部崩溃，而不是返回一个错误的结果。 云计算和超算 超算：垂直扩展的极端，设置检查点，一点节点故障则全部失效从上一个检查点重新开始（离线批处理），类似单机上内核崩溃。 云计算：水平扩展的极端 传统企业位于两个极端的中间 分布式可靠必然面临部分失效，需要依赖软件系统来提供容错机制。我们需要在不可靠的组件上构建可靠的系统。
不可靠网络 分布式无共享系统：成本低廉。 互联网以及大多数 IDC 内部网络都是异步网络：不保证发送一定到达（排队），等待响应时可能出现任何错误。 现实中的网络故障非常普遍 故障检测：HA、主从切换、保活机制（ICMP，SYN） 超时与无限期的延迟 网络拥塞与排队 网络负载过高会出现拥塞。 数据在发送的过程中分别会在发送端和接收端进行排队：等待发送和等待处理。 TCP 的拥塞控制机制。 虚拟化 CPU 核切换虚拟机 同步与异步网络 同步网络：固定电话网络，一路电话分配固定的电路、有带宽保证，规定延迟内保证完成数据包发送，不会丢弃数据包，成本高，利用率低 异步网络：数据中心网络，共享带宽，无法保证延迟和数据包发送，成本低廉，利用率高 不可靠时钟 单调时钟与墙上时钟 时间同步与准确性 计算机中的石英钟不够精确 NTP 服务器不稳定（网络、防火墙或服务本身） 虚拟机中时钟是虚拟化的。 终端设备不可控：休眠、故意设置 依赖同步的时钟 时钟陷阱：
一天可能不总是 86400 秒 回拨 多个节点上的时间完全不相同 需要精确同步的时钟：
自己监控所有节点上的时钟偏差 某个节点时钟漂移超出上限则将其宣告失效 时间戳与时间顺序 最后写入者获胜 时钟的置信区间 通过直接安装 GPS 接收器或原子（铯）时钟，它的误差范围通常可以查询制造商手册。
全局快照的同步时钟 Google Spanner 根据部署了 GPS 接收器或者原子时钟的 TrueTime API 返回的时钟置信区间。确保读事务足够晚发生，避免与先前事务的置信区间产生重叠。
进程暂停 垃圾回收 虚拟化暂停虚拟机 磁盘 I/O 内存交换分区 手动暂停进程（SIGSTOP/SIGCONT） 响应时间保证 RTOS 系统 调整垃圾回收的影响 知识，真相与谎言 真相由多数决定：Quorum 一致性 主节点与锁 Fencing 令牌 拜占庭故障 理论系统模型与现实 计时方面</description>
    </item>
    
    <item>
      <title>LeetCode: 46. Permutations</title>
      <link>https://notes.0081800.xyz/notes/20210719073125-leetcode_46_permutations/</link>
      <pubDate>Mon, 19 Jul 2021 07:31:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210719073125-leetcode_46_permutations/</guid>
      <description>tags: LeetCode,backtracking Keywords backtrack 回溯算法
图解 举例： [1, 2, 3] ，顺着叶子节点和删除的节点就可以还原成全排列。
从上面图可以看出来，叶子节点加上回溯路径上被移除的节点就是结果的一项，从左到右依次是：
[3,R:2,R:1] -&amp;gt; [3,2,1] [2,R:3,R:1] -&amp;gt; [2,3,1] &amp;hellip; class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permute(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; vector&amp;lt;int&amp;gt; track; backtrack(res, track, nums); return res; } void backtrack(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; res, vector&amp;lt;int&amp;gt; &amp;amp; track, vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (track.size() == nums.size()) { res.push_back(track); return; } for (int i = 0; i &amp;lt; nums.size(); i++) { if (visited.find(nums[i]) != visited.end() &amp;amp;&amp;amp; visited[nums[i]]) { continue; } track.</description>
    </item>
    
    <item>
      <title>JavaScript 内存模型 (2017)</title>
      <link>https://notes.0081800.xyz/notes/20210716120333-javascript_%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B_2017/</link>
      <pubDate>Fri, 16 Jul 2021 12:03:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210716120333-javascript_%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B_2017/</guid>
      <description> tags: 编程语言内存模型,JavaScript litmus test
Litmus Test: ES2017 racy reads on ARMv8 Can this program (using atomics) see r1 = 0, r2 = 1? // Thread 1 // Thread 2 x = 1 y = 1 r1 = y x = 2 (non-atomic) r2 = x C++: yes (data race, can do anything at all). Java: the program cannot be written. ARMv8 using ldar/stlr: yes. ES2017: no! (contradicting ARMv8) </description>
    </item>
    
    <item>
      <title>C、Rust 和 Swift 的内存模型</title>
      <link>https://notes.0081800.xyz/notes/20210716120258-c_rust_%E5%92%8C_swift_%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Fri, 16 Jul 2021 12:02:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210716120258-c_rust_%E5%92%8C_swift_%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description>tags: Rust,Swift,编程语言内存模型 都采用C++11 内存模型。</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 弱同步原子（acquire/release atomic）</title>
      <link>https://notes.0081800.xyz/notes/20210716115953-c_%E5%BC%B1%E5%90%8C%E6%AD%A5%E5%8E%9F%E5%AD%90_acquire_release_atomic/</link>
      <pubDate>Fri, 16 Jul 2021 11:59:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210716115953-c_%E5%BC%B1%E5%90%8C%E6%AD%A5%E5%8E%9F%E5%AD%90_acquire_release_atomic/</guid>
      <description>tags: C++11 内存模型,C/C++ C++ 还添加了较弱的原子，可以使用 atomic_store_explicit 和 atomic_load_explicit 以及附加的n内存排序参数来访问这些原子。使用 memory_order_seq_cst 使显式调用等效于C++ 同步原子（atomic）较短的调用。
较弱的原子称为 acquire/release 原子，一个 release 如果被后来的 acquire 观察到，那么就创建了一个 happen-before 的关系(从 release 到 acquire)。这个术语意在唤起 mutex:release 就像 unlock mutex ， acquire 就像锁定同一个 mutex 。release 之前执行的写入必须对后续 acquire 之后执行的读取可见，就像解锁 mutex 之前执行的写入必须对后解锁 mutex 之后执行的读取可见一样。
atomic&amp;lt;int&amp;gt; done; // Thread 1 // Thread 2 atomic_store(&amp;amp;done, 1, memory_order_release); while(atomic_load(&amp;amp;done, memory_order_acquire) == 0) { /* loop */ } acquire/release 原子只对单个内存位置的操作进行顺序一致的交替执行，所以属于内存一致性（coherence）而非顺序一致性。
来看下面 litmus test：
Litmus Test: Store Buffering Can this program see r1 = 0, r2 = 0?</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 非同步原子（Relaxed atomic）</title>
      <link>https://notes.0081800.xyz/notes/20210716114242-c_%E9%9D%9E%E5%90%8C%E6%AD%A5%E5%8E%9F%E5%AD%90_relaxed_atomic/</link>
      <pubDate>Fri, 16 Jul 2021 11:42:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210716114242-c_%E9%9D%9E%E5%90%8C%E6%AD%A5%E5%8E%9F%E5%AD%90_relaxed_atomic/</guid>
      <description>tags: C++11 内存模型,C/C++ C++ 并没有仅仅停留在内存一致性（coherence）的C++ 弱同步原子（acquire/release atomic）。它还引入了非同步原子，称为 relaxed 原子（memory_order_relaxed）。这些原子根本没有同步效果——它们没有创建先发生的边——并且它们根本没有排序保证。事实上，宽松原子读_写和普通读_写没有区别，除了宽松原子上的竞争不被认为是竞争， 不能着火 。</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 同步原子（atomic）</title>
      <link>https://notes.0081800.xyz/notes/20210716113858-c_%E5%90%8C%E6%AD%A5%E5%8E%9F%E5%AD%90_atomic/</link>
      <pubDate>Fri, 16 Jul 2021 11:38:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210716113858-c_%E5%90%8C%E6%AD%A5%E5%8E%9F%E5%AD%90_atomic/</guid>
      <description> tags: C++11 内存模型 C++ 采用了顺序一致的原子变量，很像Java 同步原子（volatile）(与 C++ volatile 没有关系）。
atomic&amp;lt;int&amp;gt; done; // Thread 1 // Thread 2 atomic_store(&amp;amp;done, 1); while(atomic_load(&amp;amp;done) == 0) { /* loop */ } C++ 弱同步原子（acquire/release atomic） </description>
    </item>
    
    <item>
      <title>DRF-SC 还是着火（Catch Fire）</title>
      <link>https://notes.0081800.xyz/notes/20210716113642-drf_sc_%E8%BF%98%E6%98%AF%E7%9D%80%E7%81%AB_catch_fire/</link>
      <pubDate>Fri, 16 Jul 2021 11:36:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210716113642-drf_sc_%E8%BF%98%E6%98%AF%E7%9D%80%E7%81%AB_catch_fire/</guid>
      <description>tags: C++11 内存模型 与 Java 不同，C++ 没有给有竞争的程序任何保证。任何有竞争的程序都属于“未定义的行为”。允许在程序执行的最初几微秒内进行竞争访问，从而在几小时或几天后导致任意的错误行为。这通常被称为“DRF-SC或着火”：如果程序没有数据竞争，它以顺序一致的方式运行，如果有数据竞争，它可以做任何事情，包括着火。</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 内存模型</title>
      <link>https://notes.0081800.xyz/notes/20210716113225-c_11_%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Fri, 16 Jul 2021 11:32:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210716113225-c_11_%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description>tags: C/C++,Memory Model,编程语言内存模型 受新的 Java 内存模型（2004）许多同样的人开始为 C++ 定义一个类似的内存模型，最终在 C++11 中采用。 两个重要方便的差异：
C++ 对具有数据竞争的程序不做任何保证 C++ 提供了三种原子性：强同步（顺序一致性），弱同步（内存一致性（coherence））和无同步（“relaxed”，用于隐藏竞争）。 第一点尝试消除对 Java 模型的复杂性需求，“relaxed” 的原子性重新引入 Java 关于定义什么是竞争程序的所有复杂性。结果是C++模型比Java更复杂，但对程序员的帮助更小。</description>
    </item>
    
    <item>
      <title>Java 同步原子（volatile）</title>
      <link>https://notes.0081800.xyz/notes/20210716112805-java_%E5%90%8C%E6%AD%A5%E5%8E%9F%E5%AD%90_volatile/</link>
      <pubDate>Fri, 16 Jul 2021 11:28:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210716112805-java_%E5%90%8C%E6%AD%A5%E5%8E%9F%E5%AD%90_volatile/</guid>
      <description>线程的创建前置于（happens bofere）线程的第一个动作。 互斥体 m 的解锁前置于（happens before）任何 后续（subsequent） 对互斥体 m 的锁定。 volatile 变量 v 的写入前置于（happens bofere）任何 后续（subsequent） 对变量 v 的读取。 “后续（subsequent）” 意味着什么？Java 定义了所有锁定、解锁和 volatile 变量访问的行为，给出了整个程序中所有这些操作的总顺序，就像它们发生在某个顺序一致的交错中一样。“后续（subsequent）”指在总顺序中较晚执行。也就是说：锁定、解锁和 volatile 变量的访问的“总顺序”定义了“后续”的含义，“后续”定义了由特定执行创建的“前置于（happens before）”关系，最终“前置于（happens before）”关系定义了该特定执行是否存在数据竞争。如果没有数据竞争，那么执行就会以顺序一致的方式进行。
事实上， volatile 访问必须表现得像在某种总排序一样，意味这在下面 litmus test 中，不能出现 r1=0 和 r2=0 的结果:
Litmus Test: Store Buffering Can this program see r1 = 0, r2 = 0? // Thread 1 // Thread 2 x = 1 y = 1 r1 = y r2 = x On sequentially consistent hardware: no.</description>
    </item>
    
    <item>
      <title>Java 决定竞争读写的具体规则</title>
      <link>https://notes.0081800.xyz/notes/20210716112456-java_%E5%86%B3%E5%AE%9A%E7%AB%9E%E4%BA%89%E8%AF%BB%E5%86%99%E7%9A%84%E5%85%B7%E4%BD%93%E8%A7%84%E5%88%99/</link>
      <pubDate>Fri, 16 Jul 2021 11:24:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210716112456-java_%E5%86%B3%E5%AE%9A%E7%AB%9E%E4%BA%89%E8%AF%BB%E5%86%99%E7%9A%84%E5%85%B7%E4%BD%93%E8%A7%84%E5%88%99/</guid>
      <description>对于小于等于 word 大小的变量，对变量（或字段） x 的读取必须看到对 x 的某一次写入所存储的值。 如果读取 r 观察到对 x 的写入 w ，那么 r 不发生在 w 之前。
也就是说 r 可以观察发生在 r 之前的所有写入，并且可以观察与 r 竞争的写入。</description>
    </item>
    
    <item>
      <title>内存顺序一致性（sequential consistency）</title>
      <link>https://notes.0081800.xyz/notes/20210716111043-%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7_sequential_consistency/</link>
      <pubDate>Fri, 16 Jul 2021 11:10:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210716111043-%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7_sequential_consistency/</guid>
      <description>See also: 顺序一致性。</description>
    </item>
    
    <item>
      <title>内存一致性（coherence）</title>
      <link>https://notes.0081800.xyz/notes/20210716110953-%E5%86%85%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7_coherence/</link>
      <pubDate>Fri, 16 Jul 2021 11:09:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210716110953-%E5%86%85%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7_coherence/</guid>
      <description>tags: Memory Model，一致性 FROM 硬件内存模型：
threads in the system must agree about a total order for the writes to a single memory location. That is, threads must agree which writes overwrite other writes. This property is called called coherence.
内存一致性的系统都所有线程都必须接受对一个内存地址所有写入的总顺序。换句话说，所有线程必须同意哪些写入可以覆盖另外的一些写入。</description>
    </item>
    
    <item>
      <title>Memory coherence vs consistency</title>
      <link>https://notes.0081800.xyz/notes/20210716110147-memory_coherence_vs_consistency/</link>
      <pubDate>Fri, 16 Jul 2021 11:01:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210716110147-memory_coherence_vs_consistency/</guid>
      <description>Coherence deals with maintaining a global order in which writes to a single location or single variable are seen by all processors. Consistency deals with the ordering of operations to multiple locations with respect to all processors.
Memory coherence: a memory system is coherent if any read of a data item returns the most recently written value of that data item (what values can be returned by a read).</description>
    </item>
    
    <item>
      <title>悲观与乐观并发控制</title>
      <link>https://notes.0081800.xyz/notes/20210716080024-%E6%82%B2%E8%A7%82%E4%B8%8E%E4%B9%90%E8%A7%82%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Fri, 16 Jul 2021 08:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210716080024-%E6%82%B2%E8%A7%82%E4%B8%8E%E4%B9%90%E8%A7%82%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</guid>
      <description>悲观并发控制 两阶段加锁是一个典型的悲观并发控制。设计原则：如果某些操作可能出错，则直接放弃等待直到安全。
乐观并发控制 如果可能发生潜在冲突，事务会继续执行而不是终止，寄希望与相安无事；而当事务提交时，数据库会检查是否发生了冲突，如果是的话，中止事务并接下来重试。
对比 如果冲突很多则性能不佳，如果性能良好，且事务之间的竞争不大，乐观并发控制会比悲观方式性能高很多。</description>
    </item>
    
    <item>
      <title>可串形化的快照隔离</title>
      <link>https://notes.0081800.xyz/notes/20210716075758-%E5%8F%AF%E4%B8%B2%E5%BD%A2%E5%8C%96%E7%9A%84%E5%BF%AB%E7%85%A7%E9%9A%94%E7%A6%BB/</link>
      <pubDate>Fri, 16 Jul 2021 07:57:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210716075758-%E5%8F%AF%E4%B8%B2%E5%BD%A2%E5%8C%96%E7%9A%84%E5%BF%AB%E7%85%A7%E9%9A%94%E7%A6%BB/</guid>
      <description>可串形化的快照隔离（Serializable Snapshot Isolation，SSI）近两年被研究，尚需在实践中证明其性能，但是它很有可能成为未来数据的标配。
悲观与乐观并发控制 </description>
    </item>
    
    <item>
      <title>两阶段加锁</title>
      <link>https://notes.0081800.xyz/notes/20210716074845-%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%8A%A0%E9%94%81/</link>
      <pubDate>Fri, 16 Jul 2021 07:48:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210716074845-%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%8A%A0%E9%94%81/</guid>
      <description>两阶段枷锁（two-phase locking，2PL）是近 30 年来数据库唯一一种被广泛使用的串形化算法。 多个事务可以同时读取同一个对象，但只要出现任何写操作（修改或删除），则必须加锁以独占访问。
两阶段包括：
事务执行之前要获得锁（第一阶段） 事务结束之后要释放锁（第二阶段） 实现 2PL 用于 MySQL（InnoDB）和 SQL Server 中的“可串形化隔离”，以及 DB2 的“可重复读”。
每个对象通过一个「读写锁」隔离读写操作。
共享锁进行读取。 独占锁进行修改。 读取先获取共享锁，如果要修改则升级为独占锁。 事务获得锁之后一直持有到事务结束。 性能 慢和死锁
谓词锁 通过对区间条件加谓词锁。
索引区间锁 </description>
    </item>
    
    <item>
      <title>串行化</title>
      <link>https://notes.0081800.xyz/notes/20210716074157-%E4%B8%B2%E8%A1%8C%E5%8C%96/</link>
      <pubDate>Fri, 16 Jul 2021 07:41:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210716074157-%E4%B8%B2%E8%A1%8C%E5%8C%96/</guid>
      <description>实际串行执行 解决并发问题最直接的方法：在一个线程上按照顺序方式每次执行一个事务。
为什么可行：
内存越来越便宜，可以将事务需要的数据都放在内存中。 OLTP 事务通常执行很快，只产生少量的读写操作。通常较长时间的分析操作通常是只读。 事务为了充分利用单线程所做的调整：
采用存储过程封装事务，Redis 采用 Lua 分区 约束 事务必须简短而高效。 事务所需数据都在内存。 写入吞吐量必须低，否则需要采用分区，最好没有跨分区事务。 要支持跨分区事务必须确保跨分区事务占比很小。 两阶段加锁 可串形化的快照隔离 </description>
    </item>
    
    <item>
      <title>写倾斜</title>
      <link>https://notes.0081800.xyz/notes/20210716072157-%E5%86%99%E5%80%BE%E6%96%9C/</link>
      <pubDate>Fri, 16 Jul 2021 07:21:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210716072157-%E5%86%99%E5%80%BE%E6%96%9C/</guid>
      <description>即不是脏写也不会更新丢失，事务之间的写冲突并不直接，写倾斜可以视为更广义的数据丢失。
考虑急诊医生请假系统，核心逻辑是必须要有一个医生值班。两个医生同时请假，事务同时同时开始，那么两个医生都能查询到有两个医生值班，最后请假成功，导致无医生值班。</description>
    </item>
    
    <item>
      <title>写倾斜与幻读</title>
      <link>https://notes.0081800.xyz/notes/20210716071953-%E5%86%99%E5%80%BE%E6%96%9C%E4%B8%8E%E5%B9%BB%E8%AF%BB/</link>
      <pubDate>Fri, 16 Jul 2021 07:19:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210716071953-%E5%86%99%E5%80%BE%E6%96%9C%E4%B8%8E%E5%B9%BB%E8%AF%BB/</guid>
      <description>写事务并发除了需要防止更新丢失还有一些更为微妙的写冲突。
写倾斜与幻读 定义写倾斜。</description>
    </item>
    
    <item>
      <title>防止更新丢失</title>
      <link>https://notes.0081800.xyz/notes/20210716070457-%E9%98%B2%E6%AD%A2%E6%9B%B4%E6%96%B0%E4%B8%A2%E5%A4%B1/</link>
      <pubDate>Fri, 16 Jul 2021 07:04:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210716070457-%E9%98%B2%E6%AD%A2%E6%9B%B4%E6%96%B0%E4%B8%A2%E5%A4%B1/</guid>
      <description>读事务遇到并发写会出现脏读（读-提交和可重复读可以解决），写事务并发会带来一些冲突，最值得关注的就是更新丢失问题。 应用程序从数据库读取某些值，然后应用逻辑做出修改，然后写回新值。
原子写操作 UPDATE counters SET value=value+1 WHERE key = &amp;#39;foo&amp;#39;; 原子操作通常采用方式：
对读取对象加独占加锁，这种技术有时被称为「游标稳定性」。 强制所有原子操作都在单线程上执行。 显式枷锁 BEGIN TRANSACTION; SELECT * FROM figures WHERE name = &amp;#39;robot&amp;#39; AND game_id = 222 FOR UPDATE; -- 指示数据库对返回的所有结果行要加锁。 缺点：侵入应用逻辑、容易引发死锁（竞争冲突）。
自动检测更新丢失 数据库（Oracle 的串形化和 SQL Server 的快照级别隔离）可以自动检测何时发生了更新丢失，然后终止违规的那个事务。
原子比较和设置 UPDATE wiki_pages SET content = &amp;#39;new_content&amp;#39; WHERE id = 1234 AND conetnt = &amp;#39;old_content&amp;#39;; 冲突解决与复制 最后写入者获胜 </description>
    </item>
    
    <item>
      <title>更新 Go 内存模型</title>
      <link>https://notes.0081800.xyz/notes/20210715110202-%E6%9B%B4%E6%96%B0_go_%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Thu, 15 Jul 2021 11:02:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210715110202-%E6%9B%B4%E6%96%B0_go_%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description> tags: Go,Memory Model source: 更新Go内存模型 https://research.swtch.com/gomm </description>
    </item>
    
    <item>
      <title>LeetCode: 25. Reverse Nodes in k-Group</title>
      <link>https://notes.0081800.xyz/notes/20210715064442-leetcode_25_reverse_nodes_in_k_group/</link>
      <pubDate>Thu, 15 Jul 2021 06:44:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210715064442-leetcode_25_reverse_nodes_in_k_group/</guid>
      <description>tags: LeetCode source: https://leetcode.com/problems/reverse-nodes-in-k-group/ /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { deque&amp;lt;ListNode*&amp;gt; dq; ListNode* cur = head; ListNode* top = nullptr; ListNode* tail = nullptr; bool first_k = true; while (cur !</description>
    </item>
    
    <item>
      <title>事务隔离级别</title>
      <link>https://notes.0081800.xyz/notes/20210714074945-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</link>
      <pubDate>Wed, 14 Jul 2021 07:49:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210714074945-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</guid>
      <description>读-未提交 读数据时，会读到未成功提交的数据（未防止“脏读”） 写数据时，只会覆盖已成功提交的数据（防止“脏写”） 读-提交 读数据时，只会读到已成功提交的数据（防止“脏读”） 写数据时，只会覆盖已成功提交的数据（防止“脏写”） 防止脏写 通常通过推迟第二个写请求（行锁），直到前面的事务完成提交（或者终止）。
防止脏读 通过行锁同样可以避免脏读，但是实际中不可行（性能太差），一般采用类似 MVCC 的方式：对于待更新的对象，数据库都会维护其旧值和当前持锁事务将要设置的新值两个版本。 事务提交之前，其他所有读操作读旧值；仅当写事务提交之后，才会切换到读取新值。
可重复读（快照级别隔离） 在同一个事务中，反复读取总能获得一致性的结果，而不会读取到其他事务提交修改的新值。总体性想法是：每个事务都从数据库的一致性快照中读取，事务一开始所看到的是最近提交的数据，即使数据随后可能被另外一个事务更改，但保证每个事务都只看到特定时间点的旧数据。
实现快照级别隔离 MVCC
串行化 </description>
    </item>
    
    <item>
      <title>ACID</title>
      <link>https://notes.0081800.xyz/notes/20210714074135-acid/</link>
      <pubDate>Wed, 14 Jul 2021 07:41:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210714074135-acid/</guid>
      <description>原子性（Atomicity） 一致性（Consistency） 一致性并不是数据所保证的，而是程序借助数据库的原子性和隔离性（AD）来达到一致性。一致性的 C 放到 ACID 中只是为了可以更加顺畅的宣传（读）。
隔离性（Isolation） 事务隔离级别
持久性（Durability） </description>
    </item>
    
    <item>
      <title>事务</title>
      <link>https://notes.0081800.xyz/notes/20210714073909-%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Wed, 14 Jul 2021 07:39:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210714073909-%E4%BA%8B%E5%8A%A1/</guid>
      <description>事务简化程序层错误处理，将多个读写捆绑成一个操作逻辑操作单元，成功则全部成功，失败则可以进行安全重试。
深入理解事务 ACID 单对象与多对象事务操作 事务操作涉及多对象和但对象。
多对象，如更新邮件未读数和未读邮件个数 单对象，如更新一个大的字段（20KB 的 JSON） 弱隔离级别 事务隔离级别中的「读-未提交」、「读-提交」和「快照级别隔离可重复读」。
防止更新丢失 写倾斜与幻读 串行化 </description>
    </item>
    
    <item>
      <title>LeetCode: 92. Reverse Linked List II</title>
      <link>https://notes.0081800.xyz/notes/20210714065549-leetcode_92_reverse_linked_list_ii/</link>
      <pubDate>Wed, 14 Jul 2021 06:55:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210714065549-leetcode_92_reverse_linked_list_ii/</guid>
      <description>tags: LeetCode source: https://leetcode.com/problems/reverse-linked-list-ii/ /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseBetween(ListNode* head, int left, int right) { stack&amp;lt;int&amp;gt; st; ListNode* cur = head; ListNode* prev_start = nullptr; if (left == 1) { prev_start = new ListNode(0, head); // dummy prev_start point to head } int i = 1; while(cur !</description>
    </item>
    
    <item>
      <title>Emacs Projectile 优化</title>
      <link>https://notes.0081800.xyz/notes/20210714065205-emacs_projectile_%E4%BC%98%E5%8C%96/</link>
      <pubDate>Wed, 14 Jul 2021 06:52:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210714065205-emacs_projectile_%E4%BC%98%E5%8C%96/</guid>
      <description> tags: Emacs 最近换到 ivy 之后 projectile 切换项目加载 Buffer 或查找文件变得巨慢，查抄一番发现问题可以通过缓存解决：
ivy-rich Projectile Caching </description>
    </item>
    
    <item>
      <title>Java 内存模型</title>
      <link>https://notes.0081800.xyz/notes/20210713202541-java_%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Tue, 13 Jul 2021 20:25:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210713202541-java_%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description> tags: Memory Model,Java,编程语言内存模型 </description>
    </item>
    
    <item>
      <title>新的 Java 内存模型（2004）</title>
      <link>https://notes.0081800.xyz/notes/20210713201332-%E6%96%B0%E7%9A%84_java_%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B_2004/</link>
      <pubDate>Tue, 13 Jul 2021 20:13:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210713201332-%E6%96%B0%E7%9A%84_java_%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B_2004/</guid>
      <description> tags: Java 内存模型 新模型遵循 DRF-SC 方法：保证弱有序和无数据竞争（DRF）的 Java 程序以顺序一致的方式执行。
JSR-133，在 2004 年发布的 Java 5.0 中被采用。规范：The Java Memory Model, 2005。
Java 中程序员需要同步操作建立 happens-before 关系，确保一个线程不会在另一个线程读取或写入时并发的写入非原子变量。主要的同步操作有：
同步原子（volatile）和其它操作 参见：Java 同步原子（volatile）。
有数据竞争的程序语义 弱有序和无数据竞争（DRF）只保证「无数据」竞争的程序的顺序一致性行为。新的 Java 模型（和原版本一致）出于以下原因定义了「有数据」竞争程序的顺序一致性行为：
支持Java的一般安全（security）和安全保障（safety guarantee）。 让程序员更容易发现错误。 使攻击者更难利用问题，因为由于数据竞争的原因可能造成的损失更有限。 让程序员更清楚他们的程序是做什么的 新的模型不再依赖内存一致性（coherence），取而代之的复用 happens-before（已经用于决定程序是否存在竞争）来决定竞争读写的结果。
具体规则参见：Java 决定竞争读写的具体规则。使用 happens-before 并结合Java 同步原子（volatile）就可以建立新的 happen before 关系，是对原始Java内存模型的重大改进。它为程序员提供了更多有用的保证，并使大量重要的编译器优化得到了明确的允。
happens-before 不排除语无伦次（incoherence） 以前发生的事不排除无用性（acausality） </description>
    </item>
    
    <item>
      <title>Java 编译器公共子表达式消除（common subexpression elimination）</title>
      <link>https://notes.0081800.xyz/notes/20210713201045-java_%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%AC%E5%85%B1%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B6%88%E9%99%A4_common_subexpression_elimination/</link>
      <pubDate>Tue, 13 Jul 2021 20:10:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210713201045-java_%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%AC%E5%85%B1%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B6%88%E9%99%A4_common_subexpression_elimination/</guid>
      <description>// p and q may or may not point at the same object. int i = p.x; // ... maybe another thread writes p.x at this point ... int j = q.x; int k = p.x; 在这个程序中，公共子表达式消除（common subexpression elimination）会注意到 p.x 被计算了两次，并将最后一行优化为 k = i 。</description>
    </item>
    
    <item>
      <title>原始 Java 内存模型（1996）</title>
      <link>https://notes.0081800.xyz/notes/20210713200556-%E5%8E%9F%E5%A7%8B_java_%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B_1996/</link>
      <pubDate>Tue, 13 Jul 2021 20:05:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210713200556-%E5%8E%9F%E5%A7%8B_java_%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B_1996/</guid>
      <description> tags: Java 内存模型,Java Java 是第一个试图写下多线程程序保证的主流语言。它包括：
互斥体（mutex），并定义了它们隐含的内存排序要求。 “volatile” 原子变量: volatile 变量的所有读和写都需要直接在主内存中按程序顺序执行，使得对 volatile 变量的操作以顺序一致的方式进行。 制定了（或者至少试图制定）具有数据竞争的程序的行为。 缺陷 Atomic 需要同步：volatile 原子变量是不同步的，所以它们无助于消除程序其余部分的竞争。不能用于构建新的同步原语。 一致性与编译器优化不兼容：Java 编译器公共子表达式消除（common subexpression elimination）会导致其他线程写入新值无法对消除后表达式生效。 </description>
    </item>
    
    <item>
      <title>DRF-SC 系统同步指令</title>
      <link>https://notes.0081800.xyz/notes/20210713195115-drf_sc_%E7%B3%BB%E7%BB%9F%E5%90%8C%E6%AD%A5%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Tue, 13 Jul 2021 19:51:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210713195115-drf_sc_%E7%B3%BB%E7%BB%9F%E5%90%8C%E6%AD%A5%E6%8C%87%E4%BB%A4/</guid>
      <description>保证了弱有序和无数据竞争（DRF）的系统会提供称为同步的特定指令，提供一种协调不同处理器（相当于硬件线程）的属性。</description>
    </item>
    
    <item>
      <title>同步原子（synchronizing atomic）</title>
      <link>https://notes.0081800.xyz/notes/20210713194409-%E5%90%8C%E6%AD%A5%E5%8E%9F%E5%AD%90_synchronizing_atomic/</link>
      <pubDate>Tue, 13 Jul 2021 19:44:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210713194409-%E5%90%8C%E6%AD%A5%E5%8E%9F%E5%AD%90_synchronizing_atomic/</guid>
      <description>原子变量（atomic variable）或原子操作（tomic operation）更好的解释。</description>
    </item>
    
    <item>
      <title>原子变量（atomic variable）或原子操作（tomic operation）</title>
      <link>https://notes.0081800.xyz/notes/20210713193214-%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F_atomic_variable_%E6%88%96%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C_tomic_operation/</link>
      <pubDate>Tue, 13 Jul 2021 19:32:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210713193214-%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F_atomic_variable_%E6%88%96%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C_tomic_operation/</guid>
      <description>现代语言以原子变量（atomic variable）或原子操作（atomic operation）的形式提供特殊能力，允许程序同步其线程(参见硬件内存一致性模型)。
代码示例
// Thread 1 // Thread 2 x = 1; while(done == 0) { /* loop */ } done = 1; print(x); 如果使用原子变量实现 done 会产生很多效果：
Thread 1 的编译代码必须确保对 x 的写入完成，并且对 done 的写入可见之前对 x 的写入对其他线程可见。 Thread 2 的编译代码必须在循环的每次迭代中（重新）读取 done 。 Thread 2 的编译代码必须在读取 done 之后才读取 x 。 编译后的代码必须做任何必要的事情来禁用可能会重新引入这些问题的硬件优化。 使 done 原子化的最终结果是程序按照我们想要的方式运行，成功地将 x 的值从 Thread 1 传递到 Thread 2 。 上面代码如果不使用原子变量会出现 Thread 1 和 Thread 2 读取 x 的同时写 x ，从而导致数据竞争（data race)。 done 使用原子变量实现后，用于同步对 x 的访问： Thread 1 现在不可能在 Thread 2 读取 x 的同时写 x，从而避免数据竞争。 这是硬件内存模型弱有序和无数据竞争（DRF）在编程语言环境的应用。</description>
    </item>
    
    <item>
      <title>弱有序和无数据竞争（DRF）</title>
      <link>https://notes.0081800.xyz/notes/20210712164357-%E5%BC%B1%E6%9C%89%E5%BA%8F%E5%92%8C%E6%97%A0%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89_drf/</link>
      <pubDate>Mon, 12 Jul 2021 16:43:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210712164357-%E5%BC%B1%E6%9C%89%E5%BA%8F%E5%92%8C%E6%97%A0%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89_drf/</guid>
      <description>弱有序是 Sarita Adve 和 Mark Hill 在他们 1990 年的论文 Weak Ordering - A New Definition (1990) 提出。
定义如下
Let a synchronization model be a set of constraints on memory accesses that specify how and when synchronization needs to be done.
同步模型是对内存访问的一组约束，这些约束指定了何时以及如何进行同步。
硬件相对于同步模型是弱有序的，当且仅当它在顺序上与遵守同步模型的所有软件一致时。
Adve和Hill提出了一种同步模型，他们称之为无数据竞争(data-race-free，DRF)。该模型假设硬件具有独立于普通内存读写的内存同步操作。普通的内存读写可以在同步操作之间重新排序，但不能在跨它们移动。(也就是说，同步操作也可用来做重新排序的内存屏障。)如果对于所有理想化的顺序一致的执行，从不同线程对同一位置的任何两个普通存储器访问要么都是读取，要么通过同步操作强制一个在另一个之前发生而分开执行，则程序被称为无数据竞争的。</description>
    </item>
    
    <item>
      <title>ARM/POWER Relaxed Memory Model</title>
      <link>https://notes.0081800.xyz/notes/20210712162917-arm_power_relaxed_memory_model/</link>
      <pubDate>Mon, 12 Jul 2021 16:29:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210712162917-arm_power_relaxed_memory_model/</guid>
      <description>ARM和POWER系统的概念模型是，每个处理器从其自己的完整内存副本中读取和向其写入，每个写入独立地传播到其他处理器，随着写入的传播，允许重新排序。
在这个宽松的(relaxed)模型中，我们迄今为止所看到的每一个litmus test的答案都是“yes，这真的可能发生。”
Litmus Test: Message Passing Can this program see r1 = 1, r2 = 0? // Thread 1 // Thread 2 x = 1 r1 = y y = 1 r2 = x On sequentially consistent hardware: no. On x86 (or other TSO): no. On ARM/POWER: yes! Litmus Test: Store Buffering Can this program see r1 = 0, r2 = 0? // Thread 1 // Thread 2 x = 1 y = 1 r1 = y r2 = x On sequentially consistent hardware: no.</description>
    </item>
    
    <item>
      <title>内存屏障</title>
      <link>https://notes.0081800.xyz/notes/20210712162102-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/</link>
      <pubDate>Mon, 12 Jul 2021 16:21:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210712162102-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/</guid>
      <description>内存屏障（或栅栏）是非顺序一致性的硬件提供的一种显式指令，用于控制排序提供更强的内存排序，修复同步算法。
添加内存屏障，确保每个线程在开始读取之前都会刷新其先前对内存的写入：
// Thread 1 // Thread 2 x = 1 y = 1 barrier barrier r1 = y r2 = x x86 总存储有序（x86-TSO) 加上内存屏障之后 r1=0, r2=0 就会变得不可能。</description>
    </item>
    
    <item>
      <title>x86 总存储有序（x86-TSO)</title>
      <link>https://notes.0081800.xyz/notes/20210712155827-x86_%E6%80%BB%E5%AD%98%E5%82%A8%E6%9C%89%E5%BA%8F_x86_tso/</link>
      <pubDate>Mon, 12 Jul 2021 15:58:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210712155827-x86_%E6%80%BB%E5%AD%98%E5%82%A8%E6%9C%89%E5%BA%8F_x86_tso/</guid>
      <description>x86 总存储有序(x86 Total Store Order, x86-TSO)：所有处理器仍然连接到一个共享内存，但是每个处理器都将对该内存的写入(write)放入到本地写入队列中。处理器继续执行新指令，同时写操作(write)会更新到这个共享内存。一个处理器上的内存读取在查询主内存之前会查询本地写队列，但它看不到其他处理器上的写队列。其效果就是当前处理器比其他处理器会先看到自己的写操作。
重要的是： 所有处理器都保证写入（存储 store）到共享内存的（总）顺序，所以给这个模型起了个名字：总存储有序（Total Store Order，TSO）。
写队列是一个标准的先进先出队列：内存写操作总是以与处理器执行相同顺序的应用于共享内存。
基于以上下面 litmus test 的答案依然是 no ，这种情况与顺序一致性模型结果一致：
Litmus Test: Message Passing Can this program see r1 = 1, r2 = 0? // Thread 1 // Thread 2 x = 1 r1 = y y = 1 r2 = x On sequentially consistent hardware: no. On x86 (or other TSO): no. 但其他测试则并不一致区分与顺序一致性的常用例子:
Litmus Test: Write Queue (also called Store Buffer) Can this program see r1 = 0, r2 = 0?</description>
    </item>
    
    <item>
      <title>litmus test</title>
      <link>https://notes.0081800.xyz/notes/20210712153952-litmus_test/</link>
      <pubDate>Mon, 12 Jul 2021 15:39:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210712153952-litmus_test/</guid>
      <description>下面这种关于样本结果的问题被称为 litmus test 。它只有两个答案：可能还是不可能？为我们提供了一种区分内存一致性模型的清晰方法：如果一个模型支持特定的执行，而另一个不支持，那么这两个模型显然不同。
litmus test 假设所有变量都初始为 0 ， rN 表示非共享变量，而是一个线程本地寄存器。
Litmus Test: Message Passing Can this program see r1 = 1, r2 = 0? // Thread 1 // Thread 2 x = 1 r1 = y y = 1 r2 = x 然而不幸的是，一个特定的模型对一个特定的 litmus test 给出的答案往往令人惊讶。</description>
    </item>
    
    <item>
      <title>顺序一致性</title>
      <link>https://notes.0081800.xyz/notes/20210712151942-%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7/</link>
      <pubDate>Mon, 12 Jul 2021 15:19:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210712151942-%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7/</guid>
      <description>Leslie Lamport 1979 年的论文 How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs 定义：
The customary approach to designing and proving the correctness of multiprocess algorithms for such a computer assumes that the following condition is satisfied: the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program.</description>
    </item>
    
    <item>
      <title>内存一致性模型</title>
      <link>https://notes.0081800.xyz/notes/20210712150516-%E5%86%85%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 12 Jul 2021 15:05:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210712150516-%E5%86%85%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/</guid>
      <description> tags: 一致性，Memory Model 当执行给定程序时，硬件和编译器之间的契约，对编译后后的代码对存储在内存中的数据更改的可见性和一致性。 这种契约称为「内存一致性模型（Memeory Consistency Model）」或仅仅是「内存模型（Memory Model）」。
最初目标是定义程序员编写汇编代码时硬件提供的保证，后来用来定义高级编程语言（如 C++ 或 Java）对该语言编写代码的程序员提供的保证。
例如下面变量都初始为 0 的情况下，线程 1 和 2 都运行在自己专用的处理器上，都运行到完成，这个程序能打印 0 吗？
// Thread 1 // Thread 2 x = 1; while(done == 0) { /* loop */ } done = 1; print(x); Memory coherence vs consistency 内存一致性（coherence） 内存顺序一致性（sequential consistency） 硬件 顺序一致性 x86 总存储有序（x86-TSO) ARM/POWER Relaxed Memory Model 弱有序和无数据竞争（DRF） 编程语言内存模型 </description>
    </item>
    
    <item>
      <title>硬件内存模型</title>
      <link>https://notes.0081800.xyz/notes/20210712143220-%E7%A1%AC%E4%BB%B6%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 12 Jul 2021 14:32:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210712143220-%E7%A1%AC%E4%BB%B6%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description>tags: Memory Model,Computer Systems Hardware Memory Models 硬件内存模型 内存模型 内存一致性模型</description>
    </item>
    
    <item>
      <title>Emacs 优化启动速度</title>
      <link>https://notes.0081800.xyz/notes/20210712114303-emacs_%E4%BC%98%E5%8C%96%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6/</link>
      <pubDate>Mon, 12 Jul 2021 11:43:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210712114303-emacs_%E4%BC%98%E5%8C%96%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6/</guid>
      <description> tags: Emacs 优化 GC 参考：LSP Mode Performance
;; Optmization ;; Sources: ;; ;; - https://www.reddit.com/r/emacs/comments/ofhket/further_boost_start_up_time_with_a_simple_tweak/ ;; - https://emacs-lsp.github.io/lsp-mode/page/performance/ ;; (setq gc-cons-threshold 32000000) ;; 32mb (setq read-process-output-max (* 1024 1024)) ;; 1mb 将启动速度优化到 3 秒左右。
Dumping Emacs Emacs WIKI: Dumping Emacs Painless Transition to Portable Dumper </description>
    </item>
    
    <item>
      <title>动态再平衡策略</title>
      <link>https://notes.0081800.xyz/notes/20210712072221-%E5%8A%A8%E6%80%81%E5%86%8D%E5%B9%B3%E8%A1%A1%E7%AD%96%E7%95%A5/</link>
      <pubDate>Mon, 12 Jul 2021 07:22:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210712072221-%E5%8A%A8%E6%80%81%E5%86%8D%E5%B9%B3%E8%A1%A1%E7%AD%96%E7%95%A5/</guid>
      <description>为什么不用取模？ 节点数发生变化时，会导致很多关键字需要做节点数据迁移，会大大增加再平衡的成本。
固定数量的分区 创建远超实际节点数的分区数量，然后再为每个节点分配多个分区。
新加入节点 从现有的节点上匀走几个分区，直到分区再次达到平衡。
删除节点 采取和上面相反的过程。
优点 分区总数量不变，也不会改变关键字的分区映射关系。 唯一需要调整的分区与节点的映射关系。 分区和节点的映射关系调整可以逐步完成。 缺点 分区数量需要数据库创建时确定，并不能更改 动态分区 分区数据增长超过一个可配参数的阈值（HBase 10GB），它就拆分为两个分区，相反则合并相邻的分区。过程类似B-trees 的分裂操作。
每个分区总是分配一个节点，一个节点可以承载多个分区。
分区分裂 将其中的一半转移到其他节点以平衡负载。
优点 分区数量可以自动适配数据总量。 空数据库可以配置初始分区解决少量数据集就一个分区避免系统热点（HBase 和 MongoDB） 按节点比例分区 使分区数与集群节点数成正比关系（Cassandra 和 Ketama），就是每个节点具有固定数量的分区。 当节点数不变时，每个分区的大小与数据集大小保持正比增长关系。
新加入节点 随机选择固定数量的现有分区进行分裂，然后拿走这些分区的一半数据量。
优点 较大的数据可以使每个分区的大小保持稳定。 缺点 存在不公平分裂。 </description>
    </item>
    
    <item>
      <title>基于词条的二级索引分区</title>
      <link>https://notes.0081800.xyz/notes/20210712071502-%E5%9F%BA%E4%BA%8E%E8%AF%8D%E6%9D%A1%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%88%86%E5%8C%BA/</link>
      <pubDate>Mon, 12 Jul 2021 07:15:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210712071502-%E5%9F%BA%E4%BA%8E%E8%AF%8D%E6%9D%A1%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%88%86%E5%8C%BA/</guid>
      <description>对所有数据构建全局索引，为了避免瓶颈，对索引本身进行分区，比如：
将 a～r 开始的关键字放在分区 0 将 s～z 开始的关键字放在分区 1 优点 可以支持高效的区间查询 读取更为高效 缺点 写入速度慢，会引入明显的写入放大 写入逻辑复杂 难以保证索引时刻最新，需要跨多个相关分区的分布式事务支持 实践 对全局二级索引的更新往往都是异步的。</description>
    </item>
    
    <item>
      <title>基于文档分区的二级索引</title>
      <link>https://notes.0081800.xyz/notes/20210712071105-%E5%9F%BA%E4%BA%8E%E6%96%87%E6%A1%A3%E5%88%86%E5%8C%BA%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Mon, 12 Jul 2021 07:11:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210712071105-%E5%9F%BA%E4%BA%8E%E6%96%87%E6%A1%A3%E5%88%86%E5%8C%BA%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95/</guid>
      <description>每个分区各自维护自身的二级索引，读取时需要对所有分区节点进行查询然后对结果进行合并。
这种方法虽然二级索引查询代价高，但依然广泛用于实践：MongoDB、Riak、Cassandra、ElasticSearch、SolrCloud 和 VoltDB。</description>
    </item>
    
    <item>
      <title>基于关键字哈希值分区</title>
      <link>https://notes.0081800.xyz/notes/20210711171149-%E5%9F%BA%E4%BA%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%93%88%E5%B8%8C%E5%80%BC%E5%88%86%E5%8C%BA/</link>
      <pubDate>Sun, 11 Jul 2021 17:11:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210711171149-%E5%9F%BA%E4%BA%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%93%88%E5%B8%8C%E5%80%BC%E5%88%86%E5%8C%BA/</guid>
      <description>可以基于关键值哈希函数的方式分区，解决基于关键字区间分区数据倾斜与热点的问题。一个好的哈希函数可以处理数据倾斜并使其均匀分布，并且不需要在加密方面很强。
优点 这种方法可以很好的将关键字均匀分配到多个分区中。
缺点 丧失良好的区间查询性能。即使关键字相邻，也会分布在不同的分区上。</description>
    </item>
    
    <item>
      <title>基于关键字区间分区</title>
      <link>https://notes.0081800.xyz/notes/20210711154220-%E5%9F%BA%E4%BA%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%8C%BA%E9%97%B4%E5%88%86%E5%8C%BA/</link>
      <pubDate>Sun, 11 Jul 2021 15:42:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210711154220-%E5%9F%BA%E4%BA%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%8C%BA%E9%97%B4%E5%88%86%E5%8C%BA/</guid>
      <description>为每个分区分配一段连续的关键字或者关键字区间范围。</description>
    </item>
    
    <item>
      <title>系统热点</title>
      <link>https://notes.0081800.xyz/notes/20210711153934-%E7%B3%BB%E7%BB%9F%E7%83%AD%E7%82%B9/</link>
      <pubDate>Sun, 11 Jul 2021 15:39:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210711153934-%E7%B3%BB%E7%BB%9F%E7%83%AD%E7%82%B9/</guid>
      <description>负载倾斜会导致所有负载都集中在一个分区节点上，这种负载严重不成比例的分区即称为系统热点。
应用层解决 即使通过基于关键字哈希值分区和基于关键字区间分区等策略解决了大部分热点问题，但是极端情况下依然会出现热点，比如社交媒体的热点时间都会导致热点，只能通过应用层解决，一个简单的技术：
关键字开头或结尾添加一个随机数，两位随机数就可以将关键字的写操作分布到 100 个不同的分区上； 读取就必须从所有的 1000 个关键字中读取数据然后进行合并； 通过额外的元数据标记哪些关键字进行了特殊处理。 由于对读取造成的额外开销，所以通常只有对少量的热点关键词附加随机数才有意义。</description>
    </item>
    
    <item>
      <title>负载倾斜</title>
      <link>https://notes.0081800.xyz/notes/20210711153606-%E8%B4%9F%E8%BD%BD%E5%80%BE%E6%96%9C/</link>
      <pubDate>Sun, 11 Jul 2021 15:36:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210711153606-%E8%B4%9F%E8%BD%BD%E5%80%BE%E6%96%9C/</guid>
      <description>分区不均匀时出现某些分区节点比其他分区承担更多的数据量和查询负载。倾斜会导致分区效率严重下降。</description>
    </item>
    
    <item>
      <title>数据分区</title>
      <link>https://notes.0081800.xyz/notes/20210711153015-%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA/</link>
      <pubDate>Sun, 11 Jul 2021 15:30:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210711153015-%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA/</guid>
      <description>每一条数据都属于特定的分区，每个分区都是一个小型数据库。
目的 提高扩展性，分散大的数据集和查询负载。
目标 将数据和查询负载均匀的分步在所有节点上。如果分布不均匀会出现负载倾斜和系统热点。
数据分区与数据复制 结合数据复制每个分区在多个节点都有副本，进行冗余提高可用性。
键-值数据的分区 避免系统热点最简单的方法是将记录随机分配给所有节点上，缺点是：没办法知道数据保存在哪个节点上，所以读取时需要查询所有节点。
基于关键字区间分区 基于关键字哈希值分区 负载倾斜与系统热点 分区与二级索引 二级索引不能唯一标识一条记录，比如查询颜色为红色的汽车。二级索引带来的主要挑战是它们不能规整的映射到分区中。
有两种方法来支持对二级索引进行分区：
基于文档分区的二级索引 基于词条的二级索引分区 分区再平衡 动态再平衡策略 自动与手动再平衡操作 请求路由 策略 客户端可以连接任意节点，并由节点做转发不在当前节点的分区请求。 由路由层来充当分区感知的负载均衡器。 客户端直接感知分区和节点分配关系，客户端直连目标节点。 做出路由决策的组件 Zookeeper gossip 协议 </description>
    </item>
    
    <item>
      <title>syn</title>
      <link>https://notes.0081800.xyz/notes/20210616144616-syn/</link>
      <pubDate>Wed, 16 Jun 2021 14:46:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210616144616-syn/</guid>
      <description> syn::Span 代码位置 </description>
    </item>
    
    <item>
      <title>quote</title>
      <link>https://notes.0081800.xyz/notes/20210616144334-quote/</link>
      <pubDate>Wed, 16 Jun 2021 14:43:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210616144334-quote/</guid>
      <description>循环展开 let fields = vec![ syn::Ident::new(&amp;#34;foo&amp;#34;, syn::Span::call_site()), syn::Ident::new(&amp;#34;bar&amp;#34;, syn::Span::call_site()), ]; let token = quote!{ #(#fields),* }; // -&amp;gt; foo,bar </description>
    </item>
    
    <item>
      <title>Rust 属性宏解析</title>
      <link>https://notes.0081800.xyz/notes/20210616141500-rust_%E5%B1%9E%E6%80%A7%E5%AE%8F%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 16 Jun 2021 14:15:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210616141500-rust_%E5%B1%9E%E6%80%A7%E5%AE%8F%E8%A7%A3%E6%9E%90/</guid>
      <description>准备 解析宏通过两个 crate 进行：
quote = &amp;ldquo;1.0&amp;rdquo; syn = &amp;ldquo;1.0&amp;rdquo; Derive 属性宏 探讨 Rust 宏系统中带属性（Attributes）的 Derive 宏的几种变体，以及如何进行解析。
属性宏的变体 函数调用
#[derive(Custom)] struct Demo { #[attr(arg)] a: i8, } 关键字参数调用
#[derive(Custom)] struct Demo { #[args(name = &amp;#34;val&amp;#34;)] b: i8, } 直接赋值
#[derive(Custom)] struct Demo { #[meta = &amp;#34;val&amp;#34;] c: i8, } 函数调用 关键字参数调用 可以从 Struct 解析出各个字段，通过解析各个字段的 attrs 属性，并对 attrs 进行遍历，使用 attr.parse_args()? 即可解析出对应的关键字参数，咱们以前面的代码为例:
#[derive(Custom)] struct Demo { #[args(name = &amp;#34;val&amp;#34;)] b: i8, } 对应的解析代码为：</description>
    </item>
    
    <item>
      <title>Happens-before 关系和并发</title>
      <link>https://notes.0081800.xyz/notes/20210615215426-happens_before_%E5%85%B3%E7%B3%BB%E5%92%8C%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Tue, 15 Jun 2021 21:54:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210615215426-happens_before_%E5%85%B3%E7%B3%BB%E5%92%8C%E5%B9%B6%E5%8F%91/</guid>
      <description>确定前后关系 服务器为每个主键维护一个版本号，每当主键新值写入时递增版本号，并将新版本号与写入值一起保存。 当客户端读取主键时，服务器将返回所有（未被覆盖的）当前值以及最新的版本号。且要求写入之前，客户端必须先发送读请求。 客户端写主键，写请求必须包含之前读到的版本号，读到的值和新值合并后的集合。写请求的响应可以像读操作一样，会返回所有当前值，这样可以一步步链接起多个写入的值。 当服务器收到带有特定版本号的写入时，覆盖该版本号或者更低版本的所有值，但必须保存更高版本号所有值。 当写请求包含了前一次读取的版本号时，意味着修改时基于以前的状态。否则它将与所有的其他写入同时进行，不会覆盖任何已有值，其传入的值将包含在后续读请求的返回值列表中。
合并同时写入的值 上面算法不会导致数据丢失，但是客户端需要做一些额外的工作：如果多个操作并发发生，则客户端必须通过合并并发写入的值来继承旧值。同时删除需要特殊的墓碑标记，防止被合并回去。
版本矢量 每个副本和每个主键均定义一个版本号，每个副本在处理时增加自己的版本号，并跟踪从其他副本看到的版本号。通过这些信息来指示要覆盖那些值，该保留那些并发值。
所有的版本号集合称为版本矢量。</description>
    </item>
    
    <item>
      <title>检测并发写</title>
      <link>https://notes.0081800.xyz/notes/20210615213433-%E6%A3%80%E6%B5%8B%E5%B9%B6%E5%8F%91%E5%86%99/</link>
      <pubDate>Tue, 15 Jun 2021 21:34:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210615213433-%E6%A3%80%E6%B5%8B%E5%B9%B6%E5%8F%91%E5%86%99/</guid>
      <description>LWW：最后写入者获胜 Happens-before 关系和并发 </description>
    </item>
    
    <item>
      <title>sloppy quorum</title>
      <link>https://notes.0081800.xyz/notes/20210615212500-sloppy_quorum/</link>
      <pubDate>Tue, 15 Jun 2021 21:25:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210615212500-sloppy_quorum/</guid>
      <description>当节点不能满足 \(w + r &amp;gt; n\) 时将写请求暂时写入一些可访问的临时节点中，一旦网络问题得到交接，临时节点需要把接收的写入全部发送到原始主节点上。这就是所谓的数据回传（或者暗示移交）。</description>
    </item>
    
    <item>
      <title>Quorum 一致性</title>
      <link>https://notes.0081800.xyz/notes/20210615211745-quorum_%E4%B8%80%E8%87%B4%E6%80%A7/</link>
      <pubDate>Tue, 15 Jun 2021 21:17:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210615211745-quorum_%E4%B8%80%E8%87%B4%E6%80%A7/</guid>
      <description> tags: 一致性 确定读写成功 确定读写节点在多少节点成功才可以认为写入成功：需要保证读取时至少一个包含新值。
n 个副本的情况下，写入需要 \(w\) 个节点确认，读取必须至少查询 \(r\) 个节点，则只要 \(w + r &amp;gt; n\) ，读取的节点中一定会包含最新值。
\(w\) 仲裁写（法定票数写） \(r\) 仲裁读（法定票说读） 一般 \(n\) 设置为奇数： \(w=r=(n+1)/2\) （向上取整）。
可容忍的失效节点数 仲裁条件 \(w+r&amp;gt;n\) 定义了系统可容忍的失效节点数。
\(w&amp;lt;n\) ，如果一个节点不可用，仍然可以处理写入。 \(r&amp;lt;n\) ，如果一个节点不可用，仍然可以处理读取。 \(n=3\),\(w=2\),\(r=2\)，则可以容忍一个节点不可用 \(n=5\),\(w=3\),\(r=3\), 则可以容忍两个节点不可用 局限性 如果采用了 sloppy quorum，写操作的 w 节点和读取的 r 节点可能完全不同，因此无法保证写请求一定存在重叠的节点。 并发无法明确顺序，需要进行合并并发写入。如最后写入者获胜。 同时读写，写操作在一部分节点上完成，则读取新值还是旧值存在不确定性。 部分节点写入成功，但是最终写入失败无法回滚。 新值的节点失效，但恢复数据来自某个旧值，则总的新值节点数低于 w 边界情况 </description>
    </item>
    
    <item>
      <title>无主节点复制</title>
      <link>https://notes.0081800.xyz/notes/20210615210219-%E6%97%A0%E4%B8%BB%E8%8A%82%E7%82%B9%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Tue, 15 Jun 2021 21:02:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210615210219-%E6%97%A0%E4%B8%BB%E8%8A%82%E7%82%B9%E5%A4%8D%E5%88%B6/</guid>
      <description>没有主节点，允许任何节点接受来自客户端的写请求。
实现方式 客户端直接将其写请求发送到多节点 一个协调者代表客户端进行写入，与主节点的数据库不同，协调者并不负责写入顺序的维护。 节点失效时写入数据库 客户端将写请求并行发送给三个节点，两个可用节点接受写请求，而不可用副本则无法处理该请求。
现在失效的节点重新上线，客户端可能会读取到旧的值。
为了解决这个问题客户端并行的向多个节点发送读请求，并通过版本号来确定哪个值更新。
读修复与反熵 读修复；客户端并行读取多个节点，检测到过期的返回值，然后用新的返回值写入到返回旧值的副本。 反熵过程：后台不断查找副本之间的差异，将任何缺少的数据从一个节点复制到另一个节点。不保证特定顺序的复制写入，并且会引入明显的复制滞后问题。 Quorum 一致性 检测并发写 </description>
    </item>
    
    <item>
      <title>全部-至-全部型拓扑</title>
      <link>https://notes.0081800.xyz/notes/20210615084309-%E5%85%A8%E9%83%A8_%E8%87%B3_%E5%85%A8%E9%83%A8%E5%9E%8B%E6%8B%93%E6%89%91/</link>
      <pubDate>Tue, 15 Jun 2021 08:43:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210615084309-%E5%85%A8%E9%83%A8_%E8%87%B3_%E5%85%A8%E9%83%A8%E5%9E%8B%E6%8B%93%E6%89%91/</guid>
      <description>最常见的拓扑结构，提供更好的容错。每个节点从其他所有节点同步写入。</description>
    </item>
    
    <item>
      <title>星型拓扑</title>
      <link>https://notes.0081800.xyz/notes/20210615084143-%E6%98%9F%E5%9E%8B%E6%8B%93%E6%89%91/</link>
      <pubDate>Tue, 15 Jun 2021 08:41:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210615084143-%E6%98%9F%E5%9E%8B%E6%8B%93%E6%89%91/</guid>
      <description>通过指定一个根节点，根结点将所有的写操作转发给其他所有节点。</description>
    </item>
    
    <item>
      <title>环形拓扑</title>
      <link>https://notes.0081800.xyz/notes/20210615084010-%E7%8E%AF%E5%BD%A2%E6%8B%93%E6%89%91/</link>
      <pubDate>Tue, 15 Jun 2021 08:40:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210615084010-%E7%8E%AF%E5%BD%A2%E6%8B%93%E6%89%91/</guid>
      <description>每个节点接收来自前序节点的写入，并将这些写入（加上字节的写入）转发后后序节点。同时通过唯一 ID 防止无限循环。</description>
    </item>
    
    <item>
      <title>最后写入者获胜</title>
      <link>https://notes.0081800.xyz/notes/20210615083500-%E6%9C%80%E5%90%8E%E5%86%99%E5%85%A5%E8%80%85%E8%8E%B7%E8%83%9C/</link>
      <pubDate>Tue, 15 Jun 2021 08:35:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210615083500-%E6%9C%80%E5%90%8E%E5%86%99%E5%85%A5%E8%80%85%E8%8E%B7%E8%83%9C/</guid>
      <description>每个副本总是保存最新值，允许覆盖并丢弃旧值。假定每个写请求都最终同步到所有副本，只要我们有一个明确的方法来确定哪个写入时最新的，则副本可以最终收敛到相同的值。
通过每个请求附加一个时间戳，选择最新即最大的时间戳，丢弃较早的写入。则为最后写入着获胜（last write wins，LWW）。
缺点 会造成数据丢失。
适用场景 缓存系统。 确保安全无副作用 唯一方法是只写入一次然后写入值视为不可变，这样旧避免对同一个主键的并发（覆盖）写。</description>
    </item>
    
    <item>
      <title>收敛于一致的状态</title>
      <link>https://notes.0081800.xyz/notes/20210615083221-%E6%94%B6%E6%95%9B%E4%BA%8E%E4%B8%80%E8%87%B4%E7%9A%84%E7%8A%B6%E6%80%81/</link>
      <pubDate>Tue, 15 Jun 2021 08:32:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210615083221-%E6%94%B6%E6%95%9B%E4%BA%8E%E4%B8%80%E8%87%B4%E7%9A%84%E7%8A%B6%E6%80%81/</guid>
      <description>多个主节点看到的执行顺序不一致，病了同时按照各自看到的写入顺序执行，那么数据库最终将处于不一致状态。
数据库必须以一种趋同的方式来解决冲突。
可能的解决方式 给每个写入分配唯一的 ID，如基于时间戳的最后写入者获胜。 为每个主节点分配一个唯一 ID，序列号高的优先于序列号低的主节点，可能导致数据丢失 以某种方式合并值，如按照字母顺序拼接在一起 利用预定义号的格式记录，然后依靠应用层逻辑，事后解决冲突（可能会提示用户） </description>
    </item>
    
    <item>
      <title>避免冲突</title>
      <link>https://notes.0081800.xyz/notes/20210615082908-%E9%81%BF%E5%85%8D%E5%86%B2%E7%AA%81/</link>
      <pubDate>Tue, 15 Jun 2021 08:29:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210615082908-%E9%81%BF%E5%85%8D%E5%86%B2%E7%AA%81/</guid>
      <description>应用层保证对特定记录的写请求总是通过同一个主节点，来避免发生些冲突。
如用户更新自己的配置总是路由到特定的数据中心。
缺点 特定数据中心发生故障不得不改变事先指定的主节点。</description>
    </item>
    
    <item>
      <title>前缀一致读</title>
      <link>https://notes.0081800.xyz/notes/20210614211632-%E5%89%8D%E7%BC%80%E4%B8%80%E8%87%B4%E8%AF%BB/</link>
      <pubDate>Mon, 14 Jun 2021 21:16:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210614211632-%E5%89%8D%E7%BC%80%E4%B8%80%E8%87%B4%E8%AF%BB/</guid>
      <description>对于一系列按照某个顺序发生的写请求，同时读取这些内容时也会按照当时写入的顺序。
场景 分区数据库中出现的一个特殊问题。
正常对话：
P: C小姐，你能看到多远的文莱？
C：大约 10s，P 先生。
但是由于复制滞后，最终能被观察到的可能是：
C：大约 10s，P 先生。
P: C小姐，你能看到多远的文莱？
解决方案 低效率：具有因果关系的写入都交给一个分区来完成。 新方法：跟踪事件因果关系。</description>
    </item>
    
    <item>
      <title>单调读一致性</title>
      <link>https://notes.0081800.xyz/notes/20210614210918-%E5%8D%95%E8%B0%83%E8%AF%BB%E4%B8%80%E8%87%B4%E6%80%A7/</link>
      <pubDate>Mon, 14 Jun 2021 21:09:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210614210918-%E5%8D%95%E8%B0%83%E8%AF%BB%E4%B8%80%E8%87%B4%E6%80%A7/</guid>
      <description>是一种比强一致性弱但是比最终一致性效应强的保证，单调读保证：
如果某个用户依次进行多次读取，则绝不会看到回滚的现象，即在读取到较新的值之后又发生读旧值的情况。
场景 用户刷新网络，读请求被随机路由到某个从节点，先后从两个不同的从节点读取到了不同的内容，比如看到一个新添加的评论一次出现，一次消失。
解决方案 按照用户 ID 进行哈希方法取代随机路由。</description>
    </item>
    
    <item>
      <title>强一致性</title>
      <link>https://notes.0081800.xyz/notes/20210614210953-%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7/</link>
      <pubDate>Mon, 14 Jun 2021 21:09:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210614210953-%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7/</guid>
      <description></description>
    </item>
    
    <item>
      <title>读写一致性</title>
      <link>https://notes.0081800.xyz/notes/20210614210755-%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/</link>
      <pubDate>Mon, 14 Jun 2021 21:07:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210614210755-%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/</guid>
      <description>也称为「写后读一致性」，解决用户主节点写入后立马从从节点读取不到到情况。只能解决单用户的一致性，但是解决不了多用户的一致性。
场景 用户新提交了评论，但是自己看不到，需要等一会才能看到。
解决方案 记录更新时间戳，在指定时间内从主节点读取。</description>
    </item>
    
    <item>
      <title>最终一致性效应</title>
      <link>https://notes.0081800.xyz/notes/20210614210005-%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E6%95%88%E5%BA%94/</link>
      <pubDate>Mon, 14 Jun 2021 21:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210614210005-%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E6%95%88%E5%BA%94/</guid>
      <description>主从异步复制的情况下会导致数据库中出现明显不一致，此时从不同的从节点读取就会得到不一样的结果。这种不一致只是一个暂时状态，如果停止写入数据，经过一段时间之后，从节点最终会赶上并与主节点保持一致。
这种效应被称为最终一致性。</description>
    </item>
    
    <item>
      <title>复制滞后问题</title>
      <link>https://notes.0081800.xyz/notes/20210614205621-%E5%A4%8D%E5%88%B6%E6%BB%9E%E5%90%8E%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 14 Jun 2021 20:56:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210614205621-%E5%A4%8D%E5%88%B6%E6%BB%9E%E5%90%8E%E9%97%AE%E9%A2%98/</guid>
      <description>异步同步的情况下出出现最终一致性效应复制滞后会导致：用户提交了修改到主节点，但是从从节点没有读取到最新的变更，比如看不到自己提交的评论等。
读写一致性：读自己的写 一旦用户的数据最近发生改变则路由用户请求从主节点进行读取，规避复制滞后的问题。
缺点：只保证单一用户写后读的的一致性，但是不保证多个用户的一致性。比如发了一条评论，自己能刷新到但是同在身边的朋友可能就刷新不到。
单调读一致性 前缀一致读 解决方案 应用层可以提供比数据库更强有力的保证。 事务是数据库提供的更强保证的一种方式。 </description>
    </item>
    
    <item>
      <title>复制日志实现</title>
      <link>https://notes.0081800.xyz/notes/20210614205249-%E5%A4%8D%E5%88%B6%E6%97%A5%E5%BF%97%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 14 Jun 2021 20:52:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210614205249-%E5%A4%8D%E5%88%B6%E6%97%A5%E5%BF%97%E5%AE%9E%E7%8E%B0/</guid>
      <description>基于语句复制 优点：简单 缺点：语句副作用，或者随时间改变返回值的函数的使用会导致复制的数据产生改变。
基于预写日志（WAL）传输 优点：解决基于语句复制的问题。 缺点：日志描述过于底层：哪些磁盘块的哪些字节发生了改变，和引擎实现高度耦合，不利于模式演进。
基于行的逻辑日志复制 用一系列记录来描述数据表行级别的写请求：
对于插入行，日志包含所有相关列的新值。 对于删除行，标记主键删除。 对于行货更新，记录主键和对应列的新值。 MySQL binlog 基于此模式。
优点：更利于模式演进，支持向后兼容，同时解耦特性引擎便于外部解析。
基于触发器的复制 触发器支持注册自己的应用层代码并在数据发生改变时被调用。
优点：将复制控制交给应用层，支持更高的灵活性。 缺点：开销更大，更容易出错。</description>
    </item>
    
    <item>
      <title>主从复制</title>
      <link>https://notes.0081800.xyz/notes/20210614203213-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Mon, 14 Jun 2021 20:32:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210614203213-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</guid>
      <description>主从模式下主节点进行写入，可以从从节点进行读取。
同步复制 主节点写入，并等待从节点写入后再返回写入成功。
半同步复制 主节点写入，选举一个从节点进行同步复制，其他从节点进行异步复制，一旦同步复制的从节点出现性能下降或故障则选用一个新的从节点进行同步复制。
异步复制 主节点写入，不等待从节点写入直接返回写入成功。</description>
    </item>
    
    <item>
      <title>数据复制</title>
      <link>https://notes.0081800.xyz/notes/20210614203122-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Mon, 14 Jun 2021 20:31:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210614203122-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/</guid>
      <description>主节点与从节点 复制 单个节点可以完整存放所有数据副本，节点间进行主从复制。
配置新从节点 可以通过快照来加速新从节点复制：
对主节点的数据副本产生一个一致性快照，避免长时间锁定数据库。 拷贝快照到从节点 请求快照后面的更改日志 应用数据变更 节点失效 从节点失效：追赶式恢复 主节点失效：节点切换 自动切换
确认失效 选举新的主节点 使主节点生效 挑战
从节点复制不完整 各个数据层数据不一致，如 MySQL 和 Redis 之间 多个主节点选举：脑裂 如何有效检测主节点失效 复制日志实现 复制滞后问题 多主节点复制 使用场景 多数据中心 优点：
性能 容忍数据中心失效 容忍网络问题 缺点：写冲突
离线客户端操作 协作编辑 处理写冲突 同步与异步冲突检测 同步：等待写请求完成对所有主节点的同步再通知用户写入成功。 异步：等待单一主节点写入成功后通知用户卸乳成功，稍后多主节点数据同步的时候才能检测到冲突 避免冲突 收敛于一致的状态 自定义冲突解决逻辑 写入时解决 读取时解决 拓扑结构 环形拓扑 星型拓扑 全部-至-全部型拓扑 无主节点复制 </description>
    </item>
    
    <item>
      <title>认同的话</title>
      <link>https://notes.0081800.xyz/notes/20210612092853-%E8%AE%A4%E5%90%8C%E7%9A%84%E8%AF%9D/</link>
      <pubDate>Sat, 12 Jun 2021 09:28:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210612092853-%E8%AE%A4%E5%90%8C%E7%9A%84%E8%AF%9D/</guid>
      <description>当一个不可能出错的事物出错了，通常也就意味着不可修复 &amp;ndash; Douglas Adams，《基本无害》（1992） 关于写文档 There is a secret that needs to be understood in order to write good software documentation: there isn’t one thing called documentation, there are four.
They are: tutorials, how-to guides, technical reference and explanation. They represent four different purposes or functions, and require four different approaches to their creation. Understanding the implications of this will help improve most documentation - often immensely.</description>
    </item>
    
    <item>
      <title>Actor</title>
      <link>https://notes.0081800.xyz/notes/20210612091808-actor/</link>
      <pubDate>Sat, 12 Jun 2021 09:18:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210612091808-actor/</guid>
      <description>Actor 模型是用于单个进程中的并发模型。逻辑被封装在 Actor 中。每个 Actor 通常代表一个客户端或实体，可以具备本地状态（不共享），通过发送和接收异步消息与其他 Actor 通信。不保证消息传送：某些错误情况下，消息将丢失。每个 Actor 只处理一条消息，因此可以由框架独立调度。
Actor 框架集成了任务调度和消息流的框架。</description>
    </item>
    
    <item>
      <title>Avro</title>
      <link>https://notes.0081800.xyz/notes/20210610222725-avro/</link>
      <pubDate>Thu, 10 Jun 2021 22:27:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210610222725-avro/</guid>
      <description>两种模式语言：IDL 用于人工编辑，另一种更易于机器读取。
Avro 编码数据中只有对应字段的长度和具体的数据，不包含字段的类型信息。
写模式与读模式 写模式：使用所知道的模式的任何版本来编码数据（可以编译到代码中） 读模式：解码时期望数据符合某个模式，可能是构建过程中基于模式生成 Avro 的关键思想是写模式和读不必完全一样，只需要保持兼容，由读取端解决差异：通过对比查看写模式和读模式并将数据从写模式转换为读模式。
读取数据的代码中遇到出现在写模式但是不在读模式的字段，则忽略。 如果读数据的带代码需要某个字段，但是写模式不包含该字段的名称，则使用在读模式中声明的默认值填充。 模式演化 向前兼容：新版本的模式作为 writer，旧版本的模式作为 reader。 向后兼容：新版本的模式作为 reader，旧版本的模式作为 writer。 同时为了保持兼容性，只能添加莫删除具有默认值的字段。</description>
    </item>
    
    <item>
      <title>Thrift 与 Protocol Buffers</title>
      <link>https://notes.0081800.xyz/notes/20210610222754-thrift_%E4%B8%8E_protocol_buffers/</link>
      <pubDate>Thu, 10 Jun 2021 22:27:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210610222754-thrift_%E4%B8%8E_protocol_buffers/</guid>
      <description>每个字段一个标记号码，字段名可以随意调整因为编码信息中只有标记号码，没有字段名称，但是标记号码不能随意调整，基于此可以实现：
向前兼容 旧代码忽略不能识别的标记号码，并根据类型的注释来通知解析器跳过特定的字节数。 向后兼容 标记号码不变的情况下新的代码总是能够解析旧代码序列化的数据，但是新添加的字段不能标记为 required，不然会触发运行时错误。 同时为了保证前后兼容，删除字段也不能删除设置为 required 的字段，同时再次新添字段标记号码不能被再次使用。
改变类型同时也会导致前后兼容问题。</description>
    </item>
    
    <item>
      <title>数据编码与演化</title>
      <link>https://notes.0081800.xyz/notes/20210610215330-%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E4%B8%8E%E6%BC%94%E5%8C%96/</link>
      <pubDate>Thu, 10 Jun 2021 21:53:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210610215330-%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E4%B8%8E%E6%BC%94%E5%8C%96/</guid>
      <description>模式演化要保证：
向后兼容 较新的代码可以读取旧代码编写的数据 向前兼容 较旧的代码可以读取较新代码编写的数据 数据编码格式 语言特定格式 Python pickle Java java.io.Serializable Ruby Marshal JSON、XML与二进制变体 二进制变体
Message Pack：二进制的 JSON Thrift 与 Protocol Buffers Avro 数据流模式 基于数据库的数据流 不同是写写入不同的值 归档存储 基于服务的数据流：REST 和 RPC RPC 的问题 给人一种本地调用的错觉，却需要面临网络的不确定性：延迟和超时。
基于消息传递的数据流 消息中间件：RabbitMQ、Kafka 分布式Actor 框架：Akka、Erlang OTP </description>
    </item>
    
    <item>
      <title>OLAP</title>
      <link>https://notes.0081800.xyz/notes/20210610214521-olap/</link>
      <pubDate>Thu, 10 Jun 2021 21:45:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210610214521-olap/</guid>
      <description>在线分析处理（Online Analytic Processing，OLAP）。</description>
    </item>
    
    <item>
      <title>OLTP</title>
      <link>https://notes.0081800.xyz/notes/20210610214348-oltp/</link>
      <pubDate>Thu, 10 Jun 2021 21:43:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210610214348-oltp/</guid>
      <description>在线事务处理（Online Transaction Processing，OLTP）。</description>
    </item>
    
    <item>
      <title>B-trees</title>
      <link>https://notes.0081800.xyz/notes/20210606143901-b_trees/</link>
      <pubDate>Sun, 06 Jun 2021 14:39:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210606143901-b_trees/</guid>
      <description>B-tree 是最广泛使用的索引结构。和排序字符串表：SSTables一样，B-tree 保留按键排序的 key-value 对， 这样可以实现高效的 key-value 查找和区间查询。
结构 B-tree 将数据库分解成固定大小的页或块，传统上 4KB，这种设计更接近底层硬件，磁盘也是以固定大小的块排列的。
分页因子 B-tree 中一个页所包含的子页引用数量称为分支因子。
添加新键 找到其范围新键的页 如果页没有足够的可用空间来容纳新键，则将其分裂为两个半满的页，并更新父页以包含新的键范围。 算法确保树保持平衡：具有 n 个键的 B-tree 总是具有 \(O(log n)\) 的深度。大多数据库适合 3~4 层的 B-tree。 分支因子为 500 的 4KB 页的四级树可以存储高达 256TB。
可靠性：WAL B-tree 底层的基本写操作是使用新的数据覆盖磁盘上的旧页。
如果发生页分裂则需要覆盖多个不同的页，同时更新父页，这个操作比较危险，如果此时发生崩溃则会破坏索引。 常见的 B-tree 使用额外的数据结构：预写日志(WAL)：
追加的写 WAL； 每个 B-tree 必须先更新 WAL 然后再修改树本身的页。 通过使用「锁存器」保护进行并发控制，保护 B-tree 页被多个线程访问而看到树不一样的状态。
优化 通过复制方案替代 WAL 进行崩溃恢复，修改的页被写入不同的位置，树中父页的新版本被创建，并指向新的位置。 保存键的缩略信息，可以压入更多的键，保持更高的分支因子，减少层数。 对树进行布局，相邻叶子页按顺序保存在磁盘。 添加额外的指针到树中，如左右兄弟页。 变体，如分形树：借鉴日志结构减少磁盘寻道。 </description>
    </item>
    
    <item>
      <title>哈希索引</title>
      <link>https://notes.0081800.xyz/notes/20210606103354-%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Sun, 06 Jun 2021 10:33:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210606103354-%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95/</guid>
      <description>索引 先来看一个世界上由 Bash 实现的最简单的数据库实现：
#!/bin/bash db_set() { echo &amp;#34;$1,$2&amp;#34; &amp;gt;&amp;gt; database } db_get() { grep &amp;#34;^$1,&amp;#34; database | sed -e &amp;#34;s/^$1,//&amp;#34; | tail -n 1 } 这种数据库通过追加文件尾部的方式高效写入，许多数据库内部都是用日志，日志是一个仅支持追加更新的数据文件。但是 db_get 的性能会随着数据量的变大而下降，为了解决这个问题就需要引入新的数据结构： 索引 。
索引是基于原始数据而派生而来的额外数据结构：适当的索引可以加速读取查询，但是回减慢写速度。
key-value 索引通常使用 hash map 来实现，最简单的索引策略：保存内存中的 hash map，把每个键一一映射到数据文件中特定的字节偏移量。
优化磁盘占用 将日志分解成一定大小的段，当文件达到一定大小时就关闭它，并将后续写入到新的段文件中。 然后可以在这些段上执行压缩：丢弃重复的键，并且只保留每个键最近的更新。 同时将变小后的多个段在后台合并在一起（段在写入后不再会进行修改所以不会出现竞争）。 合并完成后将读取请求切换到新的合并段上，然后可以安全的删除旧的段文件。 实现中面临的问题 文件格式：二进制。 删除记录：通过特殊的墓碑标记。 崩溃恢复：Bitcask 通过将 hash map 快照存储到磁盘。 部分写入：文件校验丢弃损坏的部分。 并发控制：只有一个写线程。 追加的好处 顺序写性能高。 并发控制和崩溃恢复简单。 段合并避免文件碎片化。 局限性 大量的键存储在内存可能导致内存耗尽，同时需要处理哈希冲突 区间查询效率不高。 </description>
    </item>
    
    <item>
      <title>排序字符串表：SSTables</title>
      <link>https://notes.0081800.xyz/notes/20210606103142-%E6%8E%92%E5%BA%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8_sstables/</link>
      <pubDate>Sun, 06 Jun 2021 10:31:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210606103142-%E6%8E%92%E5%BA%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8_sstables/</guid>
      <description>SSTables 通过按照键的顺序存储在日志段文件中来解决哈希索引面临的一些问题。它要求每个键在每个合并的段文件中只能出现一次（通过压缩确保）。
对比哈希索引的日志段 优点 合并段更加高效，即使文件大于可用内存。类似于归并排序算法中使用的方法。并发读取多个输入段文件，比较每个文件的第一个键，把最小的键拷贝到输出文件，并重复。
解决多个段文件重复：保留最新的值，因为每个段包含在某段时间内写入数据库的所有值，意味着肯定有一个值比其他所有值更新。
基于键有序的特性可以采用稀疏索引避免内存中包含所有键的索引。
将一定范围内的所有键存储到一个块中，便于需要请求范围内多个 key-value，降低磁盘 I/O。
构建和维护 保证顺序 内存中痛哦红黑树或者 AVL 树支持任意顺序插入并以排序后的顺序读取它们。
写入时，将其添加到内存中的平衡树数据结构中，成为内存表。 内存表大于某个阈值（MB级别），将其作为 SSTable 文件写入磁盘。写入同时，写入可以继续添加到一个新的内存表实例中。 处理请求顺序：首先从内存表中查找键 -&amp;gt; 最新的磁盘段文件 -&amp;gt; 次新磁盘段文件，以此类推。 后台进程周期性执行段合并与压缩，合并多个段文件并丢弃被覆盖或着删除的值。 崩溃处理 为了避免数据库崩溃最近的写入（在内存表中尚未写入磁盘）将会丢失的问题：
在磁盘上保留单独的日志，每个写入都会立即追加到该日志。并且无需排序。 内存表写入 SSTable 时，丢弃相应的日志。 使用此技术的数据库 LevelDB RocksDB 类似的
Cassandra HBase </description>
    </item>
    
    <item>
      <title>LSM-Tree</title>
      <link>https://notes.0081800.xyz/notes/20210606100317-lsm_tree/</link>
      <pubDate>Sun, 06 Jun 2021 10:03:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210606100317-lsm_tree/</guid>
      <description> tags: Tree 日志结构合并树（Log-Structured Merge-Tree）：基于合并和压缩排序文件原理的存储引擎通常都被称为 LSM 存储引擎。
压缩排序文件基于排序字符串表：SSTables。
LSM-Tree 基本思想：保存在后台并合并的排序字符串表：SSTables。即使数据集远远大于可用内存，仍然能够正常工作。 基于有序的特性，可以有效的执行区间查询，并且由于磁盘是顺序写入，所以 LSM-Tree 可以支持非常高的写入吞吐量。
性能优化 通过布隆过滤器优化 LSM-Tree 查找不存在的键性能低下的问题。 通过大小分级和分层压缩优化 SSTables 压缩和合并时的具体顺序和时机。 大小分级：较新和较小的 SSTables 被连续合并到较旧和较大的 SSTables。 分层压缩：键的范围分裂成多个更小的 SSTables，就数据被移动到单独的“层级”，这样压缩可以逐步进行并节省磁盘空间。 </description>
    </item>
    
    <item>
      <title>数据存储与检索</title>
      <link>https://notes.0081800.xyz/notes/20210606095514-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E6%A3%80%E7%B4%A2/</link>
      <pubDate>Sun, 06 Jun 2021 09:55:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210606095514-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E6%A3%80%E7%B4%A2/</guid>
      <description>存储引擎 哈希索引 日志结构存储引擎：LSM-Tree 面向页的存储引擎：B-trees 对比 LSM-Tree 和 B-trees 项目 LSM-Tree B-trees 备注 性能 写入更快，吞吐更高 读取更快 具体场景上需要进行基准测试 存储 可变大小的段，通常 nMB 固定大小的页，传统 4KB 写入 追加，写入更多不利于 SSD 新的数据覆盖磁盘上旧的页 并发控制 后台合并进行原子替换 锁存器 其他索引结构 在索引中存储值
多列索引
全文索引和模糊索引
在内存中保存所有内容
优点：可以支持更复杂的数据结构，而无需考虑数据存储结构。
事务处理与分析处理 事务处理：OLTP 分析处理：OLAP 对比 属性 OLTP OLAP 主要读属性 基于键，每次查询返回少量记录 对于大量记录进行汇总 主要写属性 随机访问，低延迟写入用户的输入 批量导入（ETL）或事件流 典型使用场景 终端用户，通过网络应用程序 内部分析师，为决策提供支持 数据表征 最新的数据状态（当前时间点） 随着事件而变化的所有事件历史 数据规模 GB 到 TB TB 到 PB 数据仓库 星型与雪花型分析模式 星型模型也称为维度建模。
列式存储 列压缩 </description>
    </item>
    
    <item>
      <title>数据模型与查询语言</title>
      <link>https://notes.0081800.xyz/notes/20210606095222-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Sun, 06 Jun 2021 09:52:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210606095222-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/</guid>
      <description>数据模型 关系模型 突出数据之间的关联。
文档模型 数据来自于包含文档，文档间关联很少。
图状数据模型 针对所有数据都可能互相关联。
数据查询语言 Web 上声明式查询 CSS 选择器。
MapReduce 查询 MapReduce 是一种编程模型，用于在许多机器上批量处理海量数据。
MongoDB 中的 MapReduce
db.observations.mapReduce( function map() { // 2 var year = this.observationTimestamp.getFullYear(); var month = this.obbservationTimestamp.getMonth() + 1; emit(year + &amp;#34;-&amp;#34; + month, this.numAnimals); // 3 }, function reduce(key, values) { // 4 return Array.sum(values); // 5 }, { query: {family: &amp;#34;Sharks&amp;#34;}, // 1 out: &amp;#34;monthlySharkReport&amp;#34; // 6 } ); 过滤器声明式执行鲨鱼种类（MongoDB 特有扩展）。 mapper：对于每个匹配的文档都会调用一次这个 JavaScript 函数。 mapper 发射一个「键-值」对，键是 “2013-12” 格式的字符串，值是动物的数量 mapper 发射的键值对按键分组，对于相同键的所有「键-值」对，调用 reduce 函数。 reducer 函数将特定月份的所有观察到的动物数量相加。 最终输出写入到 monthlySharkReport 集合中 </description>
    </item>
    
    <item>
      <title>可靠、可扩展与可维护的应用系统</title>
      <link>https://notes.0081800.xyz/notes/20210604221658-%E5%8F%AF%E9%9D%A0_%E5%8F%AF%E6%89%A9%E5%B1%95%E4%B8%8E%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Fri, 04 Jun 2021 22:16:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210604221658-%E5%8F%AF%E9%9D%A0_%E5%8F%AF%E6%89%A9%E5%B1%95%E4%B8%8E%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F/</guid>
      <description>可靠性 故障与失效 故障（faults）或者错误：组件偏离其正常规格，可以提供容错（fault-tolerant）机制 失效（failure）意味系统作为一个整体停止 硬件故障 软件错误 人为失误 避免优化方式：
以最小出错方式设计系统。抽象、提供管理界面，使“做正确的事很轻松”，防止限制过多。 分离最容易出错的地方，提供沙箱用以放心尝试。 充分测试。 提供快速恢复机制尽量减少故障影响：快速回滚，提供校验数据的工具。 设置详细而清晰的监控系统 培训和流程 可扩展性 描述负载 QPS 数据库写入比例 同时在线活动用户数 缓存命中率等。 描述性能 吞吐量（throughput）/每秒处理数据量 延迟（latency）/响应时间（response time）：延迟是处理时间，响应时间是客户端看到的。 最好通过百分位数来监控指标：p50/p80/p90/p95/p99/p999，p50 指标表示一半请求在这个指标之下，一半在这个指标之上。
应对负载增加 无状态很方便扩容 但有状态的分布式面临一定的挑战 可维护性 可运维性：运维更轻松 监控、文档、自动化、良好的默认配置、可手动控制系统状态让系统自我修复（比如熔断机制）。
简单性：简化复杂度 抽象！
可演化性：易于改变 TDD 重构 </description>
    </item>
    
    <item>
      <title>《数据密集型应用系统设计》读书笔记</title>
      <link>https://notes.0081800.xyz/notes/20210604221412-%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 04 Jun 2021 22:14:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210604221412-%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description> tags: 读书笔记,Bigdata,分布式,数据库 数据系统基础 可靠、可扩展与可维护的应用系统 数据模型与查询语言 数据存储与检索 数据编码与演化 分布式数据系统 目的：扩展性、容错和高可用、延迟考虑（多机房）
扩展：
垂直扩展：提升单机性能 水平扩展：无共享结构，由软件实现核心逻辑 复制与分区：
复制：多节点冗余 分区：数据库拆分 分片：分区分配给不同的节点 数据复制 数据分区 事务 分布式系统挑战 一致性与共识 派生数据 记录系统：真实数据系统，拥有数据的权威版本。 派生数据系统：从另一个数据系统获取，丢失可以根据数据源重建，如缓存等。 批处理系统 流处理系统 </description>
    </item>
    
    <item>
      <title>项目代号</title>
      <link>https://notes.0081800.xyz/notes/20210525113247-%E9%A1%B9%E7%9B%AE%E4%BB%A3%E5%8F%B7/</link>
      <pubDate>Tue, 25 May 2021 11:32:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210525113247-%E9%A1%B9%E7%9B%AE%E4%BB%A3%E5%8F%B7/</guid>
      <description> tags: 技术随想 几何结构 mobius Klein Trefoil knot Penrose triangle 植物 bonsai broccoli 科幻 tardis dalek 消灭 神话 </description>
    </item>
    
    <item>
      <title>macOS 问题解决三板斧</title>
      <link>https://notes.0081800.xyz/notes/20210322145956-macos_%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E4%B8%89%E6%9D%BF%E6%96%A7/</link>
      <pubDate>Mon, 22 Mar 2021 14:59:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210322145956-macos_%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E4%B8%89%E6%9D%BF%E6%96%A7/</guid>
      <description> tags: macOS,macOS Cheatsheet 通常你沟通苹果的官方支持一般都会给你三板斧：
重启：按住电源键 10 秒中，然后等几秒钟后再开机 重置 SMC：关机然后按住：Ctrl + Option + 右侧Shift + 电源键 7 秒钟关机，等待几秒钟后开机。 </description>
    </item>
    
    <item>
      <title>macOS TimeMachine 日志</title>
      <link>https://notes.0081800.xyz/notes/20210322145854-macos_timemachine_%E6%97%A5%E5%BF%97/</link>
      <pubDate>Mon, 22 Mar 2021 14:58:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210322145854-macos_timemachine_%E6%97%A5%E5%BF%97/</guid>
      <description> tags: macOS 查看 TimeMachine 日志：
printf &amp;#39;\e[3J&amp;#39; &amp;amp;&amp;amp; log show --predicate &amp;#39;subsystem == &amp;#34;com.apple.TimeMachine&amp;#34;&amp;#39; --debug --last 6m </description>
    </item>
    
    <item>
      <title>English IPA</title>
      <link>https://notes.0081800.xyz/notes/20210317141647-english_ipa/</link>
      <pubDate>Wed, 17 Mar 2021 14:16:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210317141647-english_ipa/</guid>
      <description>tags: Learning English 一些通用的规则：
音标后面的 ː 提示拖长音。 元音 大而圆 音标 中文 发音技巧 常见单词 拼读规则 /​æ​/ 爱 张大嘴发中文的「爱」,发音短促有力。 bag map dad sad a /​e​/ 爱 音同 /​æ​/ 但是嘴形要小一些。 get let pen yes e /​ɔː​/ 哦 嘴巴轮圆了发音，并拖长音 floor door store sport oor,ore,or /​ɔ​/ 哦 /​ɔː​/ 的短音 lot dog hot shop o 扁扁扁 音标 中文 发音技巧 常见单词 拼读规则 /iː​/ 一 相比一嘴要扁一些，稍稍更用力一些 see meet he she ee, e /​i​/ 一 /iː​/ 短音 happy daddy honey 词尾的 y 或 ey /​I​/ 一 用 /​e​/ 的嘴形发 /​i​/ this give it city i /əː​/ 呃 相比中文嘴要扁一些，稍稍更用力一些 work girl dirt sir or, ir /​ə​/ 呃 /əː​/ 的短音 again a father weather 单独的 a 及词尾的 er 需要额外注意的：</description>
    </item>
    
    <item>
      <title>二叉树的遍历</title>
      <link>https://notes.0081800.xyz/notes/20210220203210-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sat, 20 Feb 2021 20:32:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210220203210-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</guid>
      <description>tags: Algorithm,Data Structures,Binary Search Tree 分为三种：前序、后序和中序，其中最容易用栈改写的是后序。
前序(Preorder)：Root -&amp;gt; Left -&amp;gt; Right class Solution { public: void processPreorderTraversal(TreeNode* root, vector&amp;lt;int&amp;gt; &amp;amp; collector) { if (root == nullptr) { return; } processPreorderTraversal(root-&amp;gt;left, collector); collector.push_back(root-&amp;gt;val); processPreorderTraversal(root-&amp;gt;right, collector); } vector&amp;lt;int&amp;gt; inorderTraversal(TreeNode* root) { vector&amp;lt;int&amp;gt; ret; if (root == nullptr) { return ret; } processPreorderTraversal(root, ret); return ret; } }; 中序(Inorder): Left -&amp;gt; Root -&amp;gt; Right class Solution { public: void processInorderTraversal(TreeNode* root, vector&amp;lt;int&amp;gt; &amp;amp; collector) { if (root == nullptr) { return; } processInorderTraversal(root-&amp;gt;left, collector); collector.</description>
    </item>
    
    <item>
      <title>OX-HUGO 批量导出 Markdown</title>
      <link>https://notes.0081800.xyz/notes/20210220175534-ox_hugo_%E6%89%B9%E9%87%8F%E5%AF%BC%E5%87%BA_markdown/</link>
      <pubDate>Sat, 20 Feb 2021 17:55:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210220175534-ox_hugo_%E6%89%B9%E9%87%8F%E5%AF%BC%E5%87%BA_markdown/</guid>
      <description> tags: Taking Notes, Org Mode 方案一：通过 Emacs 批处理模式 emacs file.org --batch -f org-hugo-export-wim-to-md --kill --batch 默认不启用配置文件，可以使用 -l
emacs file.org --batch -l ~/.emacs.d/init.el -f org-hugo-export-wim-to-md --kill 方案二：通过 LISP 遍历 (mapc (lambda (x) (with-current-buffer (find-file-noselect x) (org-hugo-export-wim-to-md t))) (directory-files &amp;#34;/Users/wh/codes/notes/roam-research-notes-hugo/journal&amp;#34; nil &amp;#34;^[0-9]+$&amp;#34; t)) </description>
    </item>
    
    <item>
      <title>中间件</title>
      <link>https://notes.0081800.xyz/notes/20210220165816-%E4%B8%AD%E9%97%B4%E4%BB%B6/</link>
      <pubDate>Sat, 20 Feb 2021 16:58:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210220165816-%E4%B8%AD%E9%97%B4%E4%BB%B6/</guid>
      <description>tags: 技术，技术概念 中间件可以对系统进行解耦，比如上层系统对下层系统进行网络请求，考虑下面结构
- U - / | \ /--- | ---\ / | \ A B C 如果下层系统增加节点的话就需要重启 U。
引入 HAProxy 或者 Nginx 之类的中间件可以对两层系统进行解耦：
U | +------+ | HA | +------+ / | \ /--- | ---\ / | \ A B C 这样上层和下层系统都依赖中间件，但是系统之间不再强耦合，下层系统可以依赖中间件随意的进行所扩容而不用被上层系统感知。 这时候中间件只要保证中间件稳定即可，可以在中间件上进行热重启。</description>
    </item>
    
    <item>
      <title>技术随想</title>
      <link>https://notes.0081800.xyz/notes/20210220165806-%E6%8A%80%E6%9C%AF%E9%9A%8F%E6%83%B3/</link>
      <pubDate>Sat, 20 Feb 2021 16:58:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210220165806-%E6%8A%80%E6%9C%AF%E9%9A%8F%E6%83%B3/</guid>
      <description> 项目代号 技术概念 </description>
    </item>
    
    <item>
      <title>C/C&#43;&#43; thread-local storage</title>
      <link>https://notes.0081800.xyz/notes/20210219200958-c_c_thread_local_storage/</link>
      <pubDate>Fri, 19 Feb 2021 20:09:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210219200958-c_c_thread_local_storage/</guid>
      <description> tags: C/C++ source: All about thread-local storage </description>
    </item>
    
    <item>
      <title>macOS max open files</title>
      <link>https://notes.0081800.xyz/notes/20210125174343-macos_max_open_files/</link>
      <pubDate>Mon, 25 Jan 2021 17:43:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210125174343-macos_max_open_files/</guid>
      <description>tags: macOS fix &amp;ldquo;Too many open files in system&amp;rdquo; error</description>
    </item>
    
    <item>
      <title>GDB 打出所有线程的 Backtrace</title>
      <link>https://notes.0081800.xyz/notes/20210118114707-gdb_%E6%89%93%E5%87%BA%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E7%9A%84_backtrace/</link>
      <pubDate>Mon, 18 Jan 2021 11:47:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210118114707-gdb_%E6%89%93%E5%87%BA%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E7%9A%84_backtrace/</guid>
      <description> tags: GDB thread apply all bt </description>
    </item>
    
    <item>
      <title>C&#43;&#43; LSP</title>
      <link>https://notes.0081800.xyz/notes/20210114175011-lsp/</link>
      <pubDate>Thu, 14 Jan 2021 17:50:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20210114175011-lsp/</guid>
      <description>tags: Emacs,LSP,C/C++,CMake 通过如下命令生成 clangd 识别的编译配置文件
mkdir build cd build cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1 .. mv compile_commands.json ../ 然后重启 M-x lsp-restart-workspace RET 即可。</description>
    </item>
    
    <item>
      <title>Python behind the scenes #2: how the CPython compiler works</title>
      <link>https://notes.0081800.xyz/notes/20201015182827-python_behind_the_scenes_2_how_the_cpython_compiler_works/</link>
      <pubDate>Thu, 15 Oct 2020 18:28:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20201015182827-python_behind_the_scenes_2_how_the_cpython_compiler_works/</guid>
      <description>tags: Translate,Incomplete,Python Python 幕后 #2: CPython 编译器如何工作 今天的主题（Today&amp;rsquo;s subject） 在本系列的第一篇文章中我们研究了 Python 虚拟机。我们学了解到它通过执行一系列叫做字节码（bytecode）的指令。 我们也看到 Python 字节码没有完全描述代码片段的行为。这也是为什么存在一个代码对象（code object）的概念。 执行诸如函数或模块的代码块也就是执行对应的代码对象。代码对象包含了代码块的字节码，包含代码中使用的常量和变量名， 还有代码块的一些属性。
通常，一个 Python 程序员不用编写字节码，并且也不用创建代码对象，而是编写正常的 Python 代码。所有 CPython 必须 能够将源代码转换成代码对象。CPython 编译器就负责这部分工作。我们将通过这部分内容探索它是如何工作的。
Note: 本文参考 CPython 3.9。一些实现细节将必然会随着 CPython 的演进而改变。 我将会尝试关注一些重要的改变并添加更新备注。
什么是 CPython 编译器（What CPython compiler is） 我们已经了解了 CPython 编译器的职责，但是在我们进入到它是如何实现的之前，让我们首先来搞清楚为什么我们称之为编译器？
在通常情况加，编译器是一个将一个程序语言翻译到另一个与之等价的程序语言的程序。编译器有许多种类，但是通常情况下我们 讨论的都是静态编译：将一个高级语言的程序翻译成机器码。CPython 编译器也是这样吗？要回答这个问题，我们先看一下静态编 译器的传统三阶段设计（three-stage design）。
编译器前端（frontend）将源代码转换成一种中间语言（IR,intermediate representation）。然后优化器（optimzer）拿到中间语言 对其进行优化并把优化过的中间语言传递给编译器后端生成机器码。如果我们选择一种源语言和目标机器无关的中间语言，我们就 得到了三阶段设计的关键益处：对于一个编译器来说，支持一种新的源语言仅仅需要新增一个对应的编译器前端，支持一种新的目标机器 仅仅需要新增一个对应的编译器后端。
LLVM 工具集（toolchain）就是这个模型的一个很好的成功的例子。有很多编译器前端如 C、Rust、Swift 等其他很多编程语言基于 LLVM 提供给编译器更加复杂的部分。LLVM 的创建者 Chris Latter 提供了一个很好的 LLVM 架构概览。
CPython 尽管不需要支持多个源语言和目标机器，尔仅仅需要支持 Python 代码和 CPython 虚拟机。不过，CPython 同样实现了三阶段设计。 如果想知道为什么，我们需要更加详细的解释编译器的三阶段的每个阶段。</description>
    </item>
    
    <item>
      <title>straight.el 命令</title>
      <link>https://notes.0081800.xyz/notes/20201006200745-straight_el_%E6%9B%B4%E6%96%B0/</link>
      <pubDate>Tue, 06 Oct 2020 20:07:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20201006200745-straight_el_%E6%9B%B4%E6%96%B0/</guid>
      <description>tags: Emacs
M-x straight-thaw-versions RET 恢复到锁定的版本
M-x straight-pull-all RET 更新所有包
M-x straight-freeze-versions RET 锁定当前版本
Duplicated with straight.el 更新所有已安装的包</description>
    </item>
    
    <item>
      <title>straight.el 更新所有已安装的包</title>
      <link>https://notes.0081800.xyz/notes/20201006200745-straight_el_%E6%9B%B4%E6%96%B0%E6%89%80%E6%9C%89%E5%B7%B2%E5%AE%89%E8%A3%85%E7%9A%84%E5%8C%85/</link>
      <pubDate>Tue, 06 Oct 2020 20:07:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20201006200745-straight_el_%E6%9B%B4%E6%96%B0%E6%89%80%E6%9C%89%E5%B7%B2%E5%AE%89%E8%A3%85%E7%9A%84%E5%8C%85/</guid>
      <description> straight-thaw-versions straight-pull-all straight-freeze-versions </description>
    </item>
    
    <item>
      <title>Emacs Buffer 名字去重</title>
      <link>https://notes.0081800.xyz/notes/20200927170116-emacs_buffer_%E5%90%8D%E5%AD%97%E5%8E%BB%E9%87%8D/</link>
      <pubDate>Sun, 27 Sep 2020 17:01:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200927170116-emacs_buffer_%E5%90%8D%E5%AD%97%E5%8E%BB%E9%87%8D/</guid>
      <description> tags: Emacs source: https://www.gnu.org/software/emacs/manual/html%5Fnode/emacs/Uniquify.html </description>
    </item>
    
    <item>
      <title>范数（norm）</title>
      <link>https://notes.0081800.xyz/notes/20200912102351-%E8%8C%83%E6%95%B0/</link>
      <pubDate>Sat, 12 Sep 2020 10:23:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200912102351-%E8%8C%83%E6%95%B0/</guid>
      <description>具有“长度”概念的函数。在线性代数、泛函分析等相关数学领域，是一个函数，其为向量空间内所有向量赋予非零的正长度或大小。</description>
    </item>
    
    <item>
      <title>MAE（平均绝对误差）</title>
      <link>https://notes.0081800.xyz/notes/20200912101549-mae_%E5%B9%B3%E5%9D%87%E7%BB%9D%E5%AF%B9%E8%AF%AF%E5%B7%AE/</link>
      <pubDate>Sat, 12 Sep 2020 10:15:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200912101549-mae_%E5%B9%B3%E5%9D%87%E7%BB%9D%E5%AF%B9%E8%AF%AF%E5%B7%AE/</guid>
      <description>\[MAE(X,h) = \frac{1}{m}\sum_{i=1}^{m}\left\lvert h(x^{(i)} - y ^{i})\right\rvert\]</description>
    </item>
    
    <item>
      <title>RMSE（均方根误差）</title>
      <link>https://notes.0081800.xyz/notes/20200912094544-rmse_%E5%9D%87%E6%96%B9%E6%A0%B9%E8%AF%AF%E5%B7%AE/</link>
      <pubDate>Sat, 12 Sep 2020 09:45:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200912094544-rmse_%E5%9D%87%E6%96%B9%E6%A0%B9%E8%AF%AF%E5%B7%AE/</guid>
      <description>测量预测过程中的预测错误的标准差。
公式
\[RMSE(X,h)=\sqrt{\frac{1}{m}\sum_{i=1}^{m}(h(x^{(i)}) - y^{(i)})^2}\]
m 是你在测量 RMSE 时，所使用的数据集中实例的数量 \(x^{(i)}\) 是数据集中第 \(i\) 个实例的所有特征值的向量（标签特征除外），\(y{(i)}\) 是标签（也就是我们期待该实例的输出值） X 是数据集中所有实例所有特征值的矩阵（标记特征除外）。每个实例一行，也就是说第 \(i\) 行等于 \(x^{(i)}\) 的转置矩阵1，记作 \((x^{(i)})^T\) h 是系统的预测函数，也称为一个假设。当给定系统一个实例的特征向量 \(x^{(i)}\) ，他会输出一个预测值 \(\hat{y}=h(x^{(i)})\) RMSE(X,h) 是使用假设 h 在示例上测量的成本函数。 转置运算符会将列向量转换成行向量。&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description>
    </item>
    
    <item>
      <title>机器学习涉及数学概念</title>
      <link>https://notes.0081800.xyz/notes/20200912093811-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%B6%89%E5%8F%8A%E6%95%B0%E5%AD%A6%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Sat, 12 Sep 2020 09:38:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200912093811-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%B6%89%E5%8F%8A%E6%95%B0%E5%AD%A6%E6%A6%82%E5%BF%B5/</guid>
      <description>公式 RMSE（均方根误差） MAE（平均绝对误差） 概念 标准差（Std Dev） 范数 方差 皮尔逊相关系数（标准相关系数） 线性相关性 </description>
    </item>
    
    <item>
      <title>Python behind the scenes #1: how the CPython VM works</title>
      <link>https://notes.0081800.xyz/notes/20200908103647-python_behind_the_scenes_1_how_the_cpython_vm_works/</link>
      <pubDate>Tue, 08 Sep 2020 10:36:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200908103647-python_behind_the_scenes_1_how_the_cpython_vm_works/</guid>
      <description>tags: Translate,Python 原文链接：Python behind the scenes #1: how the CPython VM works。
Python 幕后 #1: CPython 虚拟机如何工作 介绍（Introduction） 你是否曾经好奇过当你运行 Python 代码时 python 做了些什么？
$ python script.py 这篇文章将开启一个系列来尝试解答这个问题。我们将深入 Python 最流行的实现 CPython 的内部。 通过深入 CPython 的内部我们将更深一层的去理解这门编程语言本身。这也是我们这个系列的最主要的目标。 如果你熟悉 Python 并且可以阅读 C 代码，但是对 CPython 源码本身没有太多的经验， 那么你可能非常适合本系列，并且对本系列感兴趣。
什么是 CPython 并且为什么有人想学习它（What CPython is and why anyone would want to study it） 我们首先来说明一些众所周知的事情。CPython 是用 C 编写的 Python 解析器。他是 Python 语言的众多实现 的一种，其他还有诸如 PyPy、Jython、IronPython 等。CPython 的独特之处在于它是 Python 的起源、维护时间最长也是最受欢迎的。</description>
    </item>
    
    <item>
      <title>机器学习测试与验证</title>
      <link>https://notes.0081800.xyz/notes/20200907081217-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%B5%8B%E8%AF%95%E4%B8%8E%E9%AA%8C%E8%AF%81/</link>
      <pubDate>Mon, 07 Sep 2020 08:12:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200907081217-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%B5%8B%E8%AF%95%E4%B8%8E%E9%AA%8C%E8%AF%81/</guid>
      <description>将数据分成两部分：训练集和测试集，通常使用 80% 的数据进行训练，20% 的数据用来测试。
验证集 单独分出来一个保留集合作为验证集，防止调整模型和超参数拟合测试集的最佳模型。
交叉验证 为避免验证集浪费太多数据，交叉验证将训练集分成若干个互补子集，然后每个模型都通过这些子集的不同组合来 训练，之后用剩余的子集进行验证。</description>
    </item>
    
    <item>
      <title>机器学习的主要挑战</title>
      <link>https://notes.0081800.xyz/notes/20200907080323-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8C%91%E6%88%98/</link>
      <pubDate>Mon, 07 Sep 2020 08:03:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200907080323-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8C%91%E6%88%98/</guid>
      <description>训练数据的数量不足 训练数据不具代表性 质量差的数据 无关特征 特征工程 一个成功的机器学习项目，关键部分是提取一组好的用了训练的特征集，这个过程叫做特征工程。
特征选择 特征提取 通过手机数据创造新的特征 训练数据过度拟合 在模型的训练数据上表现良好，但是泛化时却不尽人如意。
解决方法
简化模型 收集更多的训练数据 减少训练数据中的噪声（修复数据错误和消除异常值） 正则化 通过约束模型使其更简单，并降低过度拟合风险。
超参数 通过调整超参数来调整应用正则化的程度。调整超参数是构建机器学习系统的非常重要的组成部分。
训练数据拟合不足 解决方法：
选择一个带有更多参数、更强大的模型 给学习算法提供更好的特征集 减少模型中的约束（如减少正则化超参数） </description>
    </item>
    
    <item>
      <title>机器学习系统的种类</title>
      <link>https://notes.0081800.xyz/notes/20200907074200-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%A7%8D%E7%B1%BB/</link>
      <pubDate>Mon, 07 Sep 2020 07:42:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200907074200-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%A7%8D%E7%B1%BB/</guid>
      <description>监督式/无监督式学习 监督式学习 定义 训练数据经过标注包含素所需解决方案（标签或标记）
相关算法 K-邻近算法 线性回归 逻辑回归：广泛用于分类，输出“属于某个给定类别的概率”的值 支持向量机 决策树和随机森林 神经网络 适应场景 分类任务 预测变量 无监督式学习 定义 训练数据未经标注
相关算法 聚类算法 K-平均算法 分层聚类分析 最大期望算法 可视化和降维 主成分分析 核主成分分析 局部线性嵌入 t-分布随机临近嵌入 关联规则学习 Apriori Eclat 适应场景 通过聚类算法检测相似（层次聚类算法精度更高，可以再次细分） 可视化算法 降维：不丢失太多信息的前提下简化数据，方法之一是合并特征，过程叫做特征提取 异常检测：判断新的输入是正常还是异常，数据初筛、防作弊等 关联规则学习：发现属性之间有趣的联系 半监督式学习 大量未标记数据和少量标记数据进行学习。
强化学习 观察环境、作出选择、执行操作、并获得回报（负值则为惩罚）。
批量学习和在线学习 在数据流中进行增量学习。
批量学习 在线学习 在线学习也称为增量学习，同时支持恢复到上一状态，便于检测到性能下降及时中断和回滚。
核外学习 超大数据集超出一台计算机的主存储器，每次加载部分数据并不断重复直至完成训练。
学习率 学习率高系统迅速适应新数据，同时快速忘记老数据，学习率低则反之。
基于实例和基于模型的学习 基于实例的学习 系统完全记住学习示例，然后通过某种相似度度量方式将其泛化到新的实例。
基于模型的学习 模型选择 观察数据得出模型的过程。
衡量模型表现 定义效用函数（或适应度函数）来衡量模型有多好 定义成本函数来衡量模型有多差 线性回归通常选择成本函数来衡量线性模型的预测和训练实例之间的差距。
线性回归算法的意义所在：通过你提供的训练样本，找出最符合所提供数据的线性模型的参数，这就是训练过程。</description>
    </item>
    
    <item>
      <title>《机器学习实战》读书笔记</title>
      <link>https://notes.0081800.xyz/notes/20200905075701-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 05 Sep 2020 07:57:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200905075701-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description>概览 机器学习系统的种类 机器学习的主要挑战 机器学习测试与验证 模型是观察的简化。
相关数学概念 机器学习涉及数学概念 </description>
    </item>
    
    <item>
      <title>Machine Learning</title>
      <link>https://notes.0081800.xyz/notes/20200903180214-machine_learning/</link>
      <pubDate>Thu, 03 Sep 2020 18:02:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200903180214-machine_learning/</guid>
      <description> scikit-learn 提供一些常见的机器学习算法 逻辑回归(Logistic Regression aka LR) 线性分类器 XGBoost 提供随机森林解决逻辑回归特征不明显的问题 </description>
    </item>
    
    <item>
      <title>Rust Obscure Words for non-native English speakers</title>
      <link>https://notes.0081800.xyz/notes/20200829081145-rust_obscure_words_for_non_native_english_speakers/</link>
      <pubDate>Sat, 29 Aug 2020 08:11:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200829081145-rust_obscure_words_for_non_native_english_speakers/</guid>
      <description>tags: Rust,Learning English
unwinding</description>
    </item>
    
    <item>
      <title>Rust Asynchronous Programming</title>
      <link>https://notes.0081800.xyz/notes/20200828160809-rust_asynchronous_programming/</link>
      <pubDate>Fri, 28 Aug 2020 16:08:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200828160809-rust_asynchronous_programming/</guid>
      <description>tags: Rust Future async fn 将一个代码块转换为一个 Future 对象， Future 对象维护一个状态机 Future 对象必须运行在一个 Executor 上 Executor futures::executor::block_on 阻塞当前线程直到 future 完成
// `block_on` blocks the current thread until the provided future has run to // completion. Other executors provide more complex behavior, like scheduling // multiple futures onto the same thread. use futures::executor::block_on; async fn hello_world() { println!(&amp;#34;hello, world!&amp;#34;); } fn main() { let future = hello_world(); // Nothing is printed block_on(future); // `future` is run and &amp;#34;hello, world!</description>
    </item>
    
    <item>
      <title>Go Swagger 实现代码即文档</title>
      <link>https://notes.0081800.xyz/notes/20200828104706-go_swagger/</link>
      <pubDate>Fri, 28 Aug 2020 10:47:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200828104706-go_swagger/</guid>
      <description>tags: Go 目标 当跟随这篇文章完成后将产出如下内容：
代码 http://gitlab.17zuoye.net/vgo/go-swagger-example 文档 http://swagger.17zuoye.net/?url=http%3A%2F%2F10.200.242.61%3A9090%2Fswagger.json 准备 Go1.14 及以上版本 安装 go-swagger ：参见 官方文档。 接下来使用 gin 框架作为示例，如果之前没接触过可以先了解下该框架 创建一个项目 $ mkdir go-swagger-example $ cd go-swagger-example/ $ go mod init gitlab.17zuoye.net/vgo/go-swagger-example 开始使用 首先在你的 `main.go` 定义 go generate 像下面这样：
//go:generate swagger generate spec -o ./swagger.yml package main func main() { println(&amp;#34;Hello world!&amp;#34;); } 此时如果运行 go generate 在项目目录下就会生成一个 swagger.yml 文件：
paths: {} swagger: &amp;#34;2.0&amp;#34; 使用单独的包托管 swagger 相关定义 在之前实践的过程中发现，如果在多个包中定义了相同名称的结构体会到只一个结构体覆盖另外一个结构体的定义。 所以为了解决这个问题，我把所有 swagger 相关的定义都放在同一个包下来避免相同名字的结构体。
创建 swagger/swagger.</description>
    </item>
    
    <item>
      <title>MySQL forget password</title>
      <link>https://notes.0081800.xyz/notes/20200827195950-mysql_forget_password/</link>
      <pubDate>Thu, 27 Aug 2020 19:59:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200827195950-mysql_forget_password/</guid>
      <description>tags: MySQL 启动 mysqld 时加上 --skip-grant-tables 参数可以无密码进入 MySQL。</description>
    </item>
    
    <item>
      <title>MVCC</title>
      <link>https://notes.0081800.xyz/notes/20200827195823-mvcc/</link>
      <pubDate>Thu, 27 Aug 2020 19:58:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200827195823-mvcc/</guid>
      <description>tags: MySQL https://liuzhengyang.github.io/2017/04/18/innodb-mvcc/ 来自《高性能 MySQL》：
InnoDB 在每一行都隐式的多存储两个字段：
事务更新版本 事务删除版本 当事务开始时记录这两个版本，在读取的时候根据 Undo Log 和 Redo Log 来实现隔离级别的控制。序列化隔离级别下只能通过行锁来保证。
在可重复读隔离级别下：
首先判断事务更新版本是否大于事务开始前的版本 如果大于则根据 Undo Log 进行回退实现可重复读，这样在同一事务下不管读多少遍读取到的内容都是一样的。 可重复读隔离即便下无法避免幻读：即一开始没有读取到，随着其他插入事务的提交在同一事务里执行查询又能读取到的情况。</description>
    </item>
    
    <item>
      <title>MySQL grant subnet</title>
      <link>https://notes.0081800.xyz/notes/20200827195621-mysql_grant_subnet/</link>
      <pubDate>Thu, 27 Aug 2020 19:56:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200827195621-mysql_grant_subnet/</guid>
      <description> tags: MySQL,Network https://stackoverflow.com/a/38389851/2873718
MySQL 授权用户子网段需要使用:
172.16.0.0/255.240.0.0 而不能使用
172.16.0.0/12 </description>
    </item>
    
    <item>
      <title>Network</title>
      <link>https://notes.0081800.xyz/notes/20200827180638-network/</link>
      <pubDate>Thu, 27 Aug 2020 18:06:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200827180638-network/</guid>
      <description></description>
    </item>
    
    <item>
      <title>逻辑右移</title>
      <link>https://notes.0081800.xyz/notes/20200802165502-%E9%80%BB%E8%BE%91%E5%8F%B3%E7%A7%BB/</link>
      <pubDate>Sun, 02 Aug 2020 16:55:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200802165502-%E9%80%BB%E8%BE%91%E5%8F%B3%E7%A7%BB/</guid>
      <description>位移产生的空白填上 0，会导致有符号的负数变成正数。</description>
    </item>
    
    <item>
      <title>算数右移</title>
      <link>https://notes.0081800.xyz/notes/20200802165150-%E7%AE%97%E6%95%B0%E5%8F%B3%E7%A7%BB/</link>
      <pubDate>Sun, 02 Aug 2020 16:51:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200802165150-%E7%AE%97%E6%95%B0%E5%8F%B3%E7%A7%BB/</guid>
      <description>位移的产生的空白填上符号位。</description>
    </item>
    
    <item>
      <title>汇编</title>
      <link>https://notes.0081800.xyz/notes/20200802155053-%E6%B1%87%E7%BC%96/</link>
      <pubDate>Sun, 02 Aug 2020 15:50:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200802155053-%E6%B1%87%E7%BC%96/</guid>
      <description>tags: Computer Systems,《深入理解计算机系统》读书笔记 程序编码 $ gcc -Og -S mstore.c # outputs mstore.s $ gcc -Og -c mstore.c # outptus mstore.o $ objdump -d mstore.o 所有以 ‘.’ 开头额行都是指导汇编器和链接器工作额伪指令。
数据格式 C 声明 Intel 数据类型 汇编代码后缀 大小（字节） char 字节 b 1 short 字 w 2 int 双字 l 4 long 四字 q 8 char* 四字 q 8 float 单精度 l 4 double 双精度 q 8 访问信息 寄存器 一个 x86-64 的中央处理单元（CPU）包含一组 16 个存储 64 位值的 通用目的寄存器 。</description>
    </item>
    
    <item>
      <title>IEEE 浮点数</title>
      <link>https://notes.0081800.xyz/notes/20200802151523-ieee_%E6%B5%AE%E7%82%B9%E6%95%B0/</link>
      <pubDate>Sun, 02 Aug 2020 15:15:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200802151523-ieee_%E6%B5%AE%E7%82%B9%E6%95%B0/</guid>
      <description>tags: Computer Systems,《深入理解计算机系统》读书笔记 浮点数小数表示形式 .0111 = \(0x2^{-1}+2^{-2}+2^{-3}+2^{-4}\)
IEEE 浮点数表示形式 \[ V=(-1)^s X M X 2^E \]
s = 0 表示负数， s = 1 表示正数 M 是二进制表示的小数 E 是阶码 浮点数二进制组成 一个单独符号位 s 表吗符合 k 位阶码字段 exp 编码阶码 E n 位小数字段 frac 编码尾数 M 两种常见的格式 float s = 1 k = 8 n = 23 double s = 1 k = 11 n = 52 三种计算方式 前置的一些值
e 是 exp 位表示的无符号数 f 是 frac 位表示的小数 \(Bias = 2^{k-1} -1\) 规格化的值 规则：阶码字段 exp 的位模式即不全为 0，也不全为 1（单精度 255，双精度 2047） 计算方式 \(E = e - Bias\) $M = 1 + f $ 非规格化的值 规则：阶码字段 exp 全是 0（用于表示 0） 计算方式 \(E = 1 - Bias\) \(M = f\) 可以表示 +0 和 -0。</description>
    </item>
    
    <item>
      <title>Choosing a Rust web framework, 2020 edition</title>
      <link>https://notes.0081800.xyz/notes/20200710101214-web/</link>
      <pubDate>Fri, 10 Jul 2020 10:12:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200710101214-web/</guid>
      <description> tags: Rust source: Choosing a Rust web framework, 2020 edition </description>
    </item>
    
    <item>
      <title>SSH</title>
      <link>https://notes.0081800.xyz/notes/20200707214623-ssh/</link>
      <pubDate>Tue, 07 Jul 2020 21:46:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200707214623-ssh/</guid>
      <description>SSH Port Forwarding -L 将远端机器的端口映射到本地 -R 将本地端口映射到远端 </description>
    </item>
    
    <item>
      <title>Fearless Concurrency with Rust</title>
      <link>https://notes.0081800.xyz/notes/20200703104039-fearless_concurrency_with_rust/</link>
      <pubDate>Fri, 03 Jul 2020 10:40:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200703104039-fearless_concurrency_with_rust/</guid>
      <description> tags: Rust 原文链接：https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html </description>
    </item>
    
    <item>
      <title>Rust Means Never Having to Close a Socket</title>
      <link>https://notes.0081800.xyz/notes/20200629181735-rust_means_never_having_to_close_a_socket/</link>
      <pubDate>Mon, 29 Jun 2020 18:17:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200629181735-rust_means_never_having_to_close_a_socket/</guid>
      <description>tags: Translate,Rust,Rust Wrapper Types 原文链接：Rust Means Never Having to Close a Socket
Rust 最酷的特性之一就是它可以自动地帮助你管理资源，同时在仍能保持安全（没有段错误）和高性能。
这是因为 Rust 是一门与众不同地编程语言，要理解我说的可能有点困难，让我来更近一步说明：
Rust 就像带垃圾回收的编程语言，你无需手动释放内存 Rust 不同于其他带垃圾回收的编程语言，你无需1手动关闭或者释放像文件、套接字和锁这样的资源 Rust 达到以上这些特性不附带任何运行时开销（垃圾回收或者引用计数），并且不牺牲安全性。 如果你曾经造成过一个套接字或者文件泄漏，或者使用过一些抽象方法造成了这些资源的泄漏，那么你就会知道这有多重要。
你可能已经期望通过“使用后释放”来避免内存问题，而与此同时你并没有考虑到没有明确地关闭套接字可能出现类似的错误。我在这里告诉你，还有更好地办法。
如果你使用的是带垃圾回收的编程语言，则应密切关注本文提到的资源管理方面的内容。如果你使用的是像 C/C++ 这样底层编程语言，你可能会对安全方面更加感兴趣。
Rust 的许多特性都是从其他语言借鉴而来。Rust 之所以变得有趣是因为它把所有的这些特性放在了一起，并且在编程语言层面实现了更严格地保证。 实际上，这种编程语言层面的保证让这些特性更加实用。
所有权系统（The Ownership System） 让这种保证工作的方式是通过 Rust 的「所有权（ownership）」系统。不管任何时候你创建一个新的对象，都被创建它的「作用域（scope）」所拥有。
让我们通过一个例子来进一步说明：我们定义一个函数，函数拷贝输入文件到临时文件去处理它，然后拷贝输入文件到输出文件。
fn process(from: &amp;amp;Path, to: &amp;amp;Path) -&amp;gt; IoResult&amp;lt;()&amp;gt; { // creates a new tempdir with the specified suffix let tempdir = try!(TempDir::new(&amp;#34;skylight&amp;#34;)); // open the input file let mut from_file = try!</description>
    </item>
    
    <item>
      <title>Rust 并发</title>
      <link>https://notes.0081800.xyz/notes/20200629180709-rust_%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Mon, 29 Jun 2020 18:07:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200629180709-rust_%E5%B9%B6%E5%8F%91/</guid>
      <description>并发 std::marker::Send 允许跨线程转移所有权 Send 标记特性用于标识实现该特性的类型的所有权可以在线程中间转移，几乎所有 Rust 类型都实现了 Send ，但是也有一些例外如：
Rc&amp;lt;T&amp;gt; ，如果克隆后在多个线程中转移所有权可能会多个线程同时增加计数器，可以使用 Arc&amp;lt;T&amp;gt; 替代 如果一个新的类型组合的类型都实现了 Send 那么该类型也自动实现了 Send ，几乎所有原始类型都实现了 Send .
std::marker::Sync 允许多个线程同时访问 Sync 标记特性用于标识实现该特性的类型可以在多个线程中引用，任何类型 T 是 Sync 并且 T 的引用 &amp;amp;T 是 Send 则意味着引用可以安全的发送给其他线程。
同 Send 类似，几乎所有原始类型都实现了 Sync ，组合了所有类型都是 Sync 的类型自动实现 Sync 。
以下只能指针没有实现 Sync
Rc&amp;lt;T&amp;gt; 同样没有实现 Sync RcCell&amp;lt;T&amp;gt; 和 Cell&amp;lt;T&amp;gt; 自己实现 Sync 和 Send 是不安全的 </description>
    </item>
    
    <item>
      <title>Rust 宏</title>
      <link>https://notes.0081800.xyz/notes/20200629180623-rust_%E5%AE%8F/</link>
      <pubDate>Mon, 29 Jun 2020 18:06:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200629180623-rust_%E5%AE%8F/</guid>
      <description>三种宏 自定义 #[derive] 属性行为（attribute-like）宏，Rust 属性宏解析 函数行为（function-like）宏 宏 实现元编程，代码生成代码，必须带入当前命名空间内才能使用（不能使用 mod::sub::macro! 这种方式调用）。
#[macro_export] macro_rules! vec { ( $($x:expr), *) =&amp;gt; { // $() 用于捕捉值，$x:expr 匹配 Rust 表达式并绑定到 $x，逗号（,）表明一个逗号可能出现在表达式后面，* 表明表达式匹配一次或多次 { let mut temp_vec = Vec::new(); ${ temp_vec.push($x); }* temp_vec } }; } 调用宏用于从属性生成代码 有点像编译期的装饰器：
use proc_macro; #[some_attribute] pub fn some_name(input: TokenStream) -&amp;gt; TokenStream { // --snip-- } </description>
    </item>
    
    <item>
      <title>智能指针</title>
      <link>https://notes.0081800.xyz/notes/20200629180545-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</link>
      <pubDate>Mon, 29 Jun 2020 18:05:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200629180545-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</guid>
      <description>智能指针 表现的像一个指针，拥有数据并允许在对数据进行维护。
通常通过 struct 实现并实现两个特性 Deref 和 Drop
Deref 允许智能指针实例行为像一个引用，让代码可以同时处理引用和智能指针 Drop 允许自定义智能指针超出作用域的行为。 标准库常见的智能指针
Box&amp;lt;T&amp;gt; 用于在堆分配值 Rc&amp;lt;T&amp;gt; 引用计数类型，允许多个拥有者 Ref&amp;lt;T&amp;gt; 和 RefMut&amp;lt;T&amp;gt; 和通过 RefCell&amp;lt;T&amp;gt; 访问，运行时取代编译期强制检查借用规则 Box&amp;lt;T&amp;gt; 场景：
编译期未知大小的类型（递归类型（自己包含自己类型的类型，如链表）编译期无法确定大小）
// 递归类型 enum List { Cons(i32, Box&amp;lt;List&amp;gt;), Nil, } fn main() { let b = Box::new(5); println!(&amp;#34;b = {}&amp;#34;, b); let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil)))))); } 避免大量数据转移所有权时发生拷贝
拥有一个实现特定特性的值（不关心具体类型）的所有权
Deref 用于自定义解引用操作符（ * ） 的行为，智能指针通过实现该特性来模拟普通引用的行为。
对比
fn main() { let x = 5; let y = &amp;amp;x; assert_eq!</description>
    </item>
    
    <item>
      <title>迭代器</title>
      <link>https://notes.0081800.xyz/notes/20200629180506-%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Mon, 29 Jun 2020 18:05:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200629180506-%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>迭代器 所有的迭代器都实现了 Iterator 特性：
pub trait Iterator { type Item; // 关联类型 fn next(&amp;amp;mut self) -&amp;gt; Option&amp;lt;Self::Item&amp;gt;; // 返回 None 结束循环 } </description>
    </item>
    
    <item>
      <title>生命周期</title>
      <link>https://notes.0081800.xyz/notes/20200629180413-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Mon, 29 Jun 2020 18:04:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200629180413-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>生命周期 Rust 中的每一个引用都有其生命周期：引用有效的作用域。 大部分情况下生命周期都是隐式和自举的，在无法完成的情况下就需要我们通过生命周期泛型参数帮助编译器进行注解。 生命周期的主要目标是避免悬空指针。 生命周期泛型参数定义各个引用之间（参数和参数、参数和返回值）的关系，并不改变（延长）变量原本的生命周期 &amp;amp;i32 // a reference &amp;amp;&amp;#39;a i32 // a reference with an explicit lifetime &amp;amp;&amp;#39;a mut i32 // a mutable reference with an explicit lifetime 参考以下代码
fn longest&amp;lt;&amp;#39;a&amp;gt;(x: &amp;amp;&amp;#39;a str, y: &amp;amp;&amp;#39;a str) -&amp;gt; &amp;amp;&amp;#39;a str { if x.len() &amp;gt; y.len() { x } else { y } } 以上代码
标注生命周期 &#39;a 函数有两个引用参数，都使用生命周期 &#39;a 表示两个参数的生命周期必须一致（存活的周期一样长） 函数返回一个引用，并且存活的时间和生命周期 &#39;a 一致 以上指定不改变任何传入的引用的生命周期，我们只是要求借用检查器（borrow checker）检查这些约束。 也就是说借用检查器要检查传入的两个引用的生命周期必须一致，返回的引用的存活周期不能超过传入的引用的存活周期 思考 当函数返回一个引用时，返回值的生命周期注解要和参数的其中之一相匹配，否则那么引用就是指向里函数内创建的值（不能返回）。 也就是说返回引用时，引用的声明周期必须和参数（其一）相关。如果想要返回函数内创建的值最好返回一个有所有权的值类型。
结构体生命周期 如果结构体需要持有引用，需要在定义结构体时给每一个引用都加上生命周期注解。</description>
    </item>
    
    <item>
      <title>闭包</title>
      <link>https://notes.0081800.xyz/notes/20200629180436-%E9%97%AD%E5%8C%85/</link>
      <pubDate>Mon, 29 Jun 2020 18:04:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200629180436-%E9%97%AD%E5%8C%85/</guid>
      <description>let add_one = | num | { num + 1 }; 由于闭包和当前上下文相关联，所以 Rust 可以进行类型推导，类型注解也就不是必要的，但是依然可以自己添加：
let add_one = | num: i32 | { num + 1 }; fn add_one_v1 (x: u32) -&amp;gt; u32 { x + 1 } let add_one_v2 = |x: u32| -&amp;gt; u32 { x + 1 }; let add_one_v3 = |x| { x + 1 }; let add_one_v4 = |x| x + 1 ; 使用 Fn 存储闭包类型
struct Cacher&amp;lt;T&amp;gt; where T: Fn(u32) -&amp;gt; u32 { calculation: T, value: Option&amp;lt;u32&amp;gt;, } impl Cacher&amp;lt;T&amp;gt; where T: Fn(u32) -&amp;gt; u32 { fn new(calculation: T) -&amp;gt; Cacher&amp;lt;T&amp;gt; { Cacher { calculation, value: None, } } fn value(&amp;amp;mut self, arg: u32) -&amp;gt; u32 { if let Some(value) = self.</description>
    </item>
    
    <item>
      <title>Traits</title>
      <link>https://notes.0081800.xyz/notes/20200629180345-traits/</link>
      <pubDate>Mon, 29 Jun 2020 18:03:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200629180345-traits/</guid>
      <description>Traits 定义行为在多个类型中共享。 可以定义默认行为在实现者中间共享。 可以用于定义参数的行为，同样可以定义返回值行为，当用 trait 限定返回值类型时，不能同时（if/else）返回多种实现了该 trait 的类型。 pub trait Summary { fn summarize(&amp;amp;self) -&amp;gt; String; } pub struct Article{ pub title: String, } impl Summary for Article { fn summarize(&amp;amp;self) -&amp;gt; String { format!(&amp;#34;{}&amp;#34;, self.title) } } pub fn notify(item: impl Summary) { println!(&amp;#34;{}&amp;#34;, item.summarize()); } // trait bound 语法糖版本 pub fn notify&amp;lt;T: Summary&amp;gt;(item: T) { println!(&amp;#34;{}&amp;#34;, item.summarize()); } 定义参数行为 通过 impl ： fn notify(item: impl TraitName) ，用于简单明了的场景，比如一个参数 通过 trait bound ： fn notify&amp;lt;T: TraitName&amp;gt; (item: T) ，用于更复杂的场景，比如多个参数用于减少代码 可以通过 + 连接： fn notify(T: TraitName + Display) (item: T)</description>
    </item>
    
    <item>
      <title>错误处理</title>
      <link>https://notes.0081800.xyz/notes/20200629180301-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 29 Jun 2020 18:03:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200629180301-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid>
      <description>enum Result&amp;lt;T, E&amp;gt; { Ok(T), Err(E), } ? 操作符 对比
use std::io; use std::io::Read; use std::fs::File; fn read_username_from_file() -&amp;gt; Result&amp;lt;String, io::Error&amp;gt; { let f = File::open(&amp;#34;hello.txt&amp;#34;); let mut f = match f { Ok(file) =&amp;gt; file, Err(e) =&amp;gt; return Err(e), }; let mut s = String::new(); match f.read_to_string(&amp;amp;mut s) { Ok(_) =&amp;gt; Ok(s), Err(e) =&amp;gt; Err(e), } } 和
use std::io; use std::io::Read; use std::fs::File; fn read_username_from_file() -&amp;gt; Result&amp;lt;String, io::Error&amp;gt; { let mut f = File::open(&amp;#34;hello.</description>
    </item>
    
    <item>
      <title>if let</title>
      <link>https://notes.0081800.xyz/notes/20200629180202-if_let/</link>
      <pubDate>Mon, 29 Jun 2020 18:02:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200629180202-if_let/</guid>
      <description>let some_u8_value = Some(0u8); // Without `if let` match some_u8_value { Some(3) =&amp;gt; println!(&amp;#34;three&amp;#34;); - =&amp;gt; (), } // With `if let` if let Some(3) = some_u8_value { println!(&amp;#34;three&amp;#34;); } </description>
    </item>
    
    <item>
      <title>模块化</title>
      <link>https://notes.0081800.xyz/notes/20200629180233-%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
      <pubDate>Mon, 29 Jun 2020 18:02:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200629180233-%E6%A8%A1%E5%9D%97%E5%8C%96/</guid>
      <description>包、crate 和模块 Cargo.toml 表示一个包
包含 0 个或 1 个库 crate（ src/lib.rs ） 包含 0 个或多个可执行 crate （ src/main.rs src/bin/*.rs ） 可以同时包含以上两种 模块化系统
模块，一种组织代码和控制路径隐私的方法
所有的项（函数，方法，结构体，枚举，模块和常量）默认私有 不允许使用私有的子模块的代码 可以使用父模块和同级模块的代码 路径，一种命名项的方法
use , 一个将路径带到当前作用域的关键字
pub ，一个将项公开的关键字
as ，一个将带到当前作用域项重命名的关键字
super , 一个相当于文件系统里 .. 作用的关键字
* ，通配符用于使用制定路径下的所有项
pub use 用于重新暴露可以访问的模块
模块可以放在一个文件，也可以按照一定规则拆分到不同文件下
使用同一个 use 清理嵌套的 use
use std::cmp::Ordering; use std::io; use std::{cmp::Ordering, io}; use std::io; use std::io::Write; use std::{self, Write}; mod sound { pub mod instrument { pub mod woodwind { pub fn clarinet() { super::breathe_in(); } } fn breathe_in() { } } mod voice { } } fn main() { // 绝对路径以 crate 开始，crate 表示根 crate::sound::instrument::woodwind::clarinet(); // 相对路径 sound::instrument::woodwind::clarinet(); } 上面例子 sound 模块并非公开，但是由于 main 和 sound 定义在同一模块下，所以允许在 main 中引用 sound 。</description>
    </item>
    
    <item>
      <title>模式匹配</title>
      <link>https://notes.0081800.xyz/notes/20200629180131-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Mon, 29 Jun 2020 18:01:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200629180131-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</guid>
      <description>#[derive(Debug)] enum UsState { Alabama, Alaska, } enum Coin { Penny, Nickel, Dime, Quarter(UsState), } fn value_cents(coin: Coin) -&amp;gt; u8 { match coin { Coin::Peny =&amp;gt; { println!(&amp;#34;Lucy penny!&amp;#34;); 1 }, Coin::Nickel =&amp;gt; 5, Coin::Dime =&amp;gt; 10, Coin::Quarter(state) =&amp;gt; { println!(&amp;#34;State quarter from {:?}!&amp;#34;, state); 25 }, } } // Option fn plus_one(x: Option&amp;lt;i32&amp;gt;) -&amp;gt; Option&amp;lt;i32&amp;gt; { match x { None =&amp;gt; None, Some(i) =&amp;gt; Some(i + 1), } } let five = Some(5); let six = plus_one(five); let none = plus_one(None); 编译器会检查 match 覆盖所有情况， _ 可以用于所有未覆盖的情况。</description>
    </item>
    
    <item>
      <title>枚举</title>
      <link>https://notes.0081800.xyz/notes/20200629180041-%E6%9E%9A%E4%B8%BE/</link>
      <pubDate>Mon, 29 Jun 2020 18:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200629180041-%E6%9E%9A%E4%B8%BE/</guid>
      <description>多种类型的集合体，一个类型的变量可以存储多种类型的值，枚举的每一项都是该枚举类型的变体：
enum IpAddrKind { V4, V6, } fn main() { route(IpAddrKind::V4); route(IpAddrkind::V6); } fn route(kind: IpAddrKind) { // ... } 枚举的每一个变体都可以直接包含数据，并且每一个变体可以包含不同的数据类型和不同的数量，甚至可以直接放结构体（也可以是匿名的）。
struct Ipv4Addr { // --snip-- } enum IpAddr { V4(Ipv4Addr), V6(String), } let home = IpAddr::V4(127, 0, 0, 1); let loopback = IpAddr::V6(String::from(&amp;#34;::1&amp;#34;)); struct Message { Quit, Move{ x: i32, y: i32 }, // anonymous struct Write(String), ChangeColor(i32, i32, i32), // three i32 values } 枚举也可以通过 impl 实现方法</description>
    </item>
    
    <item>
      <title>结构体</title>
      <link>https://notes.0081800.xyz/notes/20200629175956-%E7%BB%93%E6%9E%84%E4%BD%93/</link>
      <pubDate>Mon, 29 Jun 2020 17:59:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200629175956-%E7%BB%93%E6%9E%84%E4%BD%93/</guid>
      <description>结构体 元组结构体（tuple struct） 用于命名元组并和其他元组进行区分：
struct Color(i32, i32, i32); struct Point(i32, i32, i32); let black = Color(0, 0, 0); let origin = Point(0, 0, 0); 由于定义了元组结构体所有 black 和 origin 是两个不同的类型。
没有字段的结构体：类单元（Unit-Like）结构体 没有任何字段的结构体和单元类型 () 类似，用于实现一些特性（trait）但是没有任何数据。
方法语法 self 占有所有权
&amp;amp;self 不可变借用
&amp;amp;mut self 可变借用
自动引用和解引用
在 Rust 中进行方法调用，如 object.something ，Rust 会自动添加 &amp;amp; &amp;amp;mut 或者 * , 用以自动匹配方法签名。以下是等价的：
p1.distance(&amp;amp;p2); (&amp;amp;p1).distance(&amp;amp;p2); 方法如果不声明 self 行参则是一个关联方法（静态方法），通过 :: 调用
struct Rectangle { width: u32, height: u32, } impl Rectangle { fn square(size: u32) -&amp;gt; Rectangle { Rectangle{ width: size, height: size } } } let r = Rectangle::square(10); 每一个结构体可以有多个 impl 块。</description>
    </item>
    
    <item>
      <title>引用和借用</title>
      <link>https://notes.0081800.xyz/notes/20200629174943-%E5%BC%95%E7%94%A8%E5%92%8C%E5%80%9F%E7%94%A8/</link>
      <pubDate>Mon, 29 Jun 2020 17:49:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200629174943-%E5%BC%95%E7%94%A8%E5%92%8C%E5%80%9F%E7%94%A8/</guid>
      <description>类型前置 &amp;amp; 表示引用，引用允许变量指向一个值但是不发生所有权转移。 引用不占有所有权，所以变量超出作用域之后不会触发 drop 调用。 引用作为函数形参被成为借用（borrowing） 可变引用 针对特定作用域下的特定数据只能创建一个可变引用。如果要创建多个可变引用可以通过大括号创建新的作用域
let mut s = String::from(&amp;#34;hello&amp;#34;); { let s1 = mut &amp;amp;s; } let s2 = mut &amp;amp;s; 当已经存在不可变引用时，则无法再创建可变引用，下面代码无法编译通过
let mut s = String::from(&amp;#34;hello&amp;#34;); let s1 = &amp;amp;s; // OK let s2 = &amp;amp;s; // OK let s3 = mut &amp;amp;s; // BIG PROBLEM 悬空引用 以下代码是不允许的，无法编译通过
fn main() { let s = dangling_string(); } fn dangling_string() -&amp;gt; &amp;amp;String { let s = String::from(&amp;#34;hello&amp;#34;); &amp;amp;s } 上面代码 s 在函数内部分配，那么在函数执行完成后 s 将被释放，所以返回 s 的引用会造成悬空引用。</description>
    </item>
    
    <item>
      <title>所有权</title>
      <link>https://notes.0081800.xyz/notes/20200629174911-%E6%89%80%E6%9C%89%E6%9D%83/</link>
      <pubDate>Mon, 29 Jun 2020 17:49:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200629174911-%E6%89%80%E6%9C%89%E6%9D%83/</guid>
      <description>规则 每个值都有一个变量叫做所有者（owner） 同一时间只能有一个所有者 当所有者超出作用域则值被销毁 变量作用域 作用域是一个变量有效的范围 当变量超出作用域范围自动调用对象的 drop 方法进行内存归还操作 变量相互作用：所有权转移（Move） 对于所有在栈上分配的值（固定大小），在进行赋值操作时都对值进行拷贝：
let x = 5; ley y = x; // copy 5 to y 但是对于在堆上分配的，变量保存的是指向内存的指针，所以在赋值时拷贝的也是指向该内存的指针：
let s1 = String::from(&amp;#34;hello&amp;#34;); let s2 = s1; 为了保证内存安全，防止 s1 和 s2 超出作用域范围调用两次 drop 造成重复的内存回收，Rust 会让 s1 不再有效，来避免对 s1 进行回收。继续使用 s1 会导致编译错误。这种情况叫做所有权转移（move）。
变量相互作用：克隆（Clone） 克隆用于深度拷贝变量：
let s1 = String::from(&amp;#34;hello&amp;#34;); let s2 = s1.clone(); println!(s1); 变量项目作用：拷贝（Copy） 如果数据类型的大小在编译期能够确定都将存储在栈上，这种情况下能够进行快速的拷贝。
Copy 特性（trait）注解用于将值存贮在栈栈上 Copy 特性注解不能和 Drop 特性注解混用 Copy 特性注解使用规则如下 所有的数字类型 所有的布尔型 所有的浮点型 字符类型 所有元素都实现了 Copy 特性注解的元祖 所有权和函数 函数传递实参的规则和变量类似，传递变量到一个函数将为发生所有权转移或者拷贝。</description>
    </item>
    
    <item>
      <title>语句和表达式</title>
      <link>https://notes.0081800.xyz/notes/20200629174820-%E8%AF%AD%E5%8F%A5%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Mon, 29 Jun 2020 17:48:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200629174820-%E8%AF%AD%E5%8F%A5%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>Rust 区分语句和表达式， Rust 是基于表达式的语言：
语句：执行动作并且不返回值
使用 let 声明变量是语句，所以 let 语句不返回值，也就不能像 Python 那样将 let 语句赋值给其他变量 函数声明也是语句 表达式：计算并返回值，不以分号（;）结尾
5 + 6 是一个表达式，计算并返回值 11
表达式可以作为语句的一部分
函数调用是表达式
宏调用是表达式
用 {} 创建的块也是表达式
let x = { let y = 6; y + 5 } if loop while for 是表达式
在表达式后面增加分号（;）可以将一个表达式转为语句。</description>
    </item>
    
    <item>
      <title>Member initialize</title>
      <link>https://notes.0081800.xyz/notes/20200628183417-member_initialize/</link>
      <pubDate>Sun, 28 Jun 2020 18:34:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200628183417-member_initialize/</guid>
      <description> tags: C/C++ 如果类成员属性是值类型或者引用类型则需要改对象有无参数构造方法，否则类无法实例化， 这是因为这类成员属性在构造函数调用之前就需要进行初始化。
下面代码无法通过编译
class Foo { public: Foo(int n) : n {n} { }; ~Foo() { }; private: int n; }; class Bar { public: Bar(int n) { this-&amp;gt;foo = Foo(n); }; ~Bar(); private: Foo &amp;amp; foo; }; </description>
    </item>
    
    <item>
      <title>Iterator class</title>
      <link>https://notes.0081800.xyz/notes/20200628183227-iterator_class/</link>
      <pubDate>Sun, 28 Jun 2020 18:32:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200628183227-iterator_class/</guid>
      <description> tags: C/C++ 容器类实现 begin 和 end 方法返回 Iterator class 的实例， Iterator class 通过实现友元类可以直接访问容器类的私有属性， Iterator class 通过重载 ++/==/* 等操作符实现对容器类的访问并通过自己的私有属性记录当前位置。
Iterator class 重载的操作符：
++ 移动容器元素位置 == 判断两个容器位置是否相等（容器是否一个，位置是否一个） * 解引用返回当前位置指向的容器的值 </description>
    </item>
    
    <item>
      <title>SSE/AVX/AVX2/AVX512</title>
      <link>https://notes.0081800.xyz/notes/20200628182211-avx512/</link>
      <pubDate>Sun, 28 Jun 2020 18:22:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200628182211-avx512/</guid>
      <description> tags: Computer Systems,C/C++,优化,High Performance 部分 intel CPU 支持向量指令集同时进行多路整数和浮点数计算，以此来进行对相关算法进行优化，这里整理相关链接：
编译器支持相关封装避免编写汇编代码，官方指南：Intrinsics Guide 基于 sse_mathfun 的 avx_mathfun 封装相关宏和函数 mp3 库 lame 中的 SSE 加速实现 libmp3lame/vector/xmm_quantize_sub.c AVX512 VNNI https://en.wikichip.org/wiki/x86/avx512_vnni </description>
    </item>
    
    <item>
      <title>优化</title>
      <link>https://notes.0081800.xyz/notes/20200628182150-%E4%BC%98%E5%8C%96/</link>
      <pubDate>Sun, 28 Jun 2020 18:21:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200628182150-%E4%BC%98%E5%8C%96/</guid>
      <description> AVX512 </description>
    </item>
    
    <item>
      <title>CMake</title>
      <link>https://notes.0081800.xyz/notes/20200628123035-cmake/</link>
      <pubDate>Sun, 28 Jun 2020 12:30:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200628123035-cmake/</guid>
      <description>tags: C/C++,Programming Tools
安装的头文件必须包含在目标的源代码中，否则构建如 iOS 的 Framework 时无法正确包含头文件
ADD_LIBRARY(test test.h) CMake 生成 C++ LSP 配置文件</description>
    </item>
    
    <item>
      <title>Build System</title>
      <link>https://notes.0081800.xyz/notes/20200628122958-build_system/</link>
      <pubDate>Sun, 28 Jun 2020 12:29:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200628122958-build_system/</guid>
      <description> CMake </description>
    </item>
    
    <item>
      <title>Emacs Tmux 256 colors</title>
      <link>https://notes.0081800.xyz/notes/20200603103943_tmux_256_colors/</link>
      <pubDate>Wed, 03 Jun 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200603103943_tmux_256_colors/</guid>
      <description>tags: Emacs 生成 terminfo
$ cat &amp;lt;&amp;lt;EOF &amp;gt; terminfo-24bits.src # Use semicolon separators. xterm-24bits|xterm with 24-bit direct color mode, use=xterm-256color, Tc, setb24=\E[48;2;%p1%{65536}%/%d;%p1%{256}%/%{255}%&amp;amp;%d;%p1%{255}%&amp;amp;%dm, setf24=\E[38;2;%p1%{65536}%/%d;%p1%{256}%/%{255}%&amp;amp;%d;%p1%{255}%&amp;amp;%dm,]] EOF $ tic -x -o ~/.terminfo terminfo-24bits.src 通过 xterm-24bits 启动 Emacs
$ env TERM=xterm-24bits emacs Emacs 通过 list-color-display 查看效果。</description>
    </item>
    
    <item>
      <title>Rust Trait Object</title>
      <link>https://notes.0081800.xyz/notes/20200329204833_rust_trait_object/</link>
      <pubDate>Sun, 29 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200329204833_rust_trait_object/</guid>
      <description> tags: Rust 动态大小类型（DST）和 Sized 特性 str （非 &amp;amp;str ）就是一个 DST，我们不能在运行时得知 str 的大小。 &amp;amp;str 是一个指针类型，大小是已知的。
DST：拥有额外的元数据存储动态大小的信息。
每一个特性都是一个是个 DST，使用 Trait Object 必须是像 &amp;amp;dyn Trait 和 Box&amp;lt;dyn Trait&amp;gt; （或 Rc&amp;lt;dyn Trait&amp;gt; ）的指针类型。
dyn 关键字 dyn 关键字用于将 Trait Object 指针和普通的结构体指针区分开来。
Sized vs ?Sized Rust 有一个特定的特性叫做 Sized 去判断一个类型的大小是否是编译期可知的，并且自动在编译期为所有已知大小的类型实现， 同时 Rust 隐式的为泛型函数的类型参数加上 Sized 的限制（bound），下面这样的泛型函数：
fn generic&amp;lt;T&amp;gt;(t: T) { // --snip-- } 实际上相当于像下面这样硬编码：
fn generic&amp;lt;T: Sized&amp;gt;(t: T) { // --snip-- } 也可以通过下面特定的语法取消这个限制：
fn geneic&amp;lt;T: ?Sized&amp;gt;(t: &amp;amp;T) { // --snip-- } </description>
    </item>
    
    <item>
      <title>Rust Wrapper Types</title>
      <link>https://notes.0081800.xyz/notes/20200325165657_rust_wrapper_types/</link>
      <pubDate>Wed, 25 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200325165657_rust_wrapper_types/</guid>
      <description> tags: Rust </description>
    </item>
    
    <item>
      <title>《架构整洁之道》读书笔记</title>
      <link>https://notes.0081800.xyz/notes/20200323104907_%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/</link>
      <pubDate>Mon, 23 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200323104907_%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/</guid>
      <description>tags: 读书笔记,系统架构 第一遍粗读 三个编程范式：结构化编程、面向对象编程、函数式编程
每个编程范式都是增加限制：
结构化编程限制了 goto 面向对象编程限制了函数指针 函数式编程限制可变变量（变量不可修改） 设计原则：SOLID</description>
    </item>
    
    <item>
      <title>SOLID</title>
      <link>https://notes.0081800.xyz/notes/20200323101418_solid/</link>
      <pubDate>Mon, 23 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200323101418_solid/</guid>
      <description>SRP: Single Responsibility Principle 浅显的解释是软件模块只提供单一功能
更进一步任何一个软件模块都应该有且只有一个被修改的原因
再更进一步这个原则是关于人（Actor）的
任何一个软件模块都应该只对一个用户或系统利益相关者负责。
最终就是任何一个软件模块都应该只对某一类行为负责
OCP：Open/Closed Principle 设计良好的软件应该易于扩展，同时抗拒修改。也就是说一个软件模块应该允许在不修改源码的情况下扩展它的行为。
可以通过组合 SRP（代码分组）和调整依赖关系实现（DIP）。如果 A 组件不想被 B 组件上发生的修改所影响，那么就应该让 B 组件依赖于 A 组件。
LSP：Liskov Substitution Principle 里氏替换原则：多态。
每个类型是 S 的对象 o1 都存在一个类型为 T 的对象 o2，能使操作 T 类型的程序 P 在用 o2 替换 o1 时行为保持不变，我们就可以将 S 称为 T 的子类型。
public class LiskovSub { public static main(String[] args) { T o1 = new S(); T o2 = new T(); P(o1); // ok P(o2); // ok } public static P(T o) { o.</description>
    </item>
    
    <item>
      <title>系统架构</title>
      <link>https://notes.0081800.xyz/notes/20200322143810_%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Sun, 22 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200322143810_%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</guid>
      <description> tags: 技术 设计原则 SOLID
好的架构 我认为好的架构 能够无心智障碍的编写运行单元测试 从一起作业看好的架构 应该能够让任何开发人员方便的随时上线和回滚 面对上线对基础设施没有心理压力 完备的监控 </description>
    </item>
    
    <item>
      <title>《百箭穿杨》读书笔记</title>
      <link>https://notes.0081800.xyz/notes/20200320180837_%E7%99%BE%E7%AE%AD%E7%A9%BF%E6%9D%A8/</link>
      <pubDate>Fri, 20 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200320180837_%E7%99%BE%E7%AE%AD%E7%A9%BF%E6%9D%A8/</guid>
      <description>需要熟悉股市相关概念进行扫盲。
粗读要点 树立安全边际，跟随格雷厄姆 寻找好的困难股，降低触底难度，加大触底区间，预测底部区间，分 5 档抄底，最好在 1-3 档就能完成抄底 每次只买总资产的 1% 盈利后可以将本金提出，只留底仓等待顶峰信号后抛出赚取高额利润的前提下保障本金 总是留 25%-40% 的现金 做长线 分析财报看毛利、营收增长率、负债率可以确定一个好股，然后就等一些情况下这只股遇到困难触底 看行业处于哪个周期：萌发、成长啥的 不做重仓 复读要点完善 安全边际 跟随格雷厄姆
偏离：更保守或更激进 大赚小赔不如小赚不赔：不亏钱 困境好企 做有把握的事，不啃硬骨头，广撒网，多捞鱼，选取一批困境好企来实现从小盘大稳定增长股
行业中的好企业标准
行业很关键
需求无限，供给有限
关注行业周期
大周期：新生-&amp;gt;成长-&amp;gt;成熟-&amp;gt;衰落-&amp;gt;消亡 小周期：大周期各个过程中的景气与萧条（一两年、三五年甚至一二十年）
消亡之前会有死灰复燃，大周期中成长阶段会有萧条，注意区分。
门槛高，竞争少
只有少数寡头，估值会高
唯一或第一
成熟行业比较简单，成长行业比较困难。
通过企业原则、经营原则、财务原则和市场原则衡量。- P28 生活经验活常识也很重要。
落难好企
行业顺境，某些原因导致的猜疑导致股价下跌 行业遭遇整体困境：偶然事件，反转时间比好把握 个股困境，主打产品破灭：有无法度过的风险 财务数据衡量困境好企能否度过难关 - P32
负债率越低越好：不能超过 50% 资产中的现金越多越好：高于股东权益的 1/3，刚上市的好过上市很久的老企业（把钱折腾光了） 产品的毛利率越高越好：市场有需求 应收账款越少越好：钱可能收不回来 通过季报发现反转时机
季报时间长，抗短期干扰，一季度定调、二季度（半年）纠偏或修正、三季度出结果（更好或更差）、四季度（年报）成果汇报和新的起点用于比较第一季度。
一季度和半年狠重要。
通过 营业收入 发现转机。困境表现为净利润增速下滑，之前是好企可能会市盈率过高。
容错寻底 不亏钱的情况下寻找极限底部，保障安全、带来最大利润、带来良好心态
变种“不破买价”：买入的价格很难再跌回原来的位置
变成左侧交易者，不追涨
大盘底与个股底的关系
同步性：大盘筑底个股也在筑底，大盘达到最低位时，个股也先后到达最低位
差异性
大盘下跌蓝筹股先跌到位，大盘下跌过程中小盘成长股与稳定增长股少许跟跌或逆市上扬。 市场反弹小盘成长股与稳定增长股开始杀跌。
耦合性：大盘底出现时次新股出现底部的概率大，老股形成底部可能需要好几年 &amp;ndash; P56</description>
    </item>
    
    <item>
      <title>Kafka</title>
      <link>https://notes.0081800.xyz/notes/20200320172022_kafka/</link>
      <pubDate>Fri, 20 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200320172022_kafka/</guid>
      <description>tags: Bigdata 相关知识点 概念组成 Producer 消息产生者，往指定 Topic 的指定 Partition 发送消息
Consumer Group 消费指定 Topic 的消息
Consumer 消费指定 Topic 下某一分区的消息 Topic 区分不同消息主题
Partition 保证同一分区的有序性 Connector
消息可被不同的 Consumer Group 重复消费（广播或订阅）。同一 Consumer Group 下的不同 Consumer 分别消费不同的 Partition，Consumer 数量不能超过 Partition 数量。
数据被持久化并分片成功后发送 ACK 保证里数据不被丢失。
设计 持久化 基于文件系统
基于队列是顺序的和磁盘的顺序访问要比内存的随机访问要快（参见 The Pathologies of Big Data）， Kafka 采用在磁盘文件系统上尾部写头部读的方式。 Kafka 没有采用 BTree 存储数据因为 BTree 的操作是 O(log N) ，而且对磁盘的 seek 操作要慢，且同时只能进行一次限制了并行，所以实际操作比 O(log N) 要慢 基于磁盘的顺序访问进行在尾部写和头部读，可以实现读写都是 O(1) 的时间复杂度，并且读写互不干扰 基于以上实现，Kafka 可以不必在消息一经消费就删除，而是可以保留消息一段相对较长的时间（比如一周） 高效</description>
    </item>
    
    <item>
      <title>LeetCode</title>
      <link>https://notes.0081800.xyz/notes/20200320172132_leetcode/</link>
      <pubDate>Fri, 20 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200320172132_leetcode/</guid>
      <description> tags: Learning,Algorithm </description>
    </item>
    
    <item>
      <title>LeetCode: Trapping Tain Water</title>
      <link>https://notes.0081800.xyz/notes/20200320172219_leetcode_trapping_tain_water/</link>
      <pubDate>Fri, 20 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200320172219_leetcode_trapping_tain_water/</guid>
      <description> tags: LeetCode </description>
    </item>
    
    <item>
      <title>Linux Virtual Memory Management</title>
      <link>https://notes.0081800.xyz/notes/20200320174700_linux_virtual_memory_management/</link>
      <pubDate>Fri, 20 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200320174700_linux_virtual_memory_management/</guid>
      <description>tags: Linux 原文连接：Linux Virtual Memory Management Chapter 2 Describing Physical Memory：描述物理内存 独立于平台架构的方式描述内存 — 更好的支持多平台
本章包含描述存储器、内存页的结构体（structures）和一些影响 VM 行为的标识位（flags）
VM 中普遍（prevlent）认为第一重要（principal）的概念是 NUMA。
大型机器中内存访问速度取决于 CPU 到内存的距离。比如一组（bank）内存分配给每一个处理器或者一组内存非常适合靠近的 DMA 设备卡。
这里的每组（bank）内存被称为节点（node）并且这个概念在 Linux 中通过 struct pglist_data（typedef pg_data_t) 表示，即使在 UMA 架构下也是如此。每一个节点是一个由 NULL 结尾的链表，通过 pg_data_t-&amp;gt;next_node 指向下一个节点。
每一个节点都被分割成多个块（block）称为分区（zone）用于表示内存中的范围。分区使用 struct zone_struct(typedef zone_t) 结构体描述，每一个分区都是以下三种类型的一种
ZONE_DMA 开始 16MB 内存，供 ISA 设备使用 ZONE_NORMAL 16MB - 896MB，由内核直接映射到线性地址空间的上部区域（将在第四章讨论） ZONE_HIGHMEM 896MB - END，剩余不由内核直接映射的系统可用内存， 大部分内核操作都只能使用这种类型的分区，所以这里也是这里也是最关键的性能区域（most performance critical zone） 每一个物理页帧（physical page frame）都使用结构体 struct page 表示，所有的结构体都保存在全局数组 mem_map 中，mem_map 通常存储在 ZONE_NORMAL 的开始处；</description>
    </item>
    
    <item>
      <title>动态规划</title>
      <link>https://notes.0081800.xyz/notes/20200320171538_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Fri, 20 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200320171538_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>tags: Algorithm 状态转移方程 无后效性 如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响。
一旦 \(f(n)\) 确定，“我们如何凑出 \(f(n)\) ”就再也用不着了：
要求出 \(f(15)\)，只需要知道 \(f(14)\),\(f(10)\),\(f(4)\) 的值， 而 \(f(14)\),\(f(10)\),\(f(4)\) 是如何算出来的，对之后的问题没有影响。 “未来与过去无关”，这就是无后效性。
最优子结构 大问题的最优解可以由小问题的最优解推出，这个性质叫做“最优子结构性质”：
\(f(n)\) 的定义需要蕴含“最优”，利用 \(f(14)\),\(f(10)\),\(f(4)\) 的最优解，我们即可算出 \(f(15)\) 的最优解。
能将大问题拆成几个小问题，且满足无后效性、最优子结构性质。 DP 思路 参见 LeetCode 讨论：
先写出穷举的方法 找出不必要的重复计算 写出 DP 练习 0x00 硬币找零 描述 假设有几种硬币，如1、3、5，并且数量无限。请找出能够组成某个数目的找零所使用最少的硬币数。
状态转移公式 公式 \(f(n)=min\{f(n-1),f(n-3),f(n-5)\} + 1\)
检查是否满足上面提到的两个特性：
无后效性：对于 \(n\)，一旦 \(f(n)\) 确定，以后只关心 \(f(n)\) 的值，不关心怎么计算的； 最优子结构：对于 \(n\)，只要 \(n - 1\) \(n - 3\) \(n - 5\) 能是最优解，那么就能计算出 n; 推导过程 假设找零 15：</description>
    </item>
    
    <item>
      <title>归并排序</title>
      <link>https://notes.0081800.xyz/notes/20200320173033_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Fri, 20 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200320173033_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</guid>
      <description>tags: Algorithm,Sorting Wikipedia: 归并排序</description>
    </item>
    
    <item>
      <title>算法</title>
      <link>https://notes.0081800.xyz/notes/20200320171501_%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 20 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200320171501_%E7%AE%97%E6%B3%95/</guid>
      <description> alias: Algorithm </description>
    </item>
    
    <item>
      <title>Let&#39;s Encrypt</title>
      <link>https://notes.0081800.xyz/notes/20200319221212_let_s_encrypt/</link>
      <pubDate>Thu, 19 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200319221212_let_s_encrypt/</guid>
      <description>tags: Over the Wall,HTTPs 这里以新增 vd.linuxzen.com 为例。
新增 DNS 解析 通过 DNSPOD 新增 DNS 解析 A 记录 调整 Nginx 新增 HTTP 站点 Nginx 参考配置
server { listen 80; server_name vd.linuxzen.com; include /etc/nginx/snippets/letsencrypt-acme-challenge.conf; } 新增签发证书 $ acme.sh --force --issue -d linuxzen.com -d www.linuxzen.com -d cwiki.linuxzen.com -d monitor.linuxzen.com -d v.linuxzen.com -d vd.linuxzen.com -d d.linuxzen.com -d piwik.linuxzen.com -d t.linuxzen.com -d wiki.linuxzen.com -d note.linuxzen.com -w /var/www/letsencrypt/ 安装证书
$ acme.sh --install-cert -d linuxzen.com --cert-file /etc/nginx/certs/linuxzen.</description>
    </item>
    
    <item>
      <title>Over the Wall</title>
      <link>https://notes.0081800.xyz/notes/20200319224041_%E7%BF%BB%E5%A2%99/</link>
      <pubDate>Thu, 19 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200319224041_%E7%BF%BB%E5%A2%99/</guid>
      <description></description>
    </item>
    
    <item>
      <title>V2Ray</title>
      <link>https://notes.0081800.xyz/notes/20200319215535_v2ray/</link>
      <pubDate>Thu, 19 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200319215535_v2ray/</guid>
      <description>tags: Over the Wall,Tools 架构 Client -&amp;gt; DIDIYun(HAProxy) -&amp;gt; HK
滴滴云 HAPorxy 配置 117.51.146.119
frontend v_linuxzen_com bind *:6697 option tcplog mode tcp default_backend v_linuxzen_com_nodes backend v_linuxzen_com_nodes mode tcp balance roundrobin option ssl-hello-chk server webserver1 45.115.36.35:443 check 客户端改动 需要调整 hosts
$ echo &amp;#39;117.51.146.119 v.linuxzen.com&amp;#39; | sudo tee -a /etc/hosts HK V2Ray Docker 启动 $ docker run -d -p 127.0.0.1:25001:25001 --name v2ray --restart always -v /etc/v2ray:/etc/v2ray v2ray/official HK Let&amp;rsquo;s Encrypt 证书 $ acme.</description>
    </item>
    
    <item>
      <title>xinetd</title>
      <link>https://notes.0081800.xyz/notes/20200319223026_xinetd/</link>
      <pubDate>Thu, 19 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200319223026_xinetd/</guid>
      <description>tags: Over the Wall,Network xinetd 代理 SMTP 和 IMAP 通过 xinetd 代理 SMTP 和 IMAP 实现 gmail 翻墙。
配置服务端
service imap { type = UNLISTED port = 993 bind = 0.0.0.0 socket_type = stream wait = no user = nobody redirect = imap.gmail.com 993 per_source = UNLIMITED cps = 100 2 } service smtp-465 { type = UNLISTED port = 465 bind = 0.0.0.0 socket_type = stream wait = no user = nobody redirect = smtp.</description>
    </item>
    
    <item>
      <title>股市相关概念</title>
      <link>https://notes.0081800.xyz/notes/20200318160435_%E8%82%A1%E5%B8%82%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Wed, 18 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200318160435_%E8%82%A1%E5%B8%82%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</guid>
      <description>股分类 个股：投资资金来自个人的股票（还有国家股、法人股）
蓝筹股：明星股
小盘
市值比较低的股票
小盘价值股：格低于价值的股票，被低估的股票，长期看来值得投资的股票。 小盘成长股：成长潜力很大，公司发展处于较快阶段，但不确定性也比较高，业绩波动可能会很大。 稳定增长股：小盘具有一定品牌效应后的快销品，达到一定统治地位，最好在行业的繁荣周期顶峰卖出
周期股
相关指标 市盈率（P/E 或 PER）= 每股市值 / 每股盈余
每股市价处于每股盈余（EPS），评估股价是昂贵还是便宜。市盈率越低代表投资者能够以相对较低的价格购入股票。
Wikipedia: https://zh.wikipedia.org/wiki/%E5%B8%82%E7%9B%88%E7%8E%87
市净率（PBR，P/B） = 总市值 / 净资产
评估高风险企业，企业资产大量为实物资产的企业时收到重视。
市销率（PSR，P/S） = 总市值 / 营收
公司市值除以上一财年（或季度）的营业收入，或等价地，以公司股价除以每股营利收入，越小（小于 1）通常被认为投资价值越高。可以付出比单位营收更少的钱购买股票。 Wikipedia: https://zh.wikipedia.org/zh-hans/%E5%B8%82%E9%94%80%E7%8E%87
相关链接
简单直观的解释一下市盈率和市净率的意思 </description>
    </item>
    
    <item>
      <title>基金定投</title>
      <link>https://notes.0081800.xyz/notes/20200311093314_%E5%9F%BA%E9%87%91%E5%AE%9A%E6%8A%95/</link>
      <pubDate>Wed, 11 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200311093314_%E5%9F%BA%E9%87%91%E5%AE%9A%E6%8A%95/</guid>
      <description> 适合人群：穷人、笨人、忙人、好人
为什么
通胀太高，股票战胜通胀的重要工具 绝大多数人不具备择时能力 避免高点买入 核心逻辑：放弃择时，持续小额买入，降低成本
缺点：在市场上涨、高位震荡过程中，虽然盈利大幅提高，但持仓成本也在快速提高。一旦市场转向熊市，整体会迅速亏本。
单边上涨：定投盈利少于一次性投资 先震荡后上涨：定投盈利少于一次性投资 先上涨后下跌：定投亏损多于一次性投资 单边下跌：定投亏损少于一次性投资 震荡：定投与一次性投资持平 先下跌再震荡：定投亏损少于一次性投资 除了坚持，还在于止盈策略，牛市中成本不断提高，需要及时止盈，防止下跌时候的亏损 错误理念
定投不是万能，需要防止“倒微笑曲线周期” 巴菲特说指数基金难以超越仅限于美股，A 股与之相反 定投组合包含债券基金：定投适合波动较大的权益类资产（股票、商品），债卷等固定收益类产品本身波动小，一次性买入和定投基本没区别 月定投不够还要周定投：基本没差别 定投是懒人投资，坚持即可：还需要主动管理，如定投的标的不再适合定投，该换要换。 一次性投资止损不止赢，定投止赢不止损。 定投只买开放式基金：还可以宽基指数基金、主题指数基金、行业指数基金、风格指数基金、策略指数基金、QDII 指数基金、商品指数基金。此外，还有折价的封闭式基金、定增基金，适当的配置会非常好玩。 策略
定投买入，止盈不止损： 需要在可能出现的“倒微笑曲线周期”及时止盈。 制订量化估值标准 技术分析
通过MA、MACD、RSI等各种技术指标，判断目前市场从长期看，是相对低位还是高位
趋势上涨原则：MA(30)&amp;gt;MA(60)&amp;gt;MA(120)； 趋势下跌原则：MA(30)&amp;lt;MA(60)&amp;lt;MA(120)。 均线偏离法：根据指数价格对均线偏离的程度决定投资额度的多少。
P&amp;gt;MA(120)：正偏离，减少投资额度； P&amp;lt;MA(120)：负偏离，增加投资额度。 基本面分析
根据指数相关基本面指标，判断股市处于高估或者低估。如市盈率、市净率、整体ROI等地。在股市高估时，降低投资额度，在股市低估时，增加投资额度。
定期不定额策略
在上述策略的基础上，如目前市场明显在历史地点，原来每个月投1000的，这时不妨投2000。如市场明显高估，每个月投1000的可以投500。如果涨的都害怕了，可以不投甚至卖出一部分。
产品池管理
构建“核心——卫星”组合
技巧
部分基金可以场内购买（炒股账号购买），交易时间短手续费低 Links 基金定投，看这篇就够了 </description>
    </item>
    
    <item>
      <title>Deep Learning</title>
      <link>https://notes.0081800.xyz/notes/20200310093014_deep_learning/</link>
      <pubDate>Tue, 10 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200310093014_deep_learning/</guid>
      <description> tags: AI What is the Difference Between CNN and RNN? </description>
    </item>
    
    <item>
      <title>AI</title>
      <link>https://notes.0081800.xyz/notes/20200309112015_ai/</link>
      <pubDate>Mon, 09 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200309112015_ai/</guid>
      <description> Machine Learning Deep Learning 《机器学习实战》读书笔记 How to Train Really Large Models on Many GPUs? </description>
    </item>
    
    <item>
      <title>《巴比伦富翁新解》读书笔记</title>
      <link>https://notes.0081800.xyz/notes/20200307114151_%E5%B7%B4%E6%AF%94%E4%BC%A6%E5%AF%8C%E7%BF%81%E6%96%B0%E8%A7%A3/</link>
      <pubDate>Sat, 07 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200307114151_%E5%B7%B4%E6%AF%94%E4%BC%A6%E5%AF%8C%E7%BF%81%E6%96%B0%E8%A7%A3/</guid>
      <description>积累财富首先要改变思维，学习复利的力量。
粗读要点 实践 10/50 懒人储蓄投资自己，工资 10% 奖金 50% 存储单独的账户用户投资自己 开辟单独基金用于存放房租、孩子学费和自我投资 不懂不投，宁愿错过，不犯过错 画出自己的财富水池 为自己购买保险规避风险（大病和死亡），完成家庭保险配置 理清房贷还款计划，怎么将还款金额降低到收入到 1/3 （9000）以下，可以考虑先提前还房贷减轻房贷利息压力 </description>
    </item>
    
    <item>
      <title>CPI</title>
      <link>https://notes.0081800.xyz/notes/20200224133304_cpi/</link>
      <pubDate>Sat, 07 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200224133304_cpi/</guid>
      <description>反映与居民生活有关的产品及劳务价格统计出来的物价变动指标，衡量通货膨胀的主要指标之一：
超过 3% 为通货膨胀 超过 5% 就是比较严重的通货膨胀 Links 消费者物价指数 </description>
    </item>
    
    <item>
      <title>ELisp</title>
      <link>https://notes.0081800.xyz/notes/20200225192204_elisp/</link>
      <pubDate>Sat, 07 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200225192204_elisp/</guid>
      <description>tags: Emacs &#39;foo vs #&#39;foo https://emacs.stackexchange.com/a/10943
#&amp;rsquo; on symbols will cause the byte-compiler to emit a warning if the function is not defined.</description>
    </item>
    
    <item>
      <title>Financial Management</title>
      <link>https://notes.0081800.xyz/notes/20200224132507/</link>
      <pubDate>Sat, 07 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200224132507/</guid>
      <description> 基金 基金定投 股市相关概念 相关书籍 《巴比伦富翁新解》读书笔记 《百箭穿杨》读书笔记 To Read 《布雷迪报告》 </description>
    </item>
    
    <item>
      <title>Go</title>
      <link>https://notes.0081800.xyz/notes/20200218115725/</link>
      <pubDate>Sat, 07 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200218115725/</guid>
      <description> tags: Programming Language 柯里化 func max(a, b int) int { if a &amp;gt; b { return a } return b } func currying(a int) func(int) int { return func(b int) int { return max(a, b) } } </description>
    </item>
    
    <item>
      <title>Go Channel</title>
      <link>https://notes.0081800.xyz/notes/20200218115740_go_channel/</link>
      <pubDate>Sat, 07 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200218115740_go_channel/</guid>
      <description> tags: Go Channel Directions func demo(readOnlyStream &amp;lt;-chan bool, writeOnlyStream chan&amp;lt;- bool) { } </description>
    </item>
    
    <item>
      <title>Helm</title>
      <link>https://notes.0081800.xyz/notes/20200218122103_helm/</link>
      <pubDate>Sat, 07 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200218122103_helm/</guid>
      <description>tags: Emacs 如何从历史跳到其他命令列表 Key binds C-o
See also: https://emacs.stackexchange.com/questions/18173/how-to-jump-from-emacs-command-history-to-emacs-commands-in-helm</description>
    </item>
    
    <item>
      <title>Makefile</title>
      <link>https://notes.0081800.xyz/notes/20200218174830_makefile/</link>
      <pubDate>Sat, 07 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200218174830_makefile/</guid>
      <description>Links A Makefile for Emacs Packages </description>
    </item>
    
    <item>
      <title>Unix</title>
      <link>https://notes.0081800.xyz/notes/20200218174814/</link>
      <pubDate>Sat, 07 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200218174814/</guid>
      <description> Makefile SSH macOS max open files macOS TimeMachine 日志 macOS 问题解决三板斧 </description>
    </item>
    
    <item>
      <title>基金</title>
      <link>https://notes.0081800.xyz/notes/20200224132645_/</link>
      <pubDate>Sat, 07 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200224132645_/</guid>
      <description>将资金交给投资经理人进行投资盈利跑赢 CPI 或赚取更多利润。
分类 交易方式划分：
开放式基金（活期） 封闭式基金（死期） 投资对象划分:
货币基金：余额宝 股票型、债卷型：依靠基金经理管理基金的能力 指数型：被动型基金，依靠大盘指数，美股属于长牛短熊型能跑赢主动型，A 股属于短牛长熊跑赢主动型比较困难。 股票 VS 基金 股票：想一夜暴富（也可能一夜暴亏） 基金：财富增值，门槛低，风险低 如何选基 市场研判 股市走熊：债卷基金 牛市初中：股票基金和指数基金 自身情况 稳健型 激进型 技巧 基金评级 国外渠道
晨星 国内渠道
银河证劵 海通证劵 济安金信 招商证劵 历史业绩 将基金收益与股票大盘走势进行比较； 将基金收益与其他同类基金的收益进行比较； 将基金的当期收益与历史收益进行比较。 一些指标 夏普比率 &amp;gt; 0 基金报酬大于风险，&amp;lt; 0 风险大过报酬 标准差越小，投资风险越低 天天基金网等三方平台上都能看，晨星网上更全。天天基金网的特色数据一栏可以看，晨星网的基金工具里包括阿尔法系数等指标都有标识。
Links 〈如何买基金？基金入门，学会这几招就够了〉 </description>
    </item>
    
    <item>
      <title>复利</title>
      <link>https://notes.0081800.xyz/notes/20200307114233_%E5%A4%8D%E5%88%A9/</link>
      <pubDate>Sat, 07 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200307114233_%E5%A4%8D%E5%88%A9/</guid>
      <description>Wikipedia: https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%88%A9</description>
    </item>
    
    <item>
      <title>夏普比率</title>
      <link>https://notes.0081800.xyz/notes/20200224140348_/</link>
      <pubDate>Sat, 07 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200224140348_/</guid>
      <description>它是用来衡量金融资产绩效基金表现的一个指标，核心思想就是选择收益率相近的基金承担的风险越小越好，选择风险水平相同的基金则收益率越高越好。总之，夏普比率越大，说明这只基金的绩效越好。
&amp;gt; 0 基金报酬大于风险 &amp;lt; 0 基金风险大过报酬 </description>
    </item>
    
    <item>
      <title>标准差（Standard Deviation）</title>
      <link>https://notes.0081800.xyz/notes/20200224141925_/</link>
      <pubDate>Sat, 07 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200224141925_/</guid>
      <description>又称标准偏差、均方差，数学符号 sigma。概率统计中最常使用作为测量一组数值的离散程度。
定义：为方差开算数平方根，反应组内个体间的离散程度。
用在基金上反映了基金总回报率的波动幅度大小，数值越大，表明波动程度越厉害，稳定度越小，投资风险就越高。
越小，投资风险越低 越大，投资风险越高 </description>
    </item>
    
    <item>
      <title>CPI</title>
      <link>https://notes.0081800.xyz/notes/20200224133214/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200224133214/</guid>
      <description>:Tags: Financial Management
消费者物价指数 </description>
    </item>
    
    <item>
      <title>《领域驱动设计》读书笔记</title>
      <link>https://notes.0081800.xyz/notes/20200320171301_%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Sat, 15 Jun 2019 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200320171301_%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</guid>
      <description>tags: 正在读的书,读书笔记,DDD 前言和目录 好的软件需要控制复杂性，好的领域模型可以帮助控制复杂性。
什么样的项目需要 DDD？尝试型的小型项目应该不需要 DDD，但是一旦上了规模考虑后续迭代则需要 DDD。
本书组织方式：
领域建模 领域建模的过程就是消化知识的过程，这个过程应该贯穿整个开发过程，需要持续学习。
模型用来描绘人们所关注的实现或想法的某个方面，比如地图就是模型。
模型是一种简化，是对实现的解释：把与解决问题密切相关的方面抽象出来，而忽略无关的细节。
软件问题建模的区域就是软件的领域
物质世界的领域：机票预订程序涉及的飞机乘客。 无形的领域：会计程序的金融领域。 领域涉及知识信息超载的问题，模型这种知识对知识进行了选择性的简化和有意的结构化。
领域模型将领域专家头脑中的支持严格的组织且有选择的抽象，并不是尽可能建立一个符合“现实”的模型。
模型表示 关联 规定一个遍历方向：存在双向联结时（地址 -&amp;gt; 人 或 人 -&amp;gt; 地址）尽量只用一种，并避免互相关联 添加一个限定符，以便有效减少多重关联 消除不必要的关联 表示方式 领域模式 实践 MODEL-DRIVEN DESIGN 隔离领域：引入应用层 应用 LAYERED ARCHITECTURE 把领域层划分出来，通过应用层类来处理应用程序功能。应用层类是协调者，负责提问，领域层负责回答。
将 ENTITY 和 VALUE OBJECT 区分开 依次考虑对象是必须跟踪的 ENTITY 还是表示一个 VALUE OBJECT。
AGGREGATE 边界 识别模型中的 AGGREGATE 根和对应的边界。
选择 REPOSITORY 为 AGGREGATE 根对象建立 REPOSITORY。
场景走查 根据应用程序特性复核建模，进行场景走查，确保能够有效地解决应用问题。可以走查一些正常和异常业务场景进行复核。
对象创建 如果对象复杂则创建单独的 FACTORY 类进行对象创建，简单对象可以直接在 AGGREGATE 根上通过 FACTORY METHOD 进行创建。</description>
    </item>
    
    <item>
      <title>LeetCode: 316.Remove Duplicate Letters</title>
      <link>https://notes.0081800.xyz/notes/20200320172625_leetcode_316_remove_duplicate_letters/</link>
      <pubDate>Wed, 01 May 2019 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200320172625_leetcode_316_remove_duplicate_letters/</guid>
      <description>tags: LeetCode 移除小写字母中重复的字母，让所有字母都只出现一次，并且结果是所有结果中按照字典序排序最小的那个。
Example 1
Input: &amp;ldquo;bcabc&amp;rdquo; Output: &amp;ldquo;abc&amp;rdquo; Example 2
Input: &amp;ldquo;cbacdcbc&amp;rdquo; Output: &amp;ldquo;acdb&amp;rdquo; 解法之一:
通过一个数组对每一个出现的字母进行计数 遍历每一个字母放入栈，并将该字母的计数减 1 查看栈底的字母有没有比当前字母大且该字母的计数不为 0 的（有比当前更小的字典序），从栈底弹出该字母 func removeDuplicateLetters(s string) string { var countOfEachLetter [26]int var visited [26]bool stack := make([]byte, 0) stackBottom := 0 bytesArr := []byte(s) for _, c := range bytesArr { countOfEachLetter[getIndex(c)]++ } for _, c := range bytesArr { index := getIndex(c) countOfEachLetter[index]-- if visited[index] { continue } // countOfEachLetter[getIndex(stack[stackBottom])] &amp;gt; 0 后面还有该字符 for len(stack[stackBottom:]) &amp;gt; 0 &amp;amp;&amp;amp; stack[stackBottom] &amp;gt; c &amp;amp;&amp;amp; countOfEachLetter[getIndex(stack[stackBottom])] &amp;gt; 0 { // 标记为未访问用于后面的字符加入结果 visited[getIndex(stack[stackBottom])] = false // 移动栈底 stackBottom++ } // 加入到结果栈 stack = append(stack, c) visited[index] = true } return string(stack[stackBottom:]) } func getIndex(b byte) int { return int(b - &amp;#39;a&amp;#39;) } 通过上面解法遇到如下错误：</description>
    </item>
    
    <item>
      <title>LeetCode: 153.Find Minimum in Rotated Sorted Array</title>
      <link>https://notes.0081800.xyz/notes/20200320172433_leetcode_153_find_minimum_in_rotated_sorted_array/</link>
      <pubDate>Tue, 23 Apr 2019 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200320172433_leetcode_153_find_minimum_in_rotated_sorted_array/</guid>
      <description>tags: LeetCode 解法 1 找到中间节点依次往左右扩散：
向左边扩散，如果左边的大于当前元素，那么当前元素即为最小值 向右边扩散，如果右边的小于当前元素，那么右边元素即为最小值 如果以上不成立则第一个元素为最小元素（未旋转），以下是代码
func findMin(nums []int) int { length := len(nums) if length == 1 { return nums[0] } // 从中间开始确定方向 mid := length / 2 - 1 left, right := mid, mid for left - 1 &amp;gt;= 0 || right + 1 &amp;lt; length { if left - 1 &amp;gt;= 0 { if nums[left - 1] &amp;gt; nums[left] { return nums[left]; } left-- } if right + 1 &amp;lt; length { if nums[right] &amp;gt; nums[right + 1] { return nums[right + 1] } right++ } } return nums[0] } 优化 参考答案后可通过二分查找做如下优化，首先判断是否被旋转：</description>
    </item>
    
    <item>
      <title>LeetCode: 154.Find Minimum in Rotated Sorted Array II</title>
      <link>https://notes.0081800.xyz/notes/20200320172319_154_find_minimum_in_rotated_sorted_array_ii/</link>
      <pubDate>Tue, 23 Apr 2019 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200320172319_154_find_minimum_in_rotated_sorted_array_ii/</guid>
      <description> tags: LeetCode 思路 这个是 LeetCode: 153.Find Minimum in Rotated Sorted Array 扩展，增加了以下几种边界情况：
&amp;lsquo;[2, 2, 2, 2, 1]&amp;rsquo; &amp;lsquo;[3, 1, 3]&amp;rsquo; &amp;lsquo;[1, 1, 1]&amp;rsquo; &amp;lsquo;[10, 1, 10, 10, 10]&amp;rsquo; 但核心依然是判断最小值是在左边还是右边。假设如下数组：
&amp;lsquo;[3, 3, 3, 1, 3]&amp;rsquo;
left[0]=3, right[4]=3, mid[2]=3, 这时候不确定最小值在哪边但是 right&amp;ndash; 是安全的，所以执行 right&amp;ndash;
left[0]=3, right[3]=1, mid[2]=3, 这时候 mid &amp;lt; right 说明最小值在 mid 的右边，所以调整 left = mid + 1
左右两边索引一致终止循环
实现 func findMin(nums []int) int { length := len(nums) left, right := 0, length - 1 for left &amp;lt; right { mid := (left + right) / 2 if nums[mid] &amp;gt; nums[right] { left = mid + 1 } else if nums[mid] &amp;lt; nums[right] { right = mid } else { right-- } } return nums[right] } </description>
    </item>
    
    <item>
      <title>LeetCode: 3.Longest Substring Without Repeating Characters</title>
      <link>https://notes.0081800.xyz/notes/20200320172810_leetcode_3_longest_substring_without_repeating_characters/</link>
      <pubDate>Tue, 23 Apr 2019 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200320172810_leetcode_3_longest_substring_without_repeating_characters/</guid>
      <description>tags: LeetCode 准备 动态规划
实践 字符串 &amp;ldquo;abcabcbb&amp;rdquo;
根据索引有如下关系
a b c a b c b b 0 1 2 3 4 5 6 7 \(f(0,1)=f(0,0) + 1\) \(f(0,2)=f(0,1) + 2\) 在所有字符都不重复的情况下有如下公式
\(f(s,e)=f(s,e-1) + e\)
若遇到重复的情况则，3 索引于当前字串 的 0 重复则表明当前字串已经到头，需要记录并偏移 s，s=1：
\(f(1,3)=f(1,2)+3\) 假设：
s - 开始字符索引 e - 结束字符索引 若遇到当前字符于前面 r 字符重复则： \[ f(r,e)=f(s,e - 1) + e; s=r \]
解法 func lengthOfLongestSubstring(s string) int { if len(s) == 0 { return 0 } appearedIndexes := [256]int{} for i := 0; i &amp;lt; 256; i++{ appearedIndexes[i] = -1 } longest, start, end := 0, 0, 0 b := []byte(s) for cIndex, c := range b { index := int(c) appearedIndex := appearedIndexes[index] end = cIndex // 出现过需要截断 if appearedIndex !</description>
    </item>
    
    <item>
      <title>LeetCode: 4.Median of Two Sorted Arrays</title>
      <link>https://notes.0081800.xyz/notes/20200320172945_leetcode_4_median_of_two_sorted_arrays/</link>
      <pubDate>Tue, 23 Apr 2019 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200320172945_leetcode_4_median_of_two_sorted_arrays/</guid>
      <description>tags: LeetCode 思路 归并排序
代码 func findMedianSortedArrays(nums1 []int, nums2 []int) float64 { nums := mergeSort(nums1, nums2) length := len(nums) if length % 2 != 0 { return float64(nums[(length - 1) / 2]) } i := length / 2 return (float64(nums[i]) + float64(nums[i - 1])) / 2 } func mergeSort(nums1 []int, nums2 []int) []int { l1 := len(nums1) l2 := len(nums2) result := make([]int, 0, l1 + l2) i, j := 0, 0 for i &amp;lt; l1 &amp;amp;&amp;amp; j &amp;lt; l2 { if nums1[i] &amp;lt; nums2[j] { result = append(result, nums1[i]) i++ } else { result = append(result, nums2[j]) j++ } } result = append(result, nums1[i:].</description>
    </item>
    
    <item>
      <title>LeetCode: 5.Longest Palindromic Substring</title>
      <link>https://notes.0081800.xyz/notes/20200320173438_leetcode_5_longest_palindromic_substring/</link>
      <pubDate>Tue, 23 Apr 2019 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200320173438_leetcode_5_longest_palindromic_substring/</guid>
      <description>tags: LeetCode &amp;gt; https://leetcode.com/problems/longest-palindromic-substring/description/
思路 直接暴力往两边搜索
func longestPalindrome(s string) string { buf := []byte(s) length := len(buf) if length == 0 { return s } start, end := 0, 0 for ci, _ := range buf { i, j := ci, ci // 无法处理 &amp;#34;aaaa&amp;#34; 和 &amp;#34;noon&amp;#34; 这种情况 for i &amp;gt; 0 &amp;amp;&amp;amp; j &amp;lt; length - 1 &amp;amp;&amp;amp; buf[i - 1] == buf[j + 1] { i-- j++ } // 考虑 &amp;#34;bba&amp;#34; 这种情况 if i == j &amp;amp;&amp;amp; ci &amp;gt; 0 &amp;amp;&amp;amp; buf[ci] == buf[ci - 1] { i, j = ci-1, ci } // 考虑 &amp;#34;abb&amp;#34; 这种情况 if i == j &amp;amp;&amp;amp; ci &amp;lt; length - 1 &amp;amp;&amp;amp; buf[ci] == buf[ci + 1] { i, j = ci, ci + 1 } if i !</description>
    </item>
    
    <item>
      <title>LeetCode: 6.ZigZag Conversion</title>
      <link>https://notes.0081800.xyz/notes/20200320173548_leetcode_6_zigzag_conversion/</link>
      <pubDate>Tue, 23 Apr 2019 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200320173548_leetcode_6_zigzag_conversion/</guid>
      <description>tags: LeetCode srouce: https://leetcode.com/problems/zigzag-conversion/description/ 先根据行数计算列数：
\(column=length / (row + 2) + bool(length \mod (row + 2))\)
每一行必然有点的位置为：
\(i \mod (row - 1)\) 为 0</description>
    </item>
    
    <item>
      <title>MySQL</title>
      <link>https://notes.0081800.xyz/notes/20200320173956_mysql/</link>
      <pubDate>Tue, 23 Apr 2019 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200320173956_mysql/</guid>
      <description></description>
    </item>
    
    <item>
      <title>《The Rust Programming Language》读书笔记</title>
      <link>https://notes.0081800.xyz/notes/20200325165411_the_rust_programming_language/</link>
      <pubDate>Tue, 09 Apr 2019 00:00:00 +0800</pubDate>
      
      <guid>https://notes.0081800.xyz/notes/20200325165411_the_rust_programming_language/</guid>
      <description> tags: 读书笔记,Rust
语句和表达式
所有权
引用和借用
结构体
枚举
模式匹配
if let
模块化
错误处理
Traits
生命周期
闭包
迭代器
智能指针
Rust 宏
Rust 并发
函数指针 fn 区分闭包的 Fn 特性，函数指针都实现来三个闭包的特性。
fn do(f: fn(i32) -&amp;gt; i32, arg: i32) -&amp;gt; i32 { f(arg) + f(arg) } </description>
    </item>
    
  </channel>
</rss>
