<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>LeetCode101: 3. Longest Substring Without Repeating Characters | Taking Smart Notes With Org-mode</title>
<meta name="keywords" content="">
<meta name="description" content="tags: Sliding Window,LeetCode101,Hash Table Use HashMap to store counts of letters Two points we should be noticed:
The length of substring should be (right - left) &#43; 1, as one side must be counted.
We must decrese the number in the counts first, and then slide the left window, or we must decrese the wrong one, please compare between Wrong and Correct.
Wrong
left&#43;&#43;; counts[s[left]]--; Correct
counts[s[left]]--; left&#43;&#43;; The full code see:">
<meta name="author" content="Gray King">
<link rel="canonical" href="https://notes.0081800.xyz/notes/20220311074801-3_longest_substring_without_repeating_characters/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://notes.0081800.xyz/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://notes.0081800.xyz/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://notes.0081800.xyz/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://notes.0081800.xyz/apple-touch-icon.png">
<link rel="mask-icon" href="https://notes.0081800.xyz/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://notes.0081800.xyz/notes/20220311074801-3_longest_substring_without_repeating_characters/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:title" content="LeetCode101: 3. Longest Substring Without Repeating Characters" />
<meta property="og:description" content="tags: Sliding Window,LeetCode101,Hash Table Use HashMap to store counts of letters Two points we should be noticed:
The length of substring should be (right - left) &#43; 1, as one side must be counted.
We must decrese the number in the counts first, and then slide the left window, or we must decrese the wrong one, please compare between Wrong and Correct.
Wrong
left&#43;&#43;; counts[s[left]]--; Correct
counts[s[left]]--; left&#43;&#43;; The full code see:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://notes.0081800.xyz/notes/20220311074801-3_longest_substring_without_repeating_characters/" /><meta property="article:section" content="notes" />
<meta property="article:published_time" content="2022-03-11T07:48:00+08:00" />
<meta property="article:modified_time" content="2022-03-11T07:48:00+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LeetCode101: 3. Longest Substring Without Repeating Characters"/>
<meta name="twitter:description" content="tags: Sliding Window,LeetCode101,Hash Table Use HashMap to store counts of letters Two points we should be noticed:
The length of substring should be (right - left) &#43; 1, as one side must be counted.
We must decrese the number in the counts first, and then slide the left window, or we must decrese the wrong one, please compare between Wrong and Correct.
Wrong
left&#43;&#43;; counts[s[left]]--; Correct
counts[s[left]]--; left&#43;&#43;; The full code see:"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://notes.0081800.xyz/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "LeetCode101: 3. Longest Substring Without Repeating Characters",
      "item": "https://notes.0081800.xyz/notes/20220311074801-3_longest_substring_without_repeating_characters/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "LeetCode101: 3. Longest Substring Without Repeating Characters",
  "name": "LeetCode101: 3. Longest Substring Without Repeating Characters",
  "description": "tags: Sliding Window,LeetCode101,Hash Table Use HashMap to store counts of letters Two points we should be noticed:\nThe length of substring should be (right - left) + 1, as one side must be counted.\nWe must decrese the number in the counts first, and then slide the left window, or we must decrese the wrong one, please compare between Wrong and Correct.\nWrong\nleft++; counts[s[left]]--; Correct\ncounts[s[left]]--; left++; The full code see:",
  "keywords": [
    
  ],
  "articleBody": " tags: Sliding Window,LeetCode101,Hash Table Use HashMap to store counts of letters Two points we should be noticed:\nThe length of substring should be (right - left) + 1, as one side must be counted.\nWe must decrese the number in the counts first, and then slide the left window, or we must decrese the wrong one, please compare between Wrong and Correct.\nWrong\nleft++; counts[s[left]]--; Correct\ncounts[s[left]]--; left++; The full code see:\nclass Solution { public: int lengthOfLongestSubstring(string s) { int left = 0; int longest = 0; char c; map\u003cchar, int\u003e counts; // for loop to slide the right side of window. for (int right = 0; right \u003c s.size(); right++) { c = s[right]; if (counts.find(c) == counts.end()) { counts[c] = 0; } counts[c]++; // slide the left side of window to meet the requirements, // here is \"Without Repeating Characters\". for (auto iter = counts.begin(); iter != counts.end(); ++iter) { if (iter-\u003esecond \u003e 1) { counts[s[left]]--; left++; break; } } // compare to result. longest = max(longest, right - left + 1); } return longest; } }; See also: An Introduction to Sliding Window Algorithms\nUse HashMap to store index of letters Points that should be noticed:\nThe whole string without repeating, that will not meet the condition: letter is indexed already.\n\" \" \"au\" // no duplicated if (indices.find(l) != indices.end()) { left = indices[l] + 1; longest = max(longest, right - left + 1); } In those cases longest will be 0, if this is the only one block to compute the longest.\nMove compute the longest out of the if block, the problem should be sloved.\n// no duplicated if (indices.find(l) != indices.end()) { left = indices[l] + 1; } longest = max(longest, right - left + 1); The left may go backward from a HashTable, and that must be avoid.\n“abba” if (indices.find(l) != indices.end() \u0026\u0026 indices[l] + 1 \u003e left) { left = indices[l] + 1; } longest = max(longest, right - left + 1); And notice that +1 must exists in the condition, the WRONG edition:\nif (indices.find(l) != indices.end() \u0026\u0026 indices[l] \u003e left) { left = indices[l] + 1; } longest = max(longest, right - left + 1); Finally code:\nclass Solution { public: int lengthOfLongestSubstring(string s) { int left = 0; int longest = 0; map\u003cchar, int\u003e indices; for (auto right = 0; right \u003c s.size(); right++) { char l = s[right]; if (indices.find(l) != indices.end() \u0026\u0026 indices[l] + 1 \u003e left) { left = indices[l] + 1; } longest = max(longest, right - left + 1); indices[l] = right; } return longest; } }; Full with failed:\nclass Solution { public: int lengthOfLongestSubstring(string s) { int left = 0; int longest = 0; map\u003cchar, int\u003e indices; for (auto right = 0; right \u003c s.size(); right++) { char l = s[right]; /* // failed on string without repeating: \" \" \"au\" if (indices.find(l) != indices.end()) { left = indices[l] + 1; longest = max(longest, right - left + 1); } */ /* // failed on left go backward: \"abba\" if (indices.find(l) != indices.end()) { left = indices[l] + 1; } longest = max(longest, right - left + 1); */ if (indices.find(l) != indices.end() \u0026\u0026 indices[l] + 1 \u003e left) { left = indices[l] + 1; } longest = max(longest, right - left + 1); indices[l] = right; } return longest; } }; Optimization: use the unordered_map to instead map.\nclass Solution { public: int lengthOfLongestSubstring(string s) { int left = 0; int longest = 0; unordered_map\u003cchar, int\u003e indices; for (auto right = 0; right \u003c s.size(); right++) { char l = s[right]; if (indices.find(l) != indices.end() \u0026\u0026 indices[l] + 1 \u003e left) { left = indices[l] + 1; } longest = max(longest, right - left + 1); indices[l] = right; } return longest; } }; ",
  "wordCount" : "636",
  "inLanguage": "en",
  "datePublished": "2022-03-11T07:48:00+08:00",
  "dateModified": "2022-03-11T07:48:00+08:00",
  "author":[{
    "@type": "Person",
    "name": "Gray King"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://notes.0081800.xyz/notes/20220311074801-3_longest_substring_without_repeating_characters/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Taking Smart Notes With Org-mode",
    "logo": {
      "@type": "ImageObject",
      "url": "https://notes.0081800.xyz/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://notes.0081800.xyz/" accesskey="h" title="Taking Smart Notes With Org-mode (Alt + H)">Taking Smart Notes With Org-mode</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://notes.0081800.xyz/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://notes.0081800.xyz/articles/" title="Articles">
                    <span>Articles</span>
                </a>
            </li>
            <li>
                <a href="https://notes.0081800.xyz/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://notes.0081800.xyz/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://notes.0081800.xyz/">Home</a>&nbsp;»&nbsp;<a href="https://notes.0081800.xyz/notes/">Notes</a></div>
    <h1 class="post-title">
      LeetCode101: 3. Longest Substring Without Repeating Characters
    </h1>
    <div class="post-meta"><span title='2022-03-11 07:48:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Gray King

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#use-hashmap-to-store-counts-of-letters" aria-label="Use HashMap to store counts of letters">Use HashMap to store counts of letters</a></li>
                <li>
                    <a href="#use-hashmap-to-store-index-of-letters" aria-label="Use HashMap to store index of letters">Use HashMap to store index of letters</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><ul>
<li>tags: <a href="/notes/20220311074820-sliding_window/">Sliding Window</a>,<a href="/notes/20220311065137-leetcode101/">LeetCode101</a>,<a href="/notes/20220311221617-hash_table/">Hash Table</a></li>
</ul>
<h2 id="use-hashmap-to-store-counts-of-letters">Use HashMap to store counts of letters<a hidden class="anchor" aria-hidden="true" href="#use-hashmap-to-store-counts-of-letters">#</a></h2>
<p>Two points we should be noticed:</p>
<ol>
<li>
<p>The <strong>length of substring</strong> should be <code>(right - left) + 1</code>, as one side must be counted.</p>
</li>
<li>
<p>We must decrese the number in the <code>counts</code> first, and then slide the left window, or we must decrese the wrong one, please compare between <strong>Wrong</strong> and <strong>Correct</strong>.</p>
<p><strong>Wrong</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>left<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>counts[s[left]]<span style="color:#f92672">--</span>;
</span></span></code></pre></div><p><strong>Correct</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>counts[s[left]]<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>left<span style="color:#f92672">++</span>;
</span></span></code></pre></div></li>
</ol>
<p>The full code see:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> lengthOfLongestSubstring(string s) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> longest <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">char</span> c;
</span></span><span style="display:flex;"><span>		map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> counts;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// for loop to slide the right side of window.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; right <span style="color:#f92672">&lt;</span> s.size(); right<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>			c <span style="color:#f92672">=</span> s[right];
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (counts.find(c) <span style="color:#f92672">==</span> counts.end()) {
</span></span><span style="display:flex;"><span>				counts[c] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			counts[c]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// slide the left side of window to meet the requirements,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// here is &#34;Without Repeating Characters&#34;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> iter <span style="color:#f92672">=</span> counts.begin(); iter <span style="color:#f92672">!=</span> counts.end(); <span style="color:#f92672">++</span>iter) {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (iter<span style="color:#f92672">-&gt;</span>second <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>					counts[s[left]]<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>					left<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// compare to result.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			longest <span style="color:#f92672">=</span> max(longest, right <span style="color:#f92672">-</span> left <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> longest;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>See also: <a href="/notes/20220311083843-an_introduction_to_sliding_window_algorithms/">An Introduction to Sliding Window Algorithms</a></p>
<h2 id="use-hashmap-to-store-index-of-letters">Use HashMap to store index of letters<a hidden class="anchor" aria-hidden="true" href="#use-hashmap-to-store-index-of-letters">#</a></h2>
<p>Points that should be noticed:</p>
<ol>
<li>
<p>The whole string without repeating, that will not meet the condition: letter is indexed already.</p>
<ul>
<li><code>&quot; &quot;</code></li>
<li><code>&quot;au&quot;</code></li>
</ul>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// no duplicated
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (indices.find(l) <span style="color:#f92672">!=</span> indices.end()) {
</span></span><span style="display:flex;"><span>	left <span style="color:#f92672">=</span> indices[l] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	longest <span style="color:#f92672">=</span> max(longest, right <span style="color:#f92672">-</span> left <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In those cases longest will be 0, if this is the only one block to compute the <code>longest</code>.</p>
<p>Move compute the <code>longest</code> out of the if block, the problem should be sloved.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// no duplicated
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (indices.find(l) <span style="color:#f92672">!=</span> indices.end()) {
</span></span><span style="display:flex;"><span>	left <span style="color:#f92672">=</span> indices[l] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>longest <span style="color:#f92672">=</span> max(longest, right <span style="color:#f92672">-</span> left <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span></code></pre></div></li>
<li>
<p>The <code>left</code> may go backward from a HashTable, and that must be avoid.</p>
<ul>
<li>&ldquo;abba&rdquo;</li>
</ul>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (indices.find(l) <span style="color:#f92672">!=</span> indices.end() <span style="color:#f92672">&amp;&amp;</span> indices[l] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;</span> left) {
</span></span><span style="display:flex;"><span>	left <span style="color:#f92672">=</span> indices[l] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>longest <span style="color:#f92672">=</span> max(longest, right <span style="color:#f92672">-</span> left <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span></code></pre></div><p>And notice that <code>+1</code> must exists in the condition, the <strong>WRONG</strong> edition:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (indices.find(l) <span style="color:#f92672">!=</span> indices.end() <span style="color:#f92672">&amp;&amp;</span> indices[l] <span style="color:#f92672">&gt;</span> left) {
</span></span><span style="display:flex;"><span>	left <span style="color:#f92672">=</span> indices[l] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>longest <span style="color:#f92672">=</span> max(longest, right <span style="color:#f92672">-</span> left <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span></code></pre></div></li>
</ol>
<p>Finally code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> lengthOfLongestSubstring(string s) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> longest <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> indices;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> right <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; right <span style="color:#f92672">&lt;</span> s.size(); right<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">char</span> l <span style="color:#f92672">=</span> s[right];
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (indices.find(l) <span style="color:#f92672">!=</span> indices.end() <span style="color:#f92672">&amp;&amp;</span> indices[l] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;</span> left) {
</span></span><span style="display:flex;"><span>				left <span style="color:#f92672">=</span> indices[l] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			longest <span style="color:#f92672">=</span> max(longest, right <span style="color:#f92672">-</span> left <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>			indices[l] <span style="color:#f92672">=</span> right;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> longest;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Full with failed:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> lengthOfLongestSubstring(string s) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> longest <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> indices;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> right <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; right <span style="color:#f92672">&lt;</span> s.size(); right<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">char</span> l <span style="color:#f92672">=</span> s[right];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			// failed on string without repeating: &#34; &#34; &#34;au&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			if (indices.find(l) != indices.end()) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">				left = indices[l] + 1;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">				longest = max(longest, right - left + 1);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			// failed on left go backward: &#34;abba&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 if (indices.find(l) != indices.end()) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">				 left = indices[l] + 1;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 longest = max(longest, right - left + 1);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (indices.find(l) <span style="color:#f92672">!=</span> indices.end() <span style="color:#f92672">&amp;&amp;</span> indices[l] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;</span> left) {
</span></span><span style="display:flex;"><span>				left <span style="color:#f92672">=</span> indices[l] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			longest <span style="color:#f92672">=</span> max(longest, right <span style="color:#f92672">-</span> left <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>			indices[l] <span style="color:#f92672">=</span> right;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> longest;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><strong>Optimization:</strong> use the <code>unordered_map</code> to instead <code>map</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> lengthOfLongestSubstring(string s) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> longest <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> indices;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> right <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; right <span style="color:#f92672">&lt;</span> s.size(); right<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">char</span> l <span style="color:#f92672">=</span> s[right];
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (indices.find(l) <span style="color:#f92672">!=</span> indices.end() <span style="color:#f92672">&amp;&amp;</span> indices[l] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;</span> left) {
</span></span><span style="display:flex;"><span>				left <span style="color:#f92672">=</span> indices[l] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			longest <span style="color:#f92672">=</span> max(longest, right <span style="color:#f92672">-</span> left <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>			indices[l] <span style="color:#f92672">=</span> right;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> longest;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>


   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   
      
   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   


<hr />

  <div class="bl-section">
    <h3>Links to this note</h3>
    <br />
    <div class="backlinks">
      <ul>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 1695. Maximum Erasure Value
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Sliding Window,LeetCode101,Hash Set Use HashMap to store indices See also: 3. Longest Substring Without Repeating Characters
class Solution { public: int maximumUniqueSubarray(vector&lt;int&gt;&amp; nums) { int maximum = 0; int left = 0, right = 0; unordered_map&lt;int, int&gt; indices; for (; right &lt; nums.size(); right&#43;&#43;) { int n = nums[right]; if (indices.find(n) != indices.end() &amp;&amp; indices[n] &#43; 1 &gt; left) { left = indices[n] &#43; 1; } maximum = max(maximum, std::accumulate(nums....</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-11 18:38:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 1695. Maximum Erasure Value" href="https://notes.0081800.xyz/notes/20220311183843-1695_maximum_erasure_value/"></a>
          </article>
       
     </ul>
    </div>
  </div>


</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://notes.0081800.xyz/">Taking Smart Notes With Org-mode</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
