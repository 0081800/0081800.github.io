<!DOCTYPE html>
<html lang="en" dir="auto">

<head>
	<meta name="generator" content="Hugo 0.147.2"><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Taking Smart Notes With Org-mode</title>

<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="https://notes.0081800.xyz/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css" integrity="sha256-IhHKMWS&#43;eDACT2qtKzouUghDpk&#43;PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://notes.0081800.xyz/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://notes.0081800.xyz/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://notes.0081800.xyz/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://notes.0081800.xyz/apple-touch-icon.png">
<link rel="mask-icon" href="https://notes.0081800.xyz/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://notes.0081800.xyz/index.xml">
<link rel="alternate" type="application/json" href="https://notes.0081800.xyz/index.json">
<link rel="alternate" hreflang="en" href="https://notes.0081800.xyz/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://notes.0081800.xyz/">
  <meta property="og:site_name" content="Taking Smart Notes With Org-mode">
  <meta property="og:title" content="Taking Smart Notes With Org-mode">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Taking Smart Notes With Org-mode">
<meta name="twitter:description" content="">

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "Taking Smart Notes With Org-mode",
  "url": "https://notes.0081800.xyz/",
  "description": "",
  "logo": "https://notes.0081800.xyz/favicon.ico",
  "sameAs": [
      
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://notes.0081800.xyz/" accesskey="h" title="Taking Smart Notes With Org-mode (Alt + H)">Taking Smart Notes With Org-mode</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://notes.0081800.xyz/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://notes.0081800.xyz/articles/" title="Articles">
                    <span>Articles</span>
                </a>
            </li>
            <li>
                <a href="https://notes.0081800.xyz/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://notes.0081800.xyz/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">中间件
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: 技术，技术概念 中间件可以对系统进行解耦，比如上层系统对下层系统进行网络请求，考虑下面结构
- U - / | \ /--- | ---\ / | \ A B C 如果下层系统增加节点的话就需要重启 U。
引入 HAProxy 或者 Nginx 之类的中间件可以对两层系统进行解耦：
U | &#43;------&#43; | HA | &#43;------&#43; / | \ /--- | ---\ / | \ A B C 这样上层和下层系统都依赖中间件，但是系统之间不再强耦合，下层系统可以依赖中间件随意的进行所扩容而不用被上层系统感知。 这时候中间件只要保证中间件稳定即可，可以在中间件上进行热重启。
</p>
  </div>
  <footer class="entry-footer"><span title='2021-02-20 16:58:00 +0800 +0800'>February 20, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to 中间件" href="https://notes.0081800.xyz/notes/20210220165816-%E4%B8%AD%E9%97%B4%E4%BB%B6/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">技术随想
    </h2>
  </header>
  <div class="entry-content">
    <p> 项目代号 技术概念 </p>
  </div>
  <footer class="entry-footer"><span title='2021-02-20 16:58:00 +0800 +0800'>February 20, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to 技术随想" href="https://notes.0081800.xyz/notes/20210220165806-%E6%8A%80%E6%9C%AF%E9%9A%8F%E6%83%B3/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">C/C&#43;&#43; thread-local storage
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: C/C&#43;&#43; source: All about thread-local storage </p>
  </div>
  <footer class="entry-footer"><span title='2021-02-19 20:09:00 +0800 +0800'>February 19, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to C/C&#43;&#43; thread-local storage" href="https://notes.0081800.xyz/notes/20210219200958-c_c_thread_local_storage/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">macOS max open files
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: macOS fix “Too many open files in system” error
</p>
  </div>
  <footer class="entry-footer"><span title='2021-01-25 17:43:00 +0800 +0800'>January 25, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to macOS max open files" href="https://notes.0081800.xyz/notes/20210125174343-macos_max_open_files/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">GDB 打出所有线程的 Backtrace
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: GDB thread apply all bt </p>
  </div>
  <footer class="entry-footer"><span title='2021-01-18 11:47:00 +0800 +0800'>January 18, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to GDB 打出所有线程的 Backtrace" href="https://notes.0081800.xyz/notes/20210118114707-gdb_%E6%89%93%E5%87%BA%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E7%9A%84_backtrace/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">C&#43;&#43; LSP
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Emacs,LSP,C/C&#43;&#43;,CMake 通过如下命令生成 clangd 识别的编译配置文件
mkdir build cd build cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1 .. mv compile_commands.json ../ 然后重启 M-x lsp-restart-workspace RET 即可。
</p>
  </div>
  <footer class="entry-footer"><span title='2021-01-14 17:50:00 +0800 +0800'>January 14, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to C&#43;&#43; LSP" href="https://notes.0081800.xyz/notes/20210114175011-lsp/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Python behind the scenes #2: how the CPython compiler works
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Translate,Incomplete,Python Python 幕后 #2: CPython 编译器如何工作 今天的主题（Today’s subject） 在本系列的第一篇文章中我们研究了 Python 虚拟机。我们学了解到它通过执行一系列叫做字节码（bytecode）的指令。 我们也看到 Python 字节码没有完全描述代码片段的行为。这也是为什么存在一个代码对象（code object）的概念。 执行诸如函数或模块的代码块也就是执行对应的代码对象。代码对象包含了代码块的字节码，包含代码中使用的常量和变量名， 还有代码块的一些属性。
通常，一个 Python 程序员不用编写字节码，并且也不用创建代码对象，而是编写正常的 Python 代码。所有 CPython 必须 能够将源代码转换成代码对象。CPython 编译器就负责这部分工作。我们将通过这部分内容探索它是如何工作的。
Note: 本文参考 CPython 3.9。一些实现细节将必然会随着 CPython 的演进而改变。 我将会尝试关注一些重要的改变并添加更新备注。
什么是 CPython 编译器（What CPython compiler is） 我们已经了解了 CPython 编译器的职责，但是在我们进入到它是如何实现的之前，让我们首先来搞清楚为什么我们称之为编译器？
在通常情况加，编译器是一个将一个程序语言翻译到另一个与之等价的程序语言的程序。编译器有许多种类，但是通常情况下我们 讨论的都是静态编译：将一个高级语言的程序翻译成机器码。CPython 编译器也是这样吗？要回答这个问题，我们先看一下静态编 译器的传统三阶段设计（three-stage design）。
编译器前端（frontend）将源代码转换成一种中间语言（IR,intermediate representation）。然后优化器（optimzer）拿到中间语言 对其进行优化并把优化过的中间语言传递给编译器后端生成机器码。如果我们选择一种源语言和目标机器无关的中间语言，我们就 得到了三阶段设计的关键益处：对于一个编译器来说，支持一种新的源语言仅仅需要新增一个对应的编译器前端，支持一种新的目标机器 仅仅需要新增一个对应的编译器后端。
LLVM 工具集（toolchain）就是这个模型的一个很好的成功的例子。有很多编译器前端如 C、Rust、Swift 等其他很多编程语言基于 LLVM 提供给编译器更加复杂的部分。LLVM 的创建者 Chris Latter 提供了一个很好的 LLVM 架构概览。
CPython 尽管不需要支持多个源语言和目标机器，尔仅仅需要支持 Python 代码和 CPython 虚拟机。不过，CPython 同样实现了三阶段设计。 如果想知道为什么，我们需要更加详细的解释编译器的三阶段的每个阶段。
...</p>
  </div>
  <footer class="entry-footer"><span title='2020-10-15 18:28:00 +0800 +0800'>October 15, 2020</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Python behind the scenes #2: how the CPython compiler works" href="https://notes.0081800.xyz/notes/20201015182827-python_behind_the_scenes_2_how_the_cpython_compiler_works/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">straight.el 命令
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Emacs
M-x straight-thaw-versions RET 恢复到锁定的版本
M-x straight-pull-all RET 更新所有包
M-x straight-freeze-versions RET 锁定当前版本
Duplicated with straight.el 更新所有已安装的包
</p>
  </div>
  <footer class="entry-footer"><span title='2020-10-06 20:07:00 +0800 +0800'>October 6, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to straight.el 命令" href="https://notes.0081800.xyz/notes/20201006200745-straight_el_%E6%9B%B4%E6%96%B0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">straight.el 更新所有已安装的包
    </h2>
  </header>
  <div class="entry-content">
    <p> straight-thaw-versions straight-pull-all straight-freeze-versions </p>
  </div>
  <footer class="entry-footer"><span title='2020-10-06 20:07:00 +0800 +0800'>October 6, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to straight.el 更新所有已安装的包" href="https://notes.0081800.xyz/notes/20201006200745-straight_el_%E6%9B%B4%E6%96%B0%E6%89%80%E6%9C%89%E5%B7%B2%E5%AE%89%E8%A3%85%E7%9A%84%E5%8C%85/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Emacs Buffer 名字去重
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Emacs source: https://www.gnu.org/software/emacs/manual/html%5Fnode/emacs/Uniquify.html </p>
  </div>
  <footer class="entry-footer"><span title='2020-09-27 17:01:00 +0800 +0800'>September 27, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Emacs Buffer 名字去重" href="https://notes.0081800.xyz/notes/20200927170116-emacs_buffer_%E5%90%8D%E5%AD%97%E5%8E%BB%E9%87%8D/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">范数（norm）
    </h2>
  </header>
  <div class="entry-content">
    <p>具有“长度”概念的函数。在线性代数、泛函分析等相关数学领域，是一个函数，其为向量空间内所有向量赋予非零的正长度或大小。
</p>
  </div>
  <footer class="entry-footer"><span title='2020-09-12 10:23:00 +0800 +0800'>September 12, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to 范数（norm）" href="https://notes.0081800.xyz/notes/20200912102351-%E8%8C%83%E6%95%B0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">MAE（平均绝对误差）
    </h2>
  </header>
  <div class="entry-content">
    <p>\[MAE(X,h) = \frac{1}{m}\sum_{i=1}^{m}\left\lvert h(x^{(i)} - y ^{i})\right\rvert\]
</p>
  </div>
  <footer class="entry-footer"><span title='2020-09-12 10:15:00 +0800 +0800'>September 12, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to MAE（平均绝对误差）" href="https://notes.0081800.xyz/notes/20200912101549-mae_%E5%B9%B3%E5%9D%87%E7%BB%9D%E5%AF%B9%E8%AF%AF%E5%B7%AE/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">RMSE（均方根误差）
    </h2>
  </header>
  <div class="entry-content">
    <p>测量预测过程中的预测错误的标准差。
公式
\[RMSE(X,h)=\sqrt{\frac{1}{m}\sum_{i=1}^{m}(h(x^{(i)}) - y^{(i)})^2}\]
m 是你在测量 RMSE 时，所使用的数据集中实例的数量 \(x^{(i)}\) 是数据集中第 \(i\) 个实例的所有特征值的向量（标签特征除外），\(y{(i)}\) 是标签（也就是我们期待该实例的输出值） X 是数据集中所有实例所有特征值的矩阵（标记特征除外）。每个实例一行，也就是说第 \(i\) 行等于 \(x^{(i)}\) 的转置矩阵1，记作 \((x^{(i)})^T\) h 是系统的预测函数，也称为一个假设。当给定系统一个实例的特征向量 \(x^{(i)}\) ，他会输出一个预测值 \(\hat{y}=h(x^{(i)})\) RMSE(X,h) 是使用假设 h 在示例上测量的成本函数。 转置运算符会将列向量转换成行向量。 ↩︎
</p>
  </div>
  <footer class="entry-footer"><span title='2020-09-12 09:45:00 +0800 +0800'>September 12, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to RMSE（均方根误差）" href="https://notes.0081800.xyz/notes/20200912094544-rmse_%E5%9D%87%E6%96%B9%E6%A0%B9%E8%AF%AF%E5%B7%AE/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">机器学习涉及数学概念
    </h2>
  </header>
  <div class="entry-content">
    <p>公式 RMSE（均方根误差） MAE（平均绝对误差） 概念 标准差（Std Dev） 范数 方差 皮尔逊相关系数（标准相关系数） 线性相关性</p>
  </div>
  <footer class="entry-footer"><span title='2020-09-12 09:38:00 +0800 +0800'>September 12, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to 机器学习涉及数学概念" href="https://notes.0081800.xyz/notes/20200912093811-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%B6%89%E5%8F%8A%E6%95%B0%E5%AD%A6%E6%A6%82%E5%BF%B5/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Python behind the scenes #1: how the CPython VM works
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Translate,Python 原文链接：Python behind the scenes #1: how the CPython VM works。
Python 幕后 #1: CPython 虚拟机如何工作 介绍（Introduction） 你是否曾经好奇过当你运行 Python 代码时 python 做了些什么？
$ python script.py 这篇文章将开启一个系列来尝试解答这个问题。我们将深入 Python 最流行的实现 CPython 的内部。 通过深入 CPython 的内部我们将更深一层的去理解这门编程语言本身。这也是我们这个系列的最主要的目标。 如果你熟悉 Python 并且可以阅读 C 代码，但是对 CPython 源码本身没有太多的经验， 那么你可能非常适合本系列，并且对本系列感兴趣。
什么是 CPython 并且为什么有人想学习它（What CPython is and why anyone would want to study it） 我们首先来说明一些众所周知的事情。CPython 是用 C 编写的 Python 解析器。他是 Python 语言的众多实现 的一种，其他还有诸如 PyPy、Jython、IronPython 等。CPython 的独特之处在于它是 Python 的起源、维护时间最长也是最受欢迎的。
CPython 实现了 Python，但是 Python 是什么？最简单的一个答案可能是：Python 是一门编程语言。 当正确问相同的问题，那么答案将会更加明确：什么定义了 Python？Python 不像 C 语言有正式的规范， 但是与之相近的是 Python 语言参考（Python Language Reference），它以如下内容开始：
...</p>
  </div>
  <footer class="entry-footer"><span title='2020-09-08 10:36:00 +0800 +0800'>September 8, 2020</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Python behind the scenes #1: how the CPython VM works" href="https://notes.0081800.xyz/notes/20200908103647-python_behind_the_scenes_1_how_the_cpython_vm_works/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">机器学习测试与验证
    </h2>
  </header>
  <div class="entry-content">
    <p>将数据分成两部分：训练集和测试集，通常使用 80% 的数据进行训练，20% 的数据用来测试。
验证集 单独分出来一个保留集合作为验证集，防止调整模型和超参数拟合测试集的最佳模型。
交叉验证 为避免验证集浪费太多数据，交叉验证将训练集分成若干个互补子集，然后每个模型都通过这些子集的不同组合来 训练，之后用剩余的子集进行验证。
</p>
  </div>
  <footer class="entry-footer"><span title='2020-09-07 08:12:00 +0800 +0800'>September 7, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to 机器学习测试与验证" href="https://notes.0081800.xyz/notes/20200907081217-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%B5%8B%E8%AF%95%E4%B8%8E%E9%AA%8C%E8%AF%81/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">机器学习的主要挑战
    </h2>
  </header>
  <div class="entry-content">
    <p>训练数据的数量不足 训练数据不具代表性 质量差的数据 无关特征 特征工程 一个成功的机器学习项目，关键部分是提取一组好的用了训练的特征集，这个过程叫做特征工程。
特征选择 特征提取 通过手机数据创造新的特征 训练数据过度拟合 在模型的训练数据上表现良好，但是泛化时却不尽人如意。
解决方法
简化模型 收集更多的训练数据 减少训练数据中的噪声（修复数据错误和消除异常值） 正则化 通过约束模型使其更简单，并降低过度拟合风险。
超参数 通过调整超参数来调整应用正则化的程度。调整超参数是构建机器学习系统的非常重要的组成部分。
训练数据拟合不足 解决方法：
选择一个带有更多参数、更强大的模型 给学习算法提供更好的特征集 减少模型中的约束（如减少正则化超参数） </p>
  </div>
  <footer class="entry-footer"><span title='2020-09-07 08:03:00 +0800 +0800'>September 7, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to 机器学习的主要挑战" href="https://notes.0081800.xyz/notes/20200907080323-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8C%91%E6%88%98/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">机器学习系统的种类
    </h2>
  </header>
  <div class="entry-content">
    <p>监督式/无监督式学习 监督式学习 定义 训练数据经过标注包含素所需解决方案（标签或标记）
相关算法 K-邻近算法 线性回归 逻辑回归：广泛用于分类，输出“属于某个给定类别的概率”的值 支持向量机 决策树和随机森林 神经网络 适应场景 分类任务 预测变量 无监督式学习 定义 训练数据未经标注
相关算法 聚类算法 K-平均算法 分层聚类分析 最大期望算法 可视化和降维 主成分分析 核主成分分析 局部线性嵌入 t-分布随机临近嵌入 关联规则学习 Apriori Eclat 适应场景 通过聚类算法检测相似（层次聚类算法精度更高，可以再次细分） 可视化算法 降维：不丢失太多信息的前提下简化数据，方法之一是合并特征，过程叫做特征提取 异常检测：判断新的输入是正常还是异常，数据初筛、防作弊等 关联规则学习：发现属性之间有趣的联系 半监督式学习 大量未标记数据和少量标记数据进行学习。
强化学习 观察环境、作出选择、执行操作、并获得回报（负值则为惩罚）。
批量学习和在线学习 在数据流中进行增量学习。
批量学习 在线学习 在线学习也称为增量学习，同时支持恢复到上一状态，便于检测到性能下降及时中断和回滚。
核外学习 超大数据集超出一台计算机的主存储器，每次加载部分数据并不断重复直至完成训练。
学习率 学习率高系统迅速适应新数据，同时快速忘记老数据，学习率低则反之。
基于实例和基于模型的学习 基于实例的学习 系统完全记住学习示例，然后通过某种相似度度量方式将其泛化到新的实例。
基于模型的学习 模型选择 观察数据得出模型的过程。
衡量模型表现 定义效用函数（或适应度函数）来衡量模型有多好 定义成本函数来衡量模型有多差 线性回归通常选择成本函数来衡量线性模型的预测和训练实例之间的差距。
线性回归算法的意义所在：通过你提供的训练样本，找出最符合所提供数据的线性模型的参数，这就是训练过程。
</p>
  </div>
  <footer class="entry-footer"><span title='2020-09-07 07:42:00 +0800 +0800'>September 7, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to 机器学习系统的种类" href="https://notes.0081800.xyz/notes/20200907074200-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%A7%8D%E7%B1%BB/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">《机器学习实战》读书笔记
    </h2>
  </header>
  <div class="entry-content">
    <p>概览 机器学习系统的种类 机器学习的主要挑战 机器学习测试与验证 模型是观察的简化。
相关数学概念 机器学习涉及数学概念 </p>
  </div>
  <footer class="entry-footer"><span title='2020-09-05 07:57:00 +0800 +0800'>September 5, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to 《机器学习实战》读书笔记" href="https://notes.0081800.xyz/notes/20200905075701-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Machine Learning
    </h2>
  </header>
  <div class="entry-content">
    <p> scikit-learn 提供一些常见的机器学习算法 逻辑回归(Logistic Regression aka LR) 线性分类器 XGBoost 提供随机森林解决逻辑回归特征不明显的问题 </p>
  </div>
  <footer class="entry-footer"><span title='2020-09-03 18:02:00 +0800 +0800'>September 3, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Machine Learning" href="https://notes.0081800.xyz/notes/20200903180214-machine_learning/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Rust Obscure Words for non-native English speakers
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Rust,Learning English
unwinding
</p>
  </div>
  <footer class="entry-footer"><span title='2020-08-29 08:11:00 +0800 +0800'>August 29, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Rust Obscure Words for non-native English speakers" href="https://notes.0081800.xyz/notes/20200829081145-rust_obscure_words_for_non_native_english_speakers/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Rust Asynchronous Programming
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Rust Future async fn 将一个代码块转换为一个 Future 对象， Future 对象维护一个状态机 Future 对象必须运行在一个 Executor 上 Executor futures::executor::block_on 阻塞当前线程直到 future 完成
// `block_on` blocks the current thread until the provided future has run to // completion. Other executors provide more complex behavior, like scheduling // multiple futures onto the same thread. use futures::executor::block_on; async fn hello_world() { println!(&#34;hello, world!&#34;); } fn main() { let future = hello_world(); // Nothing is printed block_on(future); // `future` is run and &#34;hello, world!&#34; is printed } await await 异步的等待 future 完成，不阻塞当前线程，可以配合 futures::join! 可以同时 await 多个 future futures::try_join! 如果其中一个子 future 返回错误则立即返回（join! 需要等所有 future 全部返回） futures::select! 任意一个 future 完成则立即返回 async fn learn_and_sing() { // Wait until the song has been learned before singing it. // We use `.await` here rather than `block_on` to prevent blocking the // thread, which makes it possible to `dance` at the same time. let song = learn_song().await; sing_song(song).await; } async fn async_main() { let f1 = learn_and_sing(); let f2 = dance(); // `join!` is like `.await` but can wait for multiple futures concurrently. // If we&#39;re temporarily blocked in the `learn_and_sing` future, the `dance` // future will take over the current thread. If `dance` becomes blocked, // `learn_and_sing` can take back over. If both futures are blocked, then // `async_main` is blocked and will yield to the executor. futures::join!(f1, f2); } fn main() { block_on(async_main()); } </p>
  </div>
  <footer class="entry-footer"><span title='2020-08-28 16:08:00 +0800 +0800'>August 28, 2020</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Rust Asynchronous Programming" href="https://notes.0081800.xyz/notes/20200828160809-rust_asynchronous_programming/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Go Swagger 实现代码即文档
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Go 目标 当跟随这篇文章完成后将产出如下内容：
代码 http://gitlab.17zuoye.net/vgo/go-swagger-example 文档 http://swagger.17zuoye.net/?url=http%3A%2F%2F10.200.242.61%3A9090%2Fswagger.json 准备 Go1.14 及以上版本 安装 go-swagger ：参见 官方文档。 接下来使用 gin 框架作为示例，如果之前没接触过可以先了解下该框架 创建一个项目 $ mkdir go-swagger-example $ cd go-swagger-example/ $ go mod init gitlab.17zuoye.net/vgo/go-swagger-example 开始使用 首先在你的 `main.go` 定义 go generate 像下面这样：
//go:generate swagger generate spec -o ./swagger.yml package main func main() { println(&#34;Hello world!&#34;); } 此时如果运行 go generate 在项目目录下就会生成一个 swagger.yml 文件：
paths: {} swagger: &#34;2.0&#34; 使用单独的包托管 swagger 相关定义 在之前实践的过程中发现，如果在多个包中定义了相同名称的结构体会到只一个结构体覆盖另外一个结构体的定义。 所以为了解决这个问题，我把所有 swagger 相关的定义都放在同一个包下来避免相同名字的结构体。
创建 swagger/swagger.go 填充如下内容：
// Package swagger defines API documentation. // // Swagger 演示后端接口 // // Schemes: http // Host: 10.200.242.35:8080 // BasePath: /api/ // Version: 0.1.0 // Contact: 王会&lt;hui.wang.a@17zuoye.com&gt; // // Consumes: // - application/json // // Produces: // - application/vnd.17zuoye.v1&#43;json // // swagger:meta package swagger 上面文件通过注释来定义了一些接口相关的信息，包括：
...</p>
  </div>
  <footer class="entry-footer"><span title='2020-08-28 10:47:00 +0800 +0800'>August 28, 2020</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Go Swagger 实现代码即文档" href="https://notes.0081800.xyz/notes/20200828104706-go_swagger/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">MySQL forget password
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: MySQL 启动 mysqld 时加上 --skip-grant-tables 参数可以无密码进入 MySQL。
</p>
  </div>
  <footer class="entry-footer"><span title='2020-08-27 19:59:00 +0800 +0800'>August 27, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to MySQL forget password" href="https://notes.0081800.xyz/notes/20200827195950-mysql_forget_password/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">MVCC
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: MySQL https://liuzhengyang.github.io/2017/04/18/innodb-mvcc/ 来自《高性能 MySQL》：
InnoDB 在每一行都隐式的多存储两个字段：
事务更新版本 事务删除版本 当事务开始时记录这两个版本，在读取的时候根据 Undo Log 和 Redo Log 来实现隔离级别的控制。序列化隔离级别下只能通过行锁来保证。
在可重复读隔离级别下：
首先判断事务更新版本是否大于事务开始前的版本 如果大于则根据 Undo Log 进行回退实现可重复读，这样在同一事务下不管读多少遍读取到的内容都是一样的。 可重复读隔离即便下无法避免幻读：即一开始没有读取到，随着其他插入事务的提交在同一事务里执行查询又能读取到的情况。
</p>
  </div>
  <footer class="entry-footer"><span title='2020-08-27 19:58:00 +0800 +0800'>August 27, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to MVCC" href="https://notes.0081800.xyz/notes/20200827195823-mvcc/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">MySQL grant subnet
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: MySQL,Network https://stackoverflow.com/a/38389851/2873718
MySQL 授权用户子网段需要使用:
172.16.0.0/255.240.0.0 而不能使用
172.16.0.0/12 </p>
  </div>
  <footer class="entry-footer"><span title='2020-08-27 19:56:00 +0800 +0800'>August 27, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to MySQL grant subnet" href="https://notes.0081800.xyz/notes/20200827195621-mysql_grant_subnet/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Network
    </h2>
  </header>
  <div class="entry-content">
    <p></p>
  </div>
  <footer class="entry-footer"><span title='2020-08-27 18:06:00 +0800 +0800'>August 27, 2020</span>&nbsp;·&nbsp;0 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Network" href="https://notes.0081800.xyz/notes/20200827180638-network/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">逻辑右移
    </h2>
  </header>
  <div class="entry-content">
    <p>位移产生的空白填上 0，会导致有符号的负数变成正数。
</p>
  </div>
  <footer class="entry-footer"><span title='2020-08-02 16:55:00 +0800 +0800'>August 2, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to 逻辑右移" href="https://notes.0081800.xyz/notes/20200802165502-%E9%80%BB%E8%BE%91%E5%8F%B3%E7%A7%BB/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">算数右移
    </h2>
  </header>
  <div class="entry-content">
    <p>位移的产生的空白填上符号位。
</p>
  </div>
  <footer class="entry-footer"><span title='2020-08-02 16:51:00 +0800 +0800'>August 2, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to 算数右移" href="https://notes.0081800.xyz/notes/20200802165150-%E7%AE%97%E6%95%B0%E5%8F%B3%E7%A7%BB/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">汇编
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Computer Systems,《深入理解计算机系统》读书笔记 程序编码 $ gcc -Og -S mstore.c # outputs mstore.s $ gcc -Og -c mstore.c # outptus mstore.o $ objdump -d mstore.o 所有以 ‘.’ 开头额行都是指导汇编器和链接器工作额伪指令。
数据格式 C 声明 Intel 数据类型 汇编代码后缀 大小（字节） char 字节 b 1 short 字 w 2 int 双字 l 4 long 四字 q 8 char* 四字 q 8 float 单精度 l 4 double 双精度 q 8 访问信息 寄存器 一个 x86-64 的中央处理单元（CPU）包含一组 16 个存储 64 位值的 通用目的寄存器 。
四字 双字 字 字节 用途 %rax %eax %ax %al 返回值 %rbx %ebx %bx %bl 被调用者保存 %rcx %ecx %cx %cl 第四个参数 %rdx %edx %dx %dl 第三个参数 %rsi %esi %si %sil 第二个参数 %rdi %edi %di %dil 第一个参数 %rbp %ebp %bp %bpl 被调用者保存 %rsp %esp %sp %spl 栈指针 %r8 %r8d %r8w %r8b 第五个参数 %r9 %r9d %r9w %r9b 第六个参数 %r10 %r10d %r10w %r10b 调用者保存 %r11 %r11d %r11w %r11b 调用者保存 %r12 %r12d %r12w %r11b 被调用者保存 %r13 %r13d %r13w %r13b 被调用者保存 %r14 %r14d %r14w %r14 被调用者保存 %r15 %r15d %r15w %r15 被调用者保存 相关规则：
...</p>
  </div>
  <footer class="entry-footer"><span title='2020-08-02 15:50:00 +0800 +0800'>August 2, 2020</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to 汇编" href="https://notes.0081800.xyz/notes/20200802155053-%E6%B1%87%E7%BC%96/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">IEEE 浮点数
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Computer Systems,《深入理解计算机系统》读书笔记 浮点数小数表示形式 .0111 = \(0x2^{-1}&#43;2^{-2}&#43;2^{-3}&#43;2^{-4}\)
IEEE 浮点数表示形式 \[ V=(-1)^s X M X 2^E \]
s = 0 表示负数， s = 1 表示正数 M 是二进制表示的小数 E 是阶码 浮点数二进制组成 一个单独符号位 s 表吗符合 k 位阶码字段 exp 编码阶码 E n 位小数字段 frac 编码尾数 M 两种常见的格式 float s = 1 k = 8 n = 23 double s = 1 k = 11 n = 52 三种计算方式 前置的一些值
e 是 exp 位表示的无符号数 f 是 frac 位表示的小数 \(Bias = 2^{k-1} -1\) 规格化的值 规则：阶码字段 exp 的位模式即不全为 0，也不全为 1（单精度 255，双精度 2047） 计算方式 \(E = e - Bias\) $M = 1 &#43; f $ 非规格化的值 规则：阶码字段 exp 全是 0（用于表示 0） 计算方式 \(E = 1 - Bias\) \(M = f\) 可以表示 &#43;0 和 -0。
...</p>
  </div>
  <footer class="entry-footer"><span title='2020-08-02 15:15:00 +0800 +0800'>August 2, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to IEEE 浮点数" href="https://notes.0081800.xyz/notes/20200802151523-ieee_%E6%B5%AE%E7%82%B9%E6%95%B0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Choosing a Rust web framework, 2020 edition
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Rust source: Choosing a Rust web framework, 2020 edition </p>
  </div>
  <footer class="entry-footer"><span title='2020-07-10 10:12:00 +0800 +0800'>July 10, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Choosing a Rust web framework, 2020 edition" href="https://notes.0081800.xyz/notes/20200710101214-web/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">SSH
    </h2>
  </header>
  <div class="entry-content">
    <p>SSH Port Forwarding -L 将远端机器的端口映射到本地 -R 将本地端口映射到远端 </p>
  </div>
  <footer class="entry-footer"><span title='2020-07-07 21:46:00 +0800 +0800'>July 7, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to SSH" href="https://notes.0081800.xyz/notes/20200707214623-ssh/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Fearless Concurrency with Rust
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Rust 原文链接：https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html </p>
  </div>
  <footer class="entry-footer"><span title='2020-07-03 10:40:00 +0800 +0800'>July 3, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Fearless Concurrency with Rust" href="https://notes.0081800.xyz/notes/20200703104039-fearless_concurrency_with_rust/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Rust Means Never Having to Close a Socket
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Translate,Rust,Rust Wrapper Types 原文链接：Rust Means Never Having to Close a Socket
Rust 最酷的特性之一就是它可以自动地帮助你管理资源，同时在仍能保持安全（没有段错误）和高性能。
这是因为 Rust 是一门与众不同地编程语言，要理解我说的可能有点困难，让我来更近一步说明：
Rust 就像带垃圾回收的编程语言，你无需手动释放内存 Rust 不同于其他带垃圾回收的编程语言，你无需1手动关闭或者释放像文件、套接字和锁这样的资源 Rust 达到以上这些特性不附带任何运行时开销（垃圾回收或者引用计数），并且不牺牲安全性。 如果你曾经造成过一个套接字或者文件泄漏，或者使用过一些抽象方法造成了这些资源的泄漏，那么你就会知道这有多重要。
你可能已经期望通过“使用后释放”来避免内存问题，而与此同时你并没有考虑到没有明确地关闭套接字可能出现类似的错误。我在这里告诉你，还有更好地办法。
如果你使用的是带垃圾回收的编程语言，则应密切关注本文提到的资源管理方面的内容。如果你使用的是像 C/C&#43;&#43; 这样底层编程语言，你可能会对安全方面更加感兴趣。
Rust 的许多特性都是从其他语言借鉴而来。Rust 之所以变得有趣是因为它把所有的这些特性放在了一起，并且在编程语言层面实现了更严格地保证。 实际上，这种编程语言层面的保证让这些特性更加实用。
所有权系统（The Ownership System） 让这种保证工作的方式是通过 Rust 的「所有权（ownership）」系统。不管任何时候你创建一个新的对象，都被创建它的「作用域（scope）」所拥有。
让我们通过一个例子来进一步说明：我们定义一个函数，函数拷贝输入文件到临时文件去处理它，然后拷贝输入文件到输出文件。
fn process(from: &amp;Path, to: &amp;Path) -&gt; IoResult&lt;()&gt; { // creates a new tempdir with the specified suffix let tempdir = try!(TempDir::new(&#34;skylight&#34;)); // open the input file let mut from_file = try!(File::open(from)); // create a temporary file inside the tempdir let mut tempfile = try!(File::create(&amp;tempdir.path().join(&#34;tmp1&#34;))); // copy the input file into the tempfile try!(io::util::copy(&amp;mut from_file, &amp;mut tempfile)); // use an external program to process the tmpfile in place // after processing, copy the tempfile into the output file let mut out = try!(File::create(to)); io::util::copy(&amp;mut tempfile, &amp;mut out) } 在这个例子中，函数 process 的作用域再第一行创建了 TempDir 是其初始拥有者。在这个例子中， process 函数从未放弃所有权，所以当函数完成调用， 它就会自动被丢弃（dropped），也就是会删除 Tempfile 。
...</p>
  </div>
  <footer class="entry-footer"><span title='2020-06-29 18:17:00 +0800 +0800'>June 29, 2020</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Rust Means Never Having to Close a Socket" href="https://notes.0081800.xyz/notes/20200629181735-rust_means_never_having_to_close_a_socket/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Rust 并发
    </h2>
  </header>
  <div class="entry-content">
    <p>并发 std::marker::Send 允许跨线程转移所有权 Send 标记特性用于标识实现该特性的类型的所有权可以在线程中间转移，几乎所有 Rust 类型都实现了 Send ，但是也有一些例外如：
Rc&lt;T&gt; ，如果克隆后在多个线程中转移所有权可能会多个线程同时增加计数器，可以使用 Arc&lt;T&gt; 替代 如果一个新的类型组合的类型都实现了 Send 那么该类型也自动实现了 Send ，几乎所有原始类型都实现了 Send .
std::marker::Sync 允许多个线程同时访问 Sync 标记特性用于标识实现该特性的类型可以在多个线程中引用，任何类型 T 是 Sync 并且 T 的引用 &amp;T 是 Send 则意味着引用可以安全的发送给其他线程。
同 Send 类似，几乎所有原始类型都实现了 Sync ，组合了所有类型都是 Sync 的类型自动实现 Sync 。
以下只能指针没有实现 Sync
Rc&lt;T&gt; 同样没有实现 Sync RcCell&lt;T&gt; 和 Cell&lt;T&gt; 自己实现 Sync 和 Send 是不安全的</p>
  </div>
  <footer class="entry-footer"><span title='2020-06-29 18:07:00 +0800 +0800'>June 29, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Rust 并发" href="https://notes.0081800.xyz/notes/20200629180709-rust_%E5%B9%B6%E5%8F%91/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Rust 宏
    </h2>
  </header>
  <div class="entry-content">
    <p>三种宏 自定义 #[derive] 属性行为（attribute-like）宏，Rust 属性宏解析 函数行为（function-like）宏 宏 实现元编程，代码生成代码，必须带入当前命名空间内才能使用（不能使用 mod::sub::macro! 这种方式调用）。
#[macro_export] macro_rules! vec { ( $($x:expr), *) =&gt; { // $() 用于捕捉值，$x:expr 匹配 Rust 表达式并绑定到 $x，逗号（,）表明一个逗号可能出现在表达式后面，* 表明表达式匹配一次或多次 { let mut temp_vec = Vec::new(); ${ temp_vec.push($x); }* temp_vec } }; } 调用宏用于从属性生成代码 有点像编译期的装饰器：
use proc_macro; #[some_attribute] pub fn some_name(input: TokenStream) -&gt; TokenStream { // --snip-- } </p>
  </div>
  <footer class="entry-footer"><span title='2020-06-29 18:06:00 +0800 +0800'>June 29, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Rust 宏" href="https://notes.0081800.xyz/notes/20200629180623-rust_%E5%AE%8F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">智能指针
    </h2>
  </header>
  <div class="entry-content">
    <p>智能指针 表现的像一个指针，拥有数据并允许在对数据进行维护。
通常通过 struct 实现并实现两个特性 Deref 和 Drop
Deref 允许智能指针实例行为像一个引用，让代码可以同时处理引用和智能指针 Drop 允许自定义智能指针超出作用域的行为。 标准库常见的智能指针
Box&lt;T&gt; 用于在堆分配值 Rc&lt;T&gt; 引用计数类型，允许多个拥有者 Ref&lt;T&gt; 和 RefMut&lt;T&gt; 和通过 RefCell&lt;T&gt; 访问，运行时取代编译期强制检查借用规则 Box&lt;T&gt; 场景：
编译期未知大小的类型（递归类型（自己包含自己类型的类型，如链表）编译期无法确定大小）
// 递归类型 enum List { Cons(i32, Box&lt;List&gt;), Nil, } fn main() { let b = Box::new(5); println!(&#34;b = {}&#34;, b); let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil)))))); } 避免大量数据转移所有权时发生拷贝
拥有一个实现特定特性的值（不关心具体类型）的所有权
Deref 用于自定义解引用操作符（ * ） 的行为，智能指针通过实现该特性来模拟普通引用的行为。
对比
fn main() { let x = 5; let y = &amp;x; assert_eq!(5, x); assert_eq!(5, *y); // must dereference } 和
...</p>
  </div>
  <footer class="entry-footer"><span title='2020-06-29 18:05:00 +0800 +0800'>June 29, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to 智能指针" href="https://notes.0081800.xyz/notes/20200629180545-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">迭代器
    </h2>
  </header>
  <div class="entry-content">
    <p>迭代器 所有的迭代器都实现了 Iterator 特性：
pub trait Iterator { type Item; // 关联类型 fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;; // 返回 None 结束循环 } </p>
  </div>
  <footer class="entry-footer"><span title='2020-06-29 18:05:00 +0800 +0800'>June 29, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to 迭代器" href="https://notes.0081800.xyz/notes/20200629180506-%E8%BF%AD%E4%BB%A3%E5%99%A8/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">生命周期
    </h2>
  </header>
  <div class="entry-content">
    <p>生命周期 Rust 中的每一个引用都有其生命周期：引用有效的作用域。 大部分情况下生命周期都是隐式和自举的，在无法完成的情况下就需要我们通过生命周期泛型参数帮助编译器进行注解。 生命周期的主要目标是避免悬空指针。 生命周期泛型参数定义各个引用之间（参数和参数、参数和返回值）的关系，并不改变（延长）变量原本的生命周期 &amp;i32 // a reference &amp;&#39;a i32 // a reference with an explicit lifetime &amp;&#39;a mut i32 // a mutable reference with an explicit lifetime 参考以下代码
fn longest&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str { if x.len() &gt; y.len() { x } else { y } } 以上代码
标注生命周期 &#39;a 函数有两个引用参数，都使用生命周期 &#39;a 表示两个参数的生命周期必须一致（存活的周期一样长） 函数返回一个引用，并且存活的时间和生命周期 &#39;a 一致 以上指定不改变任何传入的引用的生命周期，我们只是要求借用检查器（borrow checker）检查这些约束。 也就是说借用检查器要检查传入的两个引用的生命周期必须一致，返回的引用的存活周期不能超过传入的引用的存活周期 思考 当函数返回一个引用时，返回值的生命周期注解要和参数的其中之一相匹配，否则那么引用就是指向里函数内创建的值（不能返回）。 也就是说返回引用时，引用的声明周期必须和参数（其一）相关。如果想要返回函数内创建的值最好返回一个有所有权的值类型。
结构体生命周期 如果结构体需要持有引用，需要在定义结构体时给每一个引用都加上生命周期注解。
如果结构体声明了生命周期参数，那么 impl 同样也要声明。
struct ImportantExcerpt&lt;&#39;a&gt; { part: &amp;&#39;a str, } impl&lt;&#39;a&gt; ImportantExcerpt&lt;&#39;a&gt; { fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str { println!(&#34;Attention please: {}&#34;, announcement); self.part } } 生命周期省略（elision）规则 函数参数的生命周期为输入生命周期 函数返回值的生命周期为输出生命周期 3 个规则用于 fn 和 impl ：
...</p>
  </div>
  <footer class="entry-footer"><span title='2020-06-29 18:04:00 +0800 +0800'>June 29, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to 生命周期" href="https://notes.0081800.xyz/notes/20200629180413-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">闭包
    </h2>
  </header>
  <div class="entry-content">
    <p>let add_one = | num | { num &#43; 1 }; 由于闭包和当前上下文相关联，所以 Rust 可以进行类型推导，类型注解也就不是必要的，但是依然可以自己添加：
let add_one = | num: i32 | { num &#43; 1 }; fn add_one_v1 (x: u32) -&gt; u32 { x &#43; 1 } let add_one_v2 = |x: u32| -&gt; u32 { x &#43; 1 }; let add_one_v3 = |x| { x &#43; 1 }; let add_one_v4 = |x| x &#43; 1 ; 使用 Fn 存储闭包类型
struct Cacher&lt;T&gt; where T: Fn(u32) -&gt; u32 { calculation: T, value: Option&lt;u32&gt;, } impl Cacher&lt;T&gt; where T: Fn(u32) -&gt; u32 { fn new(calculation: T) -&gt; Cacher&lt;T&gt; { Cacher { calculation, value: None, } } fn value(&amp;mut self, arg: u32) -&gt; u32 { if let Some(value) = self.value { value } else { let value = (self.calculation)(arg); self.value = Some(value); value } } } 闭包和函数的区别：闭包会捕捉当前环境，但是函数不会。
...</p>
  </div>
  <footer class="entry-footer"><span title='2020-06-29 18:04:00 +0800 +0800'>June 29, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to 闭包" href="https://notes.0081800.xyz/notes/20200629180436-%E9%97%AD%E5%8C%85/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Traits
    </h2>
  </header>
  <div class="entry-content">
    <p>Traits 定义行为在多个类型中共享。 可以定义默认行为在实现者中间共享。 可以用于定义参数的行为，同样可以定义返回值行为，当用 trait 限定返回值类型时，不能同时（if/else）返回多种实现了该 trait 的类型。 pub trait Summary { fn summarize(&amp;self) -&gt; String; } pub struct Article{ pub title: String, } impl Summary for Article { fn summarize(&amp;self) -&gt; String { format!(&#34;{}&#34;, self.title) } } pub fn notify(item: impl Summary) { println!(&#34;{}&#34;, item.summarize()); } // trait bound 语法糖版本 pub fn notify&lt;T: Summary&gt;(item: T) { println!(&#34;{}&#34;, item.summarize()); } 定义参数行为 通过 impl ： fn notify(item: impl TraitName) ，用于简单明了的场景，比如一个参数 通过 trait bound ： fn notify&lt;T: TraitName&gt; (item: T) ，用于更复杂的场景，比如多个参数用于减少代码 可以通过 &#43; 连接： fn notify(T: TraitName &#43; Display) (item: T)
...</p>
  </div>
  <footer class="entry-footer"><span title='2020-06-29 18:03:00 +0800 +0800'>June 29, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Traits" href="https://notes.0081800.xyz/notes/20200629180345-traits/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">错误处理
    </h2>
  </header>
  <div class="entry-content">
    <p>enum Result&lt;T, E&gt; { Ok(T), Err(E), } ? 操作符 对比
use std::io; use std::io::Read; use std::fs::File; fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; { let f = File::open(&#34;hello.txt&#34;); let mut f = match f { Ok(file) =&gt; file, Err(e) =&gt; return Err(e), }; let mut s = String::new(); match f.read_to_string(&amp;mut s) { Ok(_) =&gt; Ok(s), Err(e) =&gt; Err(e), } } 和
use std::io; use std::io::Read; use std::fs::File; fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; { let mut f = File::open(&#34;hello.txt&#34;)?; let mut s = String::new(); f.read_to_string(&amp;mut s)?; Ok(s) } 和
...</p>
  </div>
  <footer class="entry-footer"><span title='2020-06-29 18:03:00 +0800 +0800'>June 29, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to 错误处理" href="https://notes.0081800.xyz/notes/20200629180301-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">if let
    </h2>
  </header>
  <div class="entry-content">
    <p>let some_u8_value = Some(0u8); // Without `if let` match some_u8_value { Some(3) =&gt; println!(&#34;three&#34;); - =&gt; (), } // With `if let` if let Some(3) = some_u8_value { println!(&#34;three&#34;); } </p>
  </div>
  <footer class="entry-footer"><span title='2020-06-29 18:02:00 +0800 +0800'>June 29, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to if let" href="https://notes.0081800.xyz/notes/20200629180202-if_let/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">模块化
    </h2>
  </header>
  <div class="entry-content">
    <p>包、crate 和模块 Cargo.toml 表示一个包
包含 0 个或 1 个库 crate（ src/lib.rs ） 包含 0 个或多个可执行 crate （ src/main.rs src/bin/*.rs ） 可以同时包含以上两种 模块化系统
模块，一种组织代码和控制路径隐私的方法
所有的项（函数，方法，结构体，枚举，模块和常量）默认私有 不允许使用私有的子模块的代码 可以使用父模块和同级模块的代码 路径，一种命名项的方法
use , 一个将路径带到当前作用域的关键字
pub ，一个将项公开的关键字
as ，一个将带到当前作用域项重命名的关键字
super , 一个相当于文件系统里 .. 作用的关键字
* ，通配符用于使用制定路径下的所有项
pub use 用于重新暴露可以访问的模块
模块可以放在一个文件，也可以按照一定规则拆分到不同文件下
使用同一个 use 清理嵌套的 use
use std::cmp::Ordering; use std::io; use std::{cmp::Ordering, io}; use std::io; use std::io::Write; use std::{self, Write}; mod sound { pub mod instrument { pub mod woodwind { pub fn clarinet() { super::breathe_in(); } } fn breathe_in() { } } mod voice { } } fn main() { // 绝对路径以 crate 开始，crate 表示根 crate::sound::instrument::woodwind::clarinet(); // 相对路径 sound::instrument::woodwind::clarinet(); } 上面例子 sound 模块并非公开，但是由于 main 和 sound 定义在同一模块下，所以允许在 main 中引用 sound 。
...</p>
  </div>
  <footer class="entry-footer"><span title='2020-06-29 18:02:00 +0800 +0800'>June 29, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to 模块化" href="https://notes.0081800.xyz/notes/20200629180233-%E6%A8%A1%E5%9D%97%E5%8C%96/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">模式匹配
    </h2>
  </header>
  <div class="entry-content">
    <p>#[derive(Debug)] enum UsState { Alabama, Alaska, } enum Coin { Penny, Nickel, Dime, Quarter(UsState), } fn value_cents(coin: Coin) -&gt; u8 { match coin { Coin::Peny =&gt; { println!(&#34;Lucy penny!&#34;); 1 }, Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10, Coin::Quarter(state) =&gt; { println!(&#34;State quarter from {:?}!&#34;, state); 25 }, } } // Option fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; { match x { None =&gt; None, Some(i) =&gt; Some(i &#43; 1), } } let five = Some(5); let six = plus_one(five); let none = plus_one(None); 编译器会检查 match 覆盖所有情况， _ 可以用于所有未覆盖的情况。
...</p>
  </div>
  <footer class="entry-footer"><span title='2020-06-29 18:01:00 +0800 +0800'>June 29, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to 模式匹配" href="https://notes.0081800.xyz/notes/20200629180131-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">枚举
    </h2>
  </header>
  <div class="entry-content">
    <p> 多种类型的集合体，一个类型的变量可以存储多种类型的值，枚举的每一项都是该枚举类型的变体：
enum IpAddrKind { V4, V6, } fn main() { route(IpAddrKind::V4); route(IpAddrkind::V6); } fn route(kind: IpAddrKind) { // ... } 枚举的每一个变体都可以直接包含数据，并且每一个变体可以包含不同的数据类型和不同的数量，甚至可以直接放结构体（也可以是匿名的）。
struct Ipv4Addr { // --snip-- } enum IpAddr { V4(Ipv4Addr), V6(String), } let home = IpAddr::V4(127, 0, 0, 1); let loopback = IpAddr::V6(String::from(&#34;::1&#34;)); struct Message { Quit, Move{ x: i32, y: i32 }, // anonymous struct Write(String), ChangeColor(i32, i32, i32), // three i32 values } 枚举也可以通过 impl 实现方法
impl Message { fn call(&amp;self) { match self { // ... } } } let m = Message::Write(String::from(&#34;hello&#34;)); m.call(); Option
...</p>
  </div>
  <footer class="entry-footer"><span title='2020-06-29 18:00:00 +0800 +0800'>June 29, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to 枚举" href="https://notes.0081800.xyz/notes/20200629180041-%E6%9E%9A%E4%B8%BE/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">结构体
    </h2>
  </header>
  <div class="entry-content">
    <p>结构体 元组结构体（tuple struct） 用于命名元组并和其他元组进行区分：
struct Color(i32, i32, i32); struct Point(i32, i32, i32); let black = Color(0, 0, 0); let origin = Point(0, 0, 0); 由于定义了元组结构体所有 black 和 origin 是两个不同的类型。
没有字段的结构体：类单元（Unit-Like）结构体 没有任何字段的结构体和单元类型 () 类似，用于实现一些特性（trait）但是没有任何数据。
方法语法 self 占有所有权
&amp;self 不可变借用
&amp;mut self 可变借用
自动引用和解引用
在 Rust 中进行方法调用，如 object.something ，Rust 会自动添加 &amp; &amp;mut 或者 * , 用以自动匹配方法签名。以下是等价的：
p1.distance(&amp;p2); (&amp;p1).distance(&amp;p2); 方法如果不声明 self 行参则是一个关联方法（静态方法），通过 :: 调用
struct Rectangle { width: u32, height: u32, } impl Rectangle { fn square(size: u32) -&gt; Rectangle { Rectangle{ width: size, height: size } } } let r = Rectangle::square(10); 每一个结构体可以有多个 impl 块。
...</p>
  </div>
  <footer class="entry-footer"><span title='2020-06-29 17:59:00 +0800 +0800'>June 29, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to 结构体" href="https://notes.0081800.xyz/notes/20200629175956-%E7%BB%93%E6%9E%84%E4%BD%93/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">引用和借用
    </h2>
  </header>
  <div class="entry-content">
    <p> 类型前置 &amp; 表示引用，引用允许变量指向一个值但是不发生所有权转移。 引用不占有所有权，所以变量超出作用域之后不会触发 drop 调用。 引用作为函数形参被成为借用（borrowing） 可变引用 针对特定作用域下的特定数据只能创建一个可变引用。如果要创建多个可变引用可以通过大括号创建新的作用域
let mut s = String::from(&#34;hello&#34;); { let s1 = mut &amp;s; } let s2 = mut &amp;s; 当已经存在不可变引用时，则无法再创建可变引用，下面代码无法编译通过
let mut s = String::from(&#34;hello&#34;); let s1 = &amp;s; // OK let s2 = &amp;s; // OK let s3 = mut &amp;s; // BIG PROBLEM 悬空引用 以下代码是不允许的，无法编译通过
fn main() { let s = dangling_string(); } fn dangling_string() -&gt; &amp;String { let s = String::from(&#34;hello&#34;); &amp;s } 上面代码 s 在函数内部分配，那么在函数执行完成后 s 将被释放，所以返回 s 的引用会造成悬空引用。
引用的规则 任何时间针对一个变量，只能有多个不可变引用或者一个可变引用 引用必须一直有效（生命周期） 分片 分片数据类型没有所有权。分片引用一片连续的序列的集合。
字符串分片 字符串分片是一个引用指向 String 的一部分。
let s = String::from(&#34;Hello world!&#34;) let hello = &amp;s[0..5]; let world = &amp;s[6..11]; 字符串字面量（&amp;str）是个指向二进制程序一块区域的字符串分片，所以函数声明字符串参数使用 &amp;str 会更通用：
...</p>
  </div>
  <footer class="entry-footer"><span title='2020-06-29 17:49:00 +0800 +0800'>June 29, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to 引用和借用" href="https://notes.0081800.xyz/notes/20200629174943-%E5%BC%95%E7%94%A8%E5%92%8C%E5%80%9F%E7%94%A8/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">所有权
    </h2>
  </header>
  <div class="entry-content">
    <p>规则 每个值都有一个变量叫做所有者（owner） 同一时间只能有一个所有者 当所有者超出作用域则值被销毁 变量作用域 作用域是一个变量有效的范围 当变量超出作用域范围自动调用对象的 drop 方法进行内存归还操作 变量相互作用：所有权转移（Move） 对于所有在栈上分配的值（固定大小），在进行赋值操作时都对值进行拷贝：
let x = 5; ley y = x; // copy 5 to y 但是对于在堆上分配的，变量保存的是指向内存的指针，所以在赋值时拷贝的也是指向该内存的指针：
let s1 = String::from(&#34;hello&#34;); let s2 = s1; 为了保证内存安全，防止 s1 和 s2 超出作用域范围调用两次 drop 造成重复的内存回收，Rust 会让 s1 不再有效，来避免对 s1 进行回收。继续使用 s1 会导致编译错误。这种情况叫做所有权转移（move）。
变量相互作用：克隆（Clone） 克隆用于深度拷贝变量：
let s1 = String::from(&#34;hello&#34;); let s2 = s1.clone(); println!(s1); 变量项目作用：拷贝（Copy） 如果数据类型的大小在编译期能够确定都将存储在栈上，这种情况下能够进行快速的拷贝。
Copy 特性（trait）注解用于将值存贮在栈栈上 Copy 特性注解不能和 Drop 特性注解混用 Copy 特性注解使用规则如下 所有的数字类型 所有的布尔型 所有的浮点型 字符类型 所有元素都实现了 Copy 特性注解的元祖 所有权和函数 函数传递实参的规则和变量类似，传递变量到一个函数将为发生所有权转移或者拷贝。
返回值和作用域 返回值可以转移所有权 将一个值赋给其他变量会产生所有权转移 一个包含堆分配的变量超出作用域将会被 drop 清理，除非所有权被转移到其他变量。 </p>
  </div>
  <footer class="entry-footer"><span title='2020-06-29 17:49:00 +0800 +0800'>June 29, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to 所有权" href="https://notes.0081800.xyz/notes/20200629174911-%E6%89%80%E6%9C%89%E6%9D%83/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://notes.0081800.xyz/page/13/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://notes.0081800.xyz/page/15/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://notes.0081800.xyz/">Taking Smart Notes With Org-mode</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
