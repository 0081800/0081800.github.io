<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>LeetCode101 | Taking Smart Notes With Org-mode</title>
<meta name="keywords" content="">
<meta name="description" content="tags: Algorithm,Data Structures 又要开始找工作了，刷题、刷题、刷题！步骤：
按顺序找到题目 解题/学习 总结考察的点（树、双指针、回溯、DP、模拟现实、递归） 刷相同解法框架的题 一些模糊的感觉：
尝试不同的遍历顺序可能是解题关键，正序遍历不行试一下反序遍历，反之亦然！ 以上到达一定量之后在 LeetCode 创建一个新的 session 重新刷起。">
<meta name="author" content="Gray King">
<link rel="canonical" href="https://notes.0081800.xyz/notes/20220311065137-leetcode101/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://notes.0081800.xyz/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://notes.0081800.xyz/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://notes.0081800.xyz/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://notes.0081800.xyz/apple-touch-icon.png">
<link rel="mask-icon" href="https://notes.0081800.xyz/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="LeetCode101" />
<meta property="og:description" content="tags: Algorithm,Data Structures 又要开始找工作了，刷题、刷题、刷题！步骤：
按顺序找到题目 解题/学习 总结考察的点（树、双指针、回溯、DP、模拟现实、递归） 刷相同解法框架的题 一些模糊的感觉：
尝试不同的遍历顺序可能是解题关键，正序遍历不行试一下反序遍历，反之亦然！ 以上到达一定量之后在 LeetCode 创建一个新的 session 重新刷起。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://notes.0081800.xyz/notes/20220311065137-leetcode101/" /><meta property="article:section" content="notes" />
<meta property="article:published_time" content="2022-03-11T06:51:00+08:00" />
<meta property="article:modified_time" content="2022-03-11T06:51:00+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LeetCode101"/>
<meta name="twitter:description" content="tags: Algorithm,Data Structures 又要开始找工作了，刷题、刷题、刷题！步骤：
按顺序找到题目 解题/学习 总结考察的点（树、双指针、回溯、DP、模拟现实、递归） 刷相同解法框架的题 一些模糊的感觉：
尝试不同的遍历顺序可能是解题关键，正序遍历不行试一下反序遍历，反之亦然！ 以上到达一定量之后在 LeetCode 创建一个新的 session 重新刷起。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://notes.0081800.xyz/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "LeetCode101",
      "item": "https://notes.0081800.xyz/notes/20220311065137-leetcode101/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "LeetCode101",
  "name": "LeetCode101",
  "description": "tags: Algorithm,Data Structures 又要开始找工作了，刷题、刷题、刷题！步骤：\n按顺序找到题目 解题/学习 总结考察的点（树、双指针、回溯、DP、模拟现实、递归） 刷相同解法框架的题 一些模糊的感觉：\n尝试不同的遍历顺序可能是解题关键，正序遍历不行试一下反序遍历，反之亦然！ 以上到达一定量之后在 LeetCode 创建一个新的 session 重新刷起。",
  "keywords": [
    
  ],
  "articleBody": " tags: Algorithm,Data Structures 又要开始找工作了，刷题、刷题、刷题！步骤：\n按顺序找到题目 解题/学习 总结考察的点（树、双指针、回溯、DP、模拟现实、递归） 刷相同解法框架的题 一些模糊的感觉：\n尝试不同的遍历顺序可能是解题关键，正序遍历不行试一下反序遍历，反之亦然！ 以上到达一定量之后在 LeetCode 创建一个新的 session 重新刷起。\n",
  "wordCount" : "15",
  "inLanguage": "en",
  "datePublished": "2022-03-11T06:51:00+08:00",
  "dateModified": "2022-03-11T06:51:00+08:00",
  "author":[{
    "@type": "Person",
    "name": "Gray King"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://notes.0081800.xyz/notes/20220311065137-leetcode101/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Taking Smart Notes With Org-mode",
    "logo": {
      "@type": "ImageObject",
      "url": "https://notes.0081800.xyz/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://notes.0081800.xyz/" accesskey="h" title="Taking Smart Notes With Org-mode (Alt + H)">Taking Smart Notes With Org-mode</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://notes.0081800.xyz/articles/" title="Articles">
                    <span>Articles</span>
                </a>
            </li>
            <li>
                <a href="https://notes.0081800.xyz/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://notes.0081800.xyz/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://notes.0081800.xyz/">Home</a>&nbsp;»&nbsp;<a href="https://notes.0081800.xyz/notes/">Notes</a></div>
    <h1 class="post-title">
      LeetCode101
    </h1>
    <div class="post-meta"><span title='2022-03-11 06:51:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King

</div>
  </header> 

  <div class="post-content"><ul>
<li>tags: <a href="/projects/20220104182327-algorithm/">Algorithm</a>,<a href="/projects/20220311073856-data_structures/">Data Structures</a></li>
</ul>
<p>又要开始找工作了，刷题、刷题、刷题！步骤：</p>
<ol>
<li>按顺序找到题目</li>
<li>解题/学习</li>
<li>总结考察的点（树、双指针、回溯、DP、模拟现实、递归）</li>
<li>刷相同解法框架的题</li>
</ol>
<p>一些模糊的感觉：</p>
<ol>
<li>尝试不同的遍历顺序可能是解题关键，正序遍历不行试一下反序遍历，反之亦然！</li>
</ol>
<p>以上到达一定量之后在 LeetCode 创建一个新的 session 重新刷起。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>


   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   
      
   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   
      
   

   
      
   

   
      
   

   
      
   

   
      
   

   
      
   

   
      
   

   
      
   

   

   
      
   

   

   

   
      
   

   
      
   

   
      
   

   

   

   

   

   
      
   

   
      
   

   

   

   

   

   

   

   
      
   

   
      
   

   

   

   

   

   

   
      
   

   
      
   

   
      
   

   
      
   

   
      
   

   
      
   

   
      
   

   

   
      
   

   

   

   
      
   

   
      
   

   
      
   

   

   
      
   

   
      
   

   

   
      
   

   
      
   

   
      
   

   
      
   

   
      
   

   
      
   

   
      
   

   

   

   

   

   

   

   

   
      
   

   

   
      
   

   

   
      
   

   

   
      
   

   

   

   

   

   

   
      
   

   

   

   

   
      
   

   

   

   

   
      
   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   


<hr />

  <div class="bl-section">
    <h3>Links to this note</h3>
    <br />
    <div class="backlinks">
      <ul>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCodeNJ
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Algorithm,Data Structures Make my best effort to move to Nanjing for my son. This is a successor of LeetCode101.</p>
            </div>
            <footer class="entry-footer"><span title='2022-06-06 07:10:00 +0800 +0800'>June 6, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCodeNJ" href="https://notes.0081800.xyz/notes/20220606071040-leetcodenj/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 347. Top K Frequent Elements
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Hash Table,Heap (data structure),LeetCode101,Priority Queue,C&#43;&#43; Lambda class Solution { public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { vector&lt;int&gt; res; unordered_map&lt;int, int&gt; freq; // Note that: we need caputre a map by reference, // otherwise we can&#39;t use the operator[]. // See also: https://stackoverflow.com/a/6281071 auto comp_by_map = [&amp;freq](const int&amp; a, const int&amp; b) { return freq[a] &lt; freq[b]; }; // Note that: here we need pass our lambda /comp_by_map/ to the // constructor of std::priority_queue....</p>
            </div>
            <footer class="entry-footer"><span title='2022-04-09 08:28:00 +0800 +0800'>April 9, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 347. Top K Frequent Elements" href="https://notes.0081800.xyz/notes/20220409082813-leetcode101_347_top_k_frequent_elements/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 27. Remove Element
              </h2>
            </header>
            <div class="entry-content">
              <p> tags: LeetCode101,In-place Travel array in reverse order, and record how many times need to swap, which is how many elements not equal val.
class Solution { public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int k = 0; for (int j = nums.size() - 1; j &gt;= 0; --j) { if (nums[j] == val) { for (int i = 0; i &lt; k; &#43;&#43;i) { swap(nums[i &#43; j], nums[j &#43; i &#43; 1]); } } else { k&#43;&#43;; } } return k; } }; </p>
            </div>
            <footer class="entry-footer"><span title='2022-04-08 13:11:00 +0800 +0800'>April 8, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 27. Remove Element" href="https://notes.0081800.xyz/notes/20220408131130-leetcode101_27_remove_element/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 18. 4Sum
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Two Pointers,Three Pointers,LeetCode101,Sorting Based on:
LeetCode101: 167. Two Sum II - Input Array Is Sorted LeetCode101: 15. 3Sum We create a new loop:
class Solution { public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) { sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; res; int T, S, r, l; for (int i = 0; i &lt; nums.size(); &#43;&#43;i) { if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) { continue; } for (int j = i &#43; 1; j &lt; nums....</p>
            </div>
            <footer class="entry-footer"><span title='2022-04-08 12:50:00 +0800 +0800'>April 8, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 18. 4Sum" href="https://notes.0081800.xyz/notes/20220408125015-leetcode101_18_4sum/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 703. Kth Largest Element in a Stream
              </h2>
            </header>
            <div class="entry-content">
              <p> tags: Priority Queue,LeetCode101 Using a min heap to keep k elements, top is the Kth largest element.
class KthLargest { private: // min heap priority_queue&lt;int, vector&lt;int&gt;, std::greater&lt;int&gt;&gt; pq; int K; public: KthLargest(int k, vector&lt;int&gt;&amp; nums) { K = k; for (auto n: nums) { add(n); } } int add(int val) { pq.push(val); while (pq.size() &gt; K) { pq.pop(); } return pq.top(); } }; /** * Your KthLargest object will be instantiated and called as such: * KthLargest* obj = new KthLargest(k, nums); * int param_1 = obj-&gt;add(val); */ </p>
            </div>
            <footer class="entry-footer"><span title='2022-04-08 12:39:00 +0800 +0800'>April 8, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 703. Kth Largest Element in a Stream" href="https://notes.0081800.xyz/notes/20220408123913-leetcode101_703_kth_largest_element_in_a_stream/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 1046. Last Stone Weight
              </h2>
            </header>
            <div class="entry-content">
              <p> tags: Heap (data structure),LeetCode101 Find top k values, classical heap problems.
Here we need find top 2 values, and pop them from heap, then we will meet two cases:
If they are not same, put back the differ between them, continue. Otherwise, continue directly. </p>
            </div>
            <footer class="entry-footer"><span title='2022-04-08 07:09:00 +0800 +0800'>April 8, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 1046. Last Stone Weight" href="https://notes.0081800.xyz/notes/20220408070926-leetcode101_1046_last_stone_weight/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 167. Two Sum II - Input Array Is Sorted
              </h2>
            </header>
            <div class="entry-content">
              <p> tags: LeetCode101,Sorting,Two Pointers Key ideas:
Move both sides to inwards. If the sum value less than target, move left pointer. Otherwise move right poinger. class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) { int S, l = 0, r = numbers.size() - 1; vector&lt;int&gt; res(2, 0); while (l &lt; r) { S = numbers[l] &#43; numbers[r]; if (S == target) { break; } if (S &lt; target) { l&#43;&#43;; } else { r--; } } res[0] = l &#43; 1; res[1] = r &#43; 1; return res; } }; </p>
            </div>
            <footer class="entry-footer"><span title='2022-04-07 08:19:00 +0800 +0800'>April 7, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 167. Two Sum II - Input Array Is Sorted" href="https://notes.0081800.xyz/notes/20220407081954-leetcode101_167_two_sum_ii_input_array_is_sorted/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 16. 3Sum Closest
              </h2>
            </header>
            <div class="entry-content">
              <p> tags: LeetCode101,Sorting,Two Pointers,Three Pointers Key ideas see LeetCode101: 15. 3Sum
class Solution { public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) { sort(nums.begin(), nums.end()); int closest = INT_MAX, l, r, sum, T, res; for (int i = 0; i &lt; nums.size(); i&#43;&#43;) { l = i &#43; 1; r = nums.size() - 1; T = target - nums[i]; while (l &lt; r) { sum = nums[l] &#43; nums[r]; if (abs(sum - T) &lt; closest) { res = sum &#43; nums[i]; closest = abs(sum - T); } if (sum == T) { return target; } if (sum &lt; T) { l&#43;&#43;; } else { r--; } } } return res; } }; </p>
            </div>
            <footer class="entry-footer"><span title='2022-04-07 08:10:00 +0800 +0800'>April 7, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 16. 3Sum Closest" href="https://notes.0081800.xyz/notes/20220407081015-leetcode101_16_3sum_closest/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 15. 3Sum
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: LeetCode101,Sorting,Two Pointers,Three Pointers Key ideas:
Sort the nums first. Then, we travel the nums, pick current element as nums[i], and apply LeetCode101: 167. Two Sum II - Input Array Is Sorted to the remains. We skip the same numbers to avoid duplicate. class Solution { public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); int l, r, sum, T; vector&lt;vector&lt;int&gt;&gt; res; for (int i = 0; i &lt; nums.size(); i&#43;&#43;) { // Skip same numbers to avoid duplicate if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) { continue; } l = i &#43; 1; r = nums....</p>
            </div>
            <footer class="entry-footer"><span title='2022-04-07 08:00:00 +0800 +0800'>April 7, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 15. 3Sum" href="https://notes.0081800.xyz/notes/20220407080010-leetcode101_15_3sum/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 680. Valid Palindrome II
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: String,Two Pointers,LeetCode101 Two pointers move inwards, when we meet two different characters:
Remove left character to see if the remains string still satisfied a valid palindrome. Remove right character to see if the remains string still satisfied a valid palindrome. Returns true if either one above two is true.
class Solution { public: bool validPalindrome(string s) { for (int i = 0, j = s.size() -1; i &lt; j; i&#43;&#43;,j--) { if (s[i] !...</p>
            </div>
            <footer class="entry-footer"><span title='2022-04-02 14:37:00 +0800 +0800'>April 2, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 680. Valid Palindrome II" href="https://notes.0081800.xyz/notes/20220402143729-leetcode101_680_valid_palindrome_ii/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 344. Reverse String
              </h2>
            </header>
            <div class="entry-content">
              <p> tags: In-place,LeetCode101,In-place Reverse class Solution { public: void reverseString(vector&lt;char&gt;&amp; s) { if (s.size() == 1) { return; } for (int i = 0; i &lt;= (s.size() - 2) / 2; &#43;&#43;i) { swap(s[s.size() - 1 - i], s[i]); } } }; </p>
            </div>
            <footer class="entry-footer"><span title='2022-04-01 10:42:00 +0800 +0800'>April 1, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 344. Reverse String" href="https://notes.0081800.xyz/notes/20220401104229-leetcode101_344_reverse_string/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 35. Search Insert Position
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Binary Search,LeetCode101 There is three corner cases must be handled if we don’t find target in nums:
Return r &#43; 1 if target is greater than right. Or return mid &#43; 1 if target is greater than mid. Otherwise return mid. class Solution { public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) { int l = 0, r = nums.size() - 1; int mid = r / 2; while (l !...</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-30 16:55:00 +0800 +0800'>March 30, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 35. Search Insert Position" href="https://notes.0081800.xyz/notes/20220330165507-leetcode101_35_search_insert_position/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 74. Search a 2D Matrix
              </h2>
            </header>
            <div class="entry-content">
              <p> tags: Divide-and-Conquer,LeetCode101,Binary Search class Solution { public: bool searchMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, int target) { int n = matrix.size(); int m = matrix[0].size(); int l = 0, r = m * n - 1; while (l != r){ int mid = l &#43; (r - l) / 2; if (matrix[mid / m][mid % m] &lt; target) l = mid &#43; 1; else r = mid; } return matrix[r / m][r % m] == target; } }; </p>
            </div>
            <footer class="entry-footer"><span title='2022-03-30 16:01:00 +0800 +0800'>March 30, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 74. Search a 2D Matrix" href="https://notes.0081800.xyz/notes/20220330160157-leetcode101_74_search_a_2d_matrix/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 287. Find the Duplicate Number
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Cycle detection,Fast &amp; Slow Pointers,LeetCode101 Treat as A Linked List with circle According to the length of nums is n &#43; 1, and integer range is [1, n], so we can treat each element as a index that point to some next value. For example:
[1,3,4,2,2] It can be treated as(format is element(index)):
1(0) -&gt; 3(1) -&gt; 2(3) -&gt; 4(3) -&gt; 2(4) -&gt; 4(3)
We can see there is a circle in it, so:...</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-29 18:14:00 +0800 +0800'>March 29, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 287. Find the Duplicate Number" href="https://notes.0081800.xyz/notes/20220329181423-leetcode101_287_find_the_duplicate_number/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 142. Linked List Cycle II
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Cycle detection,Fast &amp; Slow Pointers,LeetCode101 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { if (head == nullptr || head-&gt;next == nullptr) { return nullptr; } // tortoise move 1 step auto slow = head-&gt;next; // hare move 2 steps auto fast = head-&gt;next-&gt;next; while (slow !...</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-29 18:02:00 +0800 +0800'>March 29, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 142. Linked List Cycle II" href="https://notes.0081800.xyz/notes/20220329180222-leetcode101_142_linked_list_cycle_ii/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 215. Kth Largest Element in an Array
              </h2>
            </header>
            <div class="entry-content">
              <p> tags: Priority Queue,LeetCode101 Max heap priority queue class Solution { public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { // max heap priority_queue&lt;int&gt; pq; for (auto iter = nums.begin(); iter != nums.end(); &#43;&#43;iter) { pq.push(*iter); } // The Kth largest element should let k &gt; 1 not k &gt; 0 for (; k &gt; 1; --k) { pq.pop(); } return pq.top(); } }; </p>
            </div>
            <footer class="entry-footer"><span title='2022-03-29 07:23:00 +0800 +0800'>March 29, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 215. Kth Largest Element in an Array" href="https://notes.0081800.xyz/notes/20220329072317-leetcode101_215_kth_largest_element_in_an_array/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 1337. The K Weakest Rows in a Matrix
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Priority Queue,LeetCode101 The key ideas:
Use a std::pair to hold {count, index}, so it can compare count first then the index. Use a min heap priority queue to get the K weakest rows. class Solution { public: vector&lt;int&gt; kWeakestRows(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int k) { // min heap priority_queue&lt; std::pair&lt;int, int&gt;, vector&lt;std::pair&lt;int, int&gt; &gt;, std::greater&lt;std::pair&lt;int, int&gt; &gt; &gt; pq; for (auto iter = mat.begin(); iter != mat.end(); &#43;&#43;iter) { int c = count((*iter)....</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-29 07:14:00 +0800 +0800'>March 29, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 1337. The K Weakest Rows in a Matrix" href="https://notes.0081800.xyz/notes/20220329071403-leetcode101_1337_the_k_weakest_rows_in_a_matrix/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 881. Boats to Save People
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Hash Table,LeetCode101,Sorting,Two Pointers Intuition with HashMap class Solution { public: int numRescueBoats(vector&lt;int&gt;&amp; people, int limit) { unordered_map&lt;int, int&gt; cntOfWeights; for (auto iter = people.begin(); iter != people.end(); &#43;&#43;iter) { cntOfWeights[*iter]&#43;&#43;; } int r = 0; for (int i = 0; i &lt; people.size(); i&#43;&#43;) { if (cntOfWeights[people[i]] == 0) { continue; } cntOfWeights[people[i]]--; for (int j = (limit - people[i]); j &gt; 0; --j) { if (cntOfWeights.find(j) != cntOfWeights....</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-24 11:43:00 +0800 +0800'>March 24, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 881. Boats to Save People" href="https://notes.0081800.xyz/notes/20220324114305-881_boats_to_save_people/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 991. Broken Calculator
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Math,backtracking,LeetCode101 Backtracking and stack overflow Intuition:
We can abstract all the operations to a Tree, then apply DFS on it.
For example: startValue=2, target=3, the tree looks like:
/* 2 /\ / \ / \ 1(-1) 4(x2) /\ /\--&#43; / \ / \ 0(-1) 2(x2) 3(-1) 8(x2) */ class Solution { public: int brokenCalc(int startValue, int target) { unordered_set&lt;int&gt; visited; return backtracking(0, startValue, target, visited); } int backtracking(int count, int val, int target, unordered_set&lt;int&gt; &amp; visited) { if (val == target) { return count; } if (visited....</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-23 17:58:00 +0800 +0800'>March 23, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 991. Broken Calculator" href="https://notes.0081800.xyz/notes/20220323175835-leetcode101_991_broken_calculator/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 1663. Smallest String With A Given Numeric Value
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: String,LeetCode101,Tricky Initialize a string that fills &#39;a&#39; in it. Then we turn it to the expected string from end to start.
The maximal value of each position in the string is 26. If we start from all elements is &#39;a&#39; in the string. Then the represent value of the string is n. If it’s not equal to k. Then we need turn the last character of string to r = k - n....</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-22 16:22:00 +0800 +0800'>March 22, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 1663. Smallest String With A Given Numeric Value" href="https://notes.0081800.xyz/notes/20220322162250-leetcode101_1663_smallest_string_with_a_given_numeric_value/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 12. Integer to Roman
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Math,Hash Table,LeetCode101 class Solution { public: string intToRoman(int num) { vector&lt;string&gt; roman {&#34;M&#34;, &#34;CM&#34;, &#34;D&#34;, &#34;CD&#34;, &#34;C&#34;, &#34;XC&#34;, &#34;L&#34;, &#34;XL&#34;, &#34;X&#34;, &#34;IX&#34;, &#34;V&#34;, &#34;IV&#34;, &#34;I&#34;}; vector&lt;int&gt; integers {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 }; string r; int times = 0; for (int i = 0; i &lt; integers.size(); &#43;&#43;i) { if (num &gt;= integers[i]) { times = num / integers[i]; num -= times * integers[i]; for (int j = times; j &gt; 0; --j) { r....</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-22 15:59:00 +0800 +0800'>March 22, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 12. Integer to Roman" href="https://notes.0081800.xyz/notes/20220322155933-leetcode101_12_integer_to_roman/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 11. Container With Most Water
              </h2>
            </header>
            <div class="entry-content">
              <p> tags: Two Pointers,Tricky,LeetCode101 The key ideas are:
We start from two edges and move to the middle with two pointers. Move the pointer to the middle which side is smaller. class Solution { public: int maxArea(vector&lt;int&gt;&amp; height) { int i = 0, j = height.size() - 1; int water = 0; while (i &lt; j) { water = max(water, (j - i) * min(height[i], height[j])); if (height[i] &gt; height[j]) { --j; } else { &#43;&#43;i; } } return water; } }; </p>
            </div>
            <footer class="entry-footer"><span title='2022-03-21 18:38:00 +0800 +0800'>March 21, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 11. Container With Most Water" href="https://notes.0081800.xyz/notes/20220321183809-leetcode_11_container_with_most_water/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 316. Remove Duplicate Letters
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: String,LeetCode101,Stack,Hash Table,Hash Set I have solved this problem years before, LeetCode: 316.Remove Duplicate Letters, but still stuck on it.
The key idea is not only about stack, but also required a map to record how many same letters behind current one. Which helps us to decide if drop current letter or not, when the new letter is less than the top of stack, which means smaller in lexicographical order....</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-21 17:47:00 +0800 +0800'>March 21, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 316. Remove Duplicate Letters" href="https://notes.0081800.xyz/notes/20220321174725-leetcode101_316_remove_duplicate_letters/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 763. Partition Labels
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: String,LeetCode101,Hash Set,Hash Table,Stack The key idea is similar to LeetCode101: 316. Remove Duplicate Letters, we use a HashMap to track how many letters which is same in the string. Then we use a HashSet to store appeared letters. When there is no more letters appeared in the HashSet, it’s time to partition.
class Solution { public: vector&lt;int&gt; partitionLabels(string s) { unordered_map&lt;char, int&gt; cntOfLetters; unordered_set&lt;char&gt; appearedLetters; vector&lt;int&gt; r; int count = 0; for (auto iter = s....</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-21 17:45:00 +0800 +0800'>March 21, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 763. Partition Labels" href="https://notes.0081800.xyz/notes/20220321174504-leetcode101_763_partition_labels/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 9. Palindrome Number
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: LeetCode101,Math The key idea is:
To use \(log10(10^n) = n\) to get how many digits in the number. Then we need iterate \(n &#43; 1\) times to compare each side. The digit in the left is \(\frac{x}{10^{n-i}} \mod 10\). The digit in the right is \(\frac{x}{10^i} \mod 10\). class Solution { public: bool isPalindrome(int x) { if (x &lt; 0) { return false; } // failed at here if (x &lt; 10) { return true; } int n = log10(x); int ld = pow(10, n); // left div int rd = 1; // right div for (int i = 0; i &lt; (n &#43; 1) / 2; i&#43;&#43;) { // left right if (x / ld % 10 !...</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-18 08:44:00 +0800 +0800'>March 18, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 9. Palindrome Number" href="https://notes.0081800.xyz/notes/20220318084438-leetcode101_9_palindrome_number/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 8. String to Integer (atoi)
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Tricky,LeetCode101,Integer Overflow The key idea is how to detect integer overflow, it’s same to: LeetCode101: 7. Reverse Integer.
class Solution { public: int myAtoi(string s) { auto iter = s.begin(); int base = 1, r = 0, p = 0; // Skip whitespace for (; iter != s.end() &amp;&amp; *iter == &#39; &#39;; &#43;&#43;iter) { } // negative or positive if (*iter == &#39;-&#39; || *iter == &#39;&#43;&#39;) { if (*iter == &#39;-&#39;) { base = -1; } &#43;&#43;iter; } for (; iter !...</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-18 07:23:00 +0800 +0800'>March 18, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 8. String to Integer (atoi)" href="https://notes.0081800.xyz/notes/20220318072345-leetcode101_8_string_to_integer_atoi/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 6. Zigzag Conversion
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Tricky,LeetCode101 Make
R = total required rows d = R - 2 2 is contains head line and tail line that not need insert a character between two columns. r = current row offset, which starts from 0. c = current column offset, which starts from 0. We can use a formula to make columns, which is \(c(R&#43;d)&#43;r\).
For example, &#34;PAYPALISHIRING&#34;, numRows=3:
P A H N A P L S I I G Y I R The columns only the head and tail rows is correct should be:...</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-17 07:33:00 +0800 +0800'>March 17, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 6. Zigzag Conversion" href="https://notes.0081800.xyz/notes/20220317073333-leetcode101_6_zigzag_conversion/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 7. Reverse Integer
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Tricky,Stack,LeetCode101,Integer Overflow The key is how to detect integer overflow without store to a larger size integer.
For this purpose, we could detect integer overflow before carry:
The maximal of INT_MAX before carry is \(\frac{INT\_MAX}{10}\). We continue compare pop with the suffix of INT_MAX, 7, if maximal before carry is equal to \(\frac{INT\_MAX}{10}\).
The minimal of INT_MIN before carry is \(\frac{INT\_MIN}{10}\) too. We continue compare pop with the suffix of INT_MIN, -8, if minimal before carry is equal to \(\frac{INT\_MIN}{10}\)....</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-16 21:53:00 +0800 +0800'>March 16, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 7. Reverse Integer" href="https://notes.0081800.xyz/notes/20220316215304-leetcode101_7_reverse_integer/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 1249. Minimum Remove to Make Valid Parentheses
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Stack,LeetCode101 Stack class Solution { public: string minRemoveToMakeValid(string s) { stack&lt;char&gt; st; char open = &#39;(&#39;, close = &#39;)&#39;; int open_count = 0; string res; // forward to remove unnecessary close parentheses for (auto iter = s.begin(); iter != s.end(); &#43;&#43;iter) { if (*iter == open) { open_count&#43;&#43;; } if (open_count == 0 &amp;&amp; *iter == close) { continue; } if (*iter == close) { open_count--; } st.push(*iter); } int close_count = 0; // backward to remove unnecessary open parentheses while (!...</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-16 08:00:00 +0800 +0800'>March 16, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 1249. Minimum Remove to Make Valid Parentheses" href="https://notes.0081800.xyz/notes/20220316080026-leetcode101_1249_minimum_remove_to_make_valid_parentheses/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 769. Max Chunks To Make Sorted
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Tricky,LeetCode101 original: 0, 2, 1, 4, 3, 5, 7, 6 max: 0, 2, 2, 4, 4, 5, 7, 7 sorted: 0, 1, 2, 3, 4, 5, 6, 7 index: 0, 1, 2, 3, 4, 5, 6, 7
As shown above, the position of break point is same to the position of max value of chunks. So here:
We track chunks’s max value. Break at the position of max value lives in sorted array, which means the index in this case....</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-15 15:21:00 +0800 +0800'>March 15, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 769. Max Chunks To Make Sorted" href="https://notes.0081800.xyz/notes/20220315152142-leetcode101_769_max_chunks_to_make_sorted/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 739. Daily Temperatures
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Monotonic Stack,LeetCode101,LeetCode101: 496. Next Greater Element I Mono-descreasing stack class Solution { public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) { vector&lt;int&gt; res(temperatures.size(), 0); stack&lt;int&gt; st; for (int i = 0; i &lt; temperatures.size(); i&#43;&#43;) { while (!st.empty() &amp;&amp; temperatures[st.top()] &lt; temperatures[i]) { res[st.top()] = i - st.top(); st.pop(); } st.push(i); } return res; } }; [73,74,75,71,69,72,76,73]</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-15 11:23:00 +0800 +0800'>March 15, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 739. Daily Temperatures" href="https://notes.0081800.xyz/notes/20220315112303-leetcode101_739_daily_temperatures/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 654. Maximum Binary Tree
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Monotonic Stack,LeetCode101,Binary Search Tree Mono-descreasing stack Key:
The largest number is the root, that we can observe in by iteration. We must clear the stack to fill the right side of BST after loop. The last popped element is the left of current node. From top to bottom, the top element is the right side of the element that under the top. class Solution { public: TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) { vector&lt;TreeNode*&gt; res(nums....</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-15 10:51:00 +0800 +0800'>March 15, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 654. Maximum Binary Tree" href="https://notes.0081800.xyz/notes/20220315105116-leetcode101_654_maximum_binary_tree/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 581. Shortest Unsorted Continuous Subarray
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Monotonic Stack,LeetCode101 Mono-increasing stack Key:
Some case should move backward as the new value we meeted is larger than it. When we meet 2 in the stack, and here we need move backward. Some case we need move forward, as the following values are the mono-increaing stack: [1, 2, 5, 3, 4] class Solution { public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) { stack&lt;int&gt; st; // mono-increasing int left = -1, right = -2; for (int i = 0; i &lt; nums....</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-15 07:13:00 +0800 +0800'>March 15, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 581. Shortest Unsorted Continuous Subarray" href="https://notes.0081800.xyz/notes/20220315071351-leetcode101_581_shortest_unsorted_continuous_subarray/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 503. Next Greater Element II
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Monotonic Stack,LeetCode101 related: LeetCode101: 496. Next Greater Element I Mono-descreasing stack / normal order loop twice Loop twice to solve circular interger array Mono-descreasing stack to store index, avoid HashMap in Next Greater Element I, as there is a cicular array. class Solution { public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; res(nums.size(), -1); stack&lt;int&gt; st; for (int j = 0, i = 0; j &lt; nums.size() * 2; &#43;&#43;j) { i = j &gt;= nums....</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-15 06:30:00 +0800 +0800'>March 15, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 503. Next Greater Element II" href="https://notes.0081800.xyz/notes/20220315063008-leetcode101_503_next_greater_element_ii/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 496. Next Greater Element I
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Monotonic Stack,Hash Table,LeetCode101 Mono-descreasing and reverse order travel class Solution { public: vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { // Mono-descreasing and reverse order travel. // The next greater of the popped value is the top of the stack, if it has any. // // For example: [1,3,4,2] // the stack goes: // [2] // [4] -&gt; 2 // [4, 3, 1] stack&lt;int&gt; st; vector&lt;int&gt; res; unordered_map&lt;int, int&gt; m; for (int i = nums2....</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-14 08:58:00 +0800 +0800'>March 14, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 496. Next Greater Element I" href="https://notes.0081800.xyz/notes/20220314085847-leetcode101_496_next_greater_element_i/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 402. Remove K Digits
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Monotonic Stack,LeetCode101 Mono-increasing stack and reverse order travel (Not Work) Notes:
We attempt to remove the most large numbers in the left, first, we use the right n numbers to meet the requirements, which is num.length - k and then, using a monotonic increasing stack to keep the result as samller as we can. (A monotonic increasing stack will remove larger elements before pushing.)
Also note that: the result’s length is not actually equal num....</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-14 07:43:00 +0800 +0800'>March 14, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 402. Remove K Digits" href="https://notes.0081800.xyz/notes/20220314074324-leetcode101_402_remove_k_digits/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 456. 132 Pattern
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Monotonic Stack,LeetCode101,Tricky We travel the numbers in the reverse order:
Use a mono-increasing stack to find the largest number(3 in the 132 pattern), the value popped from stack is the second large number(2 in the 132 pattern), if any value less than the second large number, returns true. // Note: // // - subsequence is not contiguous, is i &lt; j &lt; k, not i &#43; 1 = j, j &#43; 1 = k // class Solution { public: bool find132pattern(vector&lt;int&gt;&amp; nums) { int K = INT_MIN; stack&lt;int&gt; mst; // mono-increasing stack for (int i = nums....</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-13 15:32:00 +0800 +0800'>March 13, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 456. 132 Pattern" href="https://notes.0081800.xyz/notes/20220313153222-456_132_pattern/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 219. Contains Duplicate II
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Sliding Window,Hash Table,LeetCode101 This is an “near by” problem that can be solved by Sliding Window. The k in the problem is somehow means contiguous.
And using a HashTable to indicate that two values in the different position are equal.
The steps is following:
Find two values at each side of window are equal. Return true if the offset between their indices is less than or equal k. Otherwise set left to the new position and continue....</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-12 07:37:00 +0800 +0800'>March 12, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 219. Contains Duplicate II" href="https://notes.0081800.xyz/notes/20220312073726-219_contains_duplicate_ii/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 209. Minimum Size Subarray Sum
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Sliding Window,LeetCode101 Key:
sum is greater than or equal to target Compute minimal must above slide left window, as decrease may cause sum less than target. See also 1695. Maximum Erasure Value class Solution { public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { int left = 0; int sum = 0; int minimal = INT_MAX; for (auto right = 0; right &lt; nums.size(); right&#43;&#43;) { sum &#43;= nums[right]; while (sum &gt;= target) { minimal = min(minimal, right - left &#43; 1); sum -= nums[left&#43;&#43;]; } } return minimal == INT_MAX ?...</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-11 22:08:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 209. Minimum Size Subarray Sum" href="https://notes.0081800.xyz/notes/20220311220839-209_minimum_size_subarray_sum/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 187. Repeated DNA Sequences
              </h2>
            </header>
            <div class="entry-content">
              <p> tags: Sliding Window,LeetCode101,Hash Set Key:
Fixed size window, right should start from 9 class Solution { public: vector&lt;string&gt; findRepeatedDnaSequences(string s) { int left = 0; unordered_set&lt;string&gt; results; unordered_set&lt;string&gt; hset; for (auto right = 9; right &lt; s.size(); right&#43;&#43;) { string sub(s, left, 10); if (hset.find(sub) != hset.end()) { results.insert(sub); } hset.insert(sub); left&#43;&#43;; } return vector&lt;string&gt;(results.begin(), results.end()); } }; </p>
            </div>
            <footer class="entry-footer"><span title='2022-03-11 21:30:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 187. Repeated DNA Sequences" href="https://notes.0081800.xyz/notes/20220311213045-187_repeated_dna_sequences/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 1695. Maximum Erasure Value
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Sliding Window,LeetCode101,Hash Set Use HashMap to store indices See also: 3. Longest Substring Without Repeating Characters
class Solution { public: int maximumUniqueSubarray(vector&lt;int&gt;&amp; nums) { int maximum = 0; int left = 0, right = 0; unordered_map&lt;int, int&gt; indices; for (; right &lt; nums.size(); right&#43;&#43;) { int n = nums[right]; if (indices.find(n) != indices.end() &amp;&amp; indices[n] &#43; 1 &gt; left) { left = indices[n] &#43; 1; } maximum = max(maximum, std::accumulate(nums....</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-11 18:38:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 1695. Maximum Erasure Value" href="https://notes.0081800.xyz/notes/20220311183843-1695_maximum_erasure_value/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 3. Longest Substring Without Repeating Characters
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Sliding Window,LeetCode101,Hash Table Use HashMap to store counts of letters Two points we should be noticed:
The length of substring should be (right - left) &#43; 1, as one side must be counted.
We must decrese the number in the counts first, and then slide the left window, or we must decrese the wrong one, please compare between Wrong and Correct.
Wrong
left&#43;&#43;; counts[s[left]]--; Correct
counts[s[left]]--; left&#43;&#43;; The full code see:...</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-11 07:48:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 3. Longest Substring Without Repeating Characters" href="https://notes.0081800.xyz/notes/20220311074801-3_longest_substring_without_repeating_characters/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 445. Add Two Numbers II
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Linked List,Stack, LeetCode101,2. Add Two Numbers 两数之和的进阶版，位高的数字在链表的头部，常规解法是通过「栈」进行反转链表，然后回退到2. Add Two Numbers的解法。</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-11 07:38:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 445. Add Two Numbers II" href="https://notes.0081800.xyz/notes/20220311073810-445_add_two_numbers_ii/"></a>
          </article>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>LeetCode101: 2. Add Two Numbers
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Linked List, LeetCode101 正常的「链表」遍历操作，需要注意的就是不要在末尾忘记处理进位，如果 carry 大于 0 需要追加到结果链表末尾。</p>
            </div>
            <footer class="entry-footer"><span title='2022-03-11 07:07:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to LeetCode101: 2. Add Two Numbers" href="https://notes.0081800.xyz/notes/20220311070727-2_add_two_numbers/"></a>
          </article>
       
     </ul>
    </div>
  </div>


</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://notes.0081800.xyz/">Taking Smart Notes With Org-mode</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
