<!DOCTYPE html>
<html lang="en" dir="auto">

<head>
	<meta name="generator" content="Hugo 0.147.2"><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Taking Smart Notes With Org-mode</title>

<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="https://notes.0081800.xyz/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css" integrity="sha256-IhHKMWS&#43;eDACT2qtKzouUghDpk&#43;PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://notes.0081800.xyz/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://notes.0081800.xyz/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://notes.0081800.xyz/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://notes.0081800.xyz/apple-touch-icon.png">
<link rel="mask-icon" href="https://notes.0081800.xyz/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://notes.0081800.xyz/index.xml">
<link rel="alternate" type="application/json" href="https://notes.0081800.xyz/index.json">
<link rel="alternate" hreflang="en" href="https://notes.0081800.xyz/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://notes.0081800.xyz/">
  <meta property="og:site_name" content="Taking Smart Notes With Org-mode">
  <meta property="og:title" content="Taking Smart Notes With Org-mode">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Taking Smart Notes With Org-mode">
<meta name="twitter:description" content="">

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "Taking Smart Notes With Org-mode",
  "url": "https://notes.0081800.xyz/",
  "description": "",
  "logo": "https://notes.0081800.xyz/favicon.ico",
  "sameAs": [
      
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://notes.0081800.xyz/" accesskey="h" title="Taking Smart Notes With Org-mode (Alt + H)">Taking Smart Notes With Org-mode</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://notes.0081800.xyz/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://notes.0081800.xyz/articles/" title="Articles">
                    <span>Articles</span>
                </a>
            </li>
            <li>
                <a href="https://notes.0081800.xyz/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://notes.0081800.xyz/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101: 11. Container With Most Water
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Two Pointers,Tricky,LeetCode101 The key ideas are:
We start from two edges and move to the middle with two pointers. Move the pointer to the middle which side is smaller. class Solution { public: int maxArea(vector&lt;int&gt;&amp; height) { int i = 0, j = height.size() - 1; int water = 0; while (i &lt; j) { water = max(water, (j - i) * min(height[i], height[j])); if (height[i] &gt; height[j]) { --j; } else { &#43;&#43;i; } } return water; } }; </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-21 18:38:00 +0800 +0800'>March 21, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101: 11. Container With Most Water" href="https://notes.0081800.xyz/notes/20220321183809-leetcode_11_container_with_most_water/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101: 316. Remove Duplicate Letters
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: String,LeetCode101,Stack,Hash Table,Hash Set I have solved this problem years before, LeetCode: 316.Remove Duplicate Letters, but still stuck on it.
The key idea is not only about stack, but also required a map to record how many same letters behind current one. Which helps us to decide if drop current letter or not, when the new letter is less than the top of stack, which means smaller in lexicographical order.
class Solution { public: string removeDuplicateLetters(string s) { vector&lt;int&gt; countOfLetters(26, 0); vector&lt;bool&gt; pickedLetters(26, false); stack&lt;char&gt; st; for (auto iter = s.begin(); iter != s.end(); &#43;&#43;iter) { countOfLetters[*iter - &#39;a&#39;]&#43;&#43;; } for (int i = 0; i &lt; s.size(); &#43;&#43;i) { countOfLetters[s[i] - &#39;a&#39;]--; if (pickedLetters[s[i] - &#39;a&#39;]) { continue; } while (!st.empty() &amp;&amp; s[i] &lt; st.top() &amp;&amp; countOfLetters[st.top() - &#39;a&#39;] &gt; 0) { pickedLetters[st.top() - &#39;a&#39;] = false; st.pop(); } st.push(s[i]); pickedLetters[s[i] - &#39;a&#39;] = true; } string r; while (!st.empty()) { r.push_back(st.top()); st.pop(); } reverse(r.begin(), r.end()); return r; } }; </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-21 17:47:00 +0800 +0800'>March 21, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101: 316. Remove Duplicate Letters" href="https://notes.0081800.xyz/notes/20220321174725-leetcode101_316_remove_duplicate_letters/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101: 763. Partition Labels
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: String,LeetCode101,Hash Set,Hash Table,Stack The key idea is similar to LeetCode101: 316. Remove Duplicate Letters, we use a HashMap to track how many letters which is same in the string. Then we use a HashSet to store appeared letters. When there is no more letters appeared in the HashSet, it’s time to partition.
class Solution { public: vector&lt;int&gt; partitionLabels(string s) { unordered_map&lt;char, int&gt; cntOfLetters; unordered_set&lt;char&gt; appearedLetters; vector&lt;int&gt; r; int count = 0; for (auto iter = s.begin(); iter != s.end(); &#43;&#43;iter) { cntOfLetters[*iter]&#43;&#43;; } for (auto iter = s.begin(); iter != s.end(); &#43;&#43;iter) { appearedLetters.insert(*iter); cntOfLetters[*iter]--; count&#43;&#43;; // Append current count to result if there is no appeared letters // behind. bool behind = false; for (auto si = appearedLetters.begin(); si != appearedLetters.end(); &#43;&#43;si) { if (cntOfLetters[*si]){ behind = true; break; } } if (!behind) { r.push_back(count); count = 0; } } if (count &gt; 1) { r.push_back(count); } return r; } }; </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-21 17:45:00 +0800 +0800'>March 21, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101: 763. Partition Labels" href="https://notes.0081800.xyz/notes/20220321174504-leetcode101_763_partition_labels/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">String
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Algorithm </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-21 17:45:00 +0800 +0800'>March 21, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to String" href="https://notes.0081800.xyz/notes/20220321174510-string/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101: 9. Palindrome Number
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: LeetCode101,Math The key idea is:
To use \(log10(10^n) = n\) to get how many digits in the number. Then we need iterate \(n &#43; 1\) times to compare each side. The digit in the left is \(\frac{x}{10^{n-i}} \mod 10\). The digit in the right is \(\frac{x}{10^i} \mod 10\). class Solution { public: bool isPalindrome(int x) { if (x &lt; 0) { return false; } // failed at here if (x &lt; 10) { return true; } int n = log10(x); int ld = pow(10, n); // left div int rd = 1; // right div for (int i = 0; i &lt; (n &#43; 1) / 2; i&#43;&#43;) { // left right if (x / ld % 10 != x / rd % 10) { return false; } ld /= 10; rd *= 10; } return true; } }; </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-18 08:44:00 +0800 +0800'>March 18, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101: 9. Palindrome Number" href="https://notes.0081800.xyz/notes/20220318084438-leetcode101_9_palindrome_number/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Math
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Algorithm </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-18 08:44:00 +0800 +0800'>March 18, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Math" href="https://notes.0081800.xyz/notes/20220318084456-math/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Integer Overflow
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: C/C&#43;&#43; In some problems, we need to detect is our result overflow in a 32-bit integer. The key ideas is check our value before it becomes bigger.
For example:
// INT_MAX 2147483647 // INT_MIN -2147483648 // INT_MAX&#39;s suffix is 7 if (res &gt; INT_MAX / 10 || (res == INT_MAX / 10 &amp;&amp; pop &gt; 7)) { return 0; } // INT_MIN&#39;s suffix is -8 if (res &lt; INT_MIN / 10 || (res == INT_MIN / 10 &amp;&amp; pop &lt; -8)) { return 0; } res = res * 10 &#43; pop; Our final result need a 10 times current value and plus a value, then we check:
...</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-18 07:24:00 +0800 +0800'>March 18, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Integer Overflow" href="https://notes.0081800.xyz/notes/20220318072424-integer_overflow/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101: 8. String to Integer (atoi)
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Tricky,LeetCode101,Integer Overflow The key idea is how to detect integer overflow, it’s same to: LeetCode101: 7. Reverse Integer.
class Solution { public: int myAtoi(string s) { auto iter = s.begin(); int base = 1, r = 0, p = 0; // Skip whitespace for (; iter != s.end() &amp;&amp; *iter == &#39; &#39;; &#43;&#43;iter) { } // negative or positive if (*iter == &#39;-&#39; || *iter == &#39;&#43;&#39;) { if (*iter == &#39;-&#39;) { base = -1; } &#43;&#43;iter; } for (; iter != s.end(); &#43;&#43;iter) { // failed at here: the logic between conditions is OR not AND if (*iter &gt; &#39;9&#39; || *iter &lt; &#39;0&#39;) { break; } p = (*iter - &#39;0&#39;) * base; // 7 is the INX_MAX&#39;s suffix, remember? if (r &gt; INT_MAX / 10 || (r == INT_MAX / 10 &amp;&amp; p &gt; 7)) { return INT_MAX; } // 8 is the INT_MIN&#39;s suffix, too. if (r &lt; INT_MIN / 10 || (r == INT_MIN / 10 &amp;&amp; p &lt; -8)) { return INT_MIN; } r = r * 10 &#43; p; } return r; } }; </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-18 07:23:00 +0800 +0800'>March 18, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101: 8. String to Integer (atoi)" href="https://notes.0081800.xyz/notes/20220318072345-leetcode101_8_string_to_integer_atoi/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101: 6. Zigzag Conversion
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Tricky,LeetCode101 Make
R = total required rows d = R - 2 2 is contains head line and tail line that not need insert a character between two columns. r = current row offset, which starts from 0. c = current column offset, which starts from 0. We can use a formula to make columns, which is \(c(R&#43;d)&#43;r\).
For example, &#34;PAYPALISHIRING&#34;, numRows=3:
P A H N A P L S I I G Y I R The columns only the head and tail rows is correct should be:
...</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-17 07:33:00 +0800 +0800'>March 17, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101: 6. Zigzag Conversion" href="https://notes.0081800.xyz/notes/20220317073333-leetcode101_6_zigzag_conversion/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101: 7. Reverse Integer
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Tricky,Stack,LeetCode101,Integer Overflow The key is how to detect integer overflow without store to a larger size integer.
For this purpose, we could detect integer overflow before carry:
The maximal of INT_MAX before carry is \(\frac{INT\_MAX}{10}\). We continue compare pop with the suffix of INT_MAX, 7, if maximal before carry is equal to \(\frac{INT\_MAX}{10}\).
The minimal of INT_MIN before carry is \(\frac{INT\_MIN}{10}\) too. We continue compare pop with the suffix of INT_MIN, -8, if minimal before carry is equal to \(\frac{INT\_MIN}{10}\).
...</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-16 21:53:00 +0800 +0800'>March 16, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101: 7. Reverse Integer" href="https://notes.0081800.xyz/notes/20220316215304-leetcode101_7_reverse_integer/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101: 946. Validate Stack Sequences
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Stack Intuition for (int i = 0; i &lt; pushed.size(); i&#43;&#43;) { if (pushed[i] != popped[pushed.size() - 1 - i]) { return false; } } But the pop/push operations can happend in any sequence.
Stack Using a stack. Returns false, IF the next value neither the popped nor pushed.
In each sequence we must do a operation: push or pop. When to push:
stack is empty, or top of stack is not current popped value When to pop:
...</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-16 08:52:00 +0800 +0800'>March 16, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101: 946. Validate Stack Sequences" href="https://notes.0081800.xyz/notes/20220316085247-leetcode101_946_validate_stack_sequences/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101: 1249. Minimum Remove to Make Valid Parentheses
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Stack,LeetCode101 Stack class Solution { public: string minRemoveToMakeValid(string s) { stack&lt;char&gt; st; char open = &#39;(&#39;, close = &#39;)&#39;; int open_count = 0; string res; // forward to remove unnecessary close parentheses for (auto iter = s.begin(); iter != s.end(); &#43;&#43;iter) { if (*iter == open) { open_count&#43;&#43;; } if (open_count == 0 &amp;&amp; *iter == close) { continue; } if (*iter == close) { open_count--; } st.push(*iter); } int close_count = 0; // backward to remove unnecessary open parentheses while (!st.empty()) { if (st.top() == close) { close_count&#43;&#43;; } if (st.top() == open) { if (close_count == 0 ) { st.pop(); continue; } close_count--; } res.push_back(st.top()); st.pop(); } reverse(res.begin(), res.end()); return res; } }; </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-16 08:00:00 +0800 +0800'>March 16, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101: 1249. Minimum Remove to Make Valid Parentheses" href="https://notes.0081800.xyz/notes/20220316080026-leetcode101_1249_minimum_remove_to_make_valid_parentheses/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101: 769. Max Chunks To Make Sorted
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Tricky,LeetCode101 original: 0, 2, 1, 4, 3, 5, 7, 6 max: 0, 2, 2, 4, 4, 5, 7, 7 sorted: 0, 1, 2, 3, 4, 5, 6, 7 index: 0, 1, 2, 3, 4, 5, 6, 7
As shown above, the position of break point is same to the position of max value of chunks. So here:
...</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-15 15:21:00 +0800 +0800'>March 15, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101: 769. Max Chunks To Make Sorted" href="https://notes.0081800.xyz/notes/20220315152142-leetcode101_769_max_chunks_to_make_sorted/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Tricky
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Algorithm </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-15 15:21:00 +0800 +0800'>March 15, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Tricky" href="https://notes.0081800.xyz/notes/20220315152159-tricky/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101: 739. Daily Temperatures
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Monotonic Stack,LeetCode101,LeetCode101: 496. Next Greater Element I Mono-descreasing stack class Solution { public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) { vector&lt;int&gt; res(temperatures.size(), 0); stack&lt;int&gt; st; for (int i = 0; i &lt; temperatures.size(); i&#43;&#43;) { while (!st.empty() &amp;&amp; temperatures[st.top()] &lt; temperatures[i]) { res[st.top()] = i - st.top(); st.pop(); } st.push(i); } return res; } }; [73,74,75,71,69,72,76,73]
</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-15 11:23:00 +0800 +0800'>March 15, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101: 739. Daily Temperatures" href="https://notes.0081800.xyz/notes/20220315112303-leetcode101_739_daily_temperatures/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101: 654. Maximum Binary Tree
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Monotonic Stack,LeetCode101,Binary Search Tree Mono-descreasing stack Key:
The largest number is the root, that we can observe in by iteration. We must clear the stack to fill the right side of BST after loop. The last popped element is the left of current node. From top to bottom, the top element is the right side of the element that under the top. class Solution { public: TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) { vector&lt;TreeNode*&gt; res(nums.size(), nullptr); stack&lt;int&gt; st; // mono-descreasing stack, remove smaller elements before pushing. TreeNode* root = nullptr; for (int i = 0;i &lt; nums.size(); i&#43;&#43;) { res[i] = new TreeNode(nums[i]); while (!st.empty() &amp;&amp; nums[st.top()] &lt; nums[i]) { int j = st.top(); st.pop(); if (!st.empty() &amp;&amp; nums[st.top()] &lt; nums[i]) { res[st.top()]-&gt;right = res[j]; } else { res[i]-&gt;left = res[j]; } } if (root == nullptr || res[i]-&gt;val &gt; root-&gt;val) { root = res[i]; } st.push(i); } while (st.size() &gt; 1) { int j = st.top(); st.pop(); res[st.top()]-&gt;right = res[j]; } return root; } }; </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-15 10:51:00 +0800 +0800'>March 15, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101: 654. Maximum Binary Tree" href="https://notes.0081800.xyz/notes/20220315105116-leetcode101_654_maximum_binary_tree/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101: 581. Shortest Unsorted Continuous Subarray
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Monotonic Stack,LeetCode101 Mono-increasing stack Key:
Some case should move backward as the new value we meeted is larger than it. When we meet 2 in the stack, and here we need move backward. Some case we need move forward, as the following values are the mono-increaing stack: [1, 2, 5, 3, 4] class Solution { public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) { stack&lt;int&gt; st; // mono-increasing int left = -1, right = -2; for (int i = 0; i &lt; nums.size(); i&#43;&#43;) { while (!st.empty() &amp;&amp; nums[st.top()] &gt; nums[i]) { // move backward if (left == -1 || st.top() &lt; left) { left = st.top(); // left should be the previous index } // move forward for (int j = i; j &lt; nums.size() &amp;&amp; nums[j] &lt; nums[st.top()]; j&#43;&#43;) { if (j &gt; right) { right = j; } } st.pop(); } st.push(i); } return (right - left) &#43; 1; } }; Failed test cases [2,6,4,8,10,9,15] [1, 2, 3, 4] [1] [2,1] [1,3,2,2,2] [1,2,3,3,3] [2,3,3,2,4] [1,2,5,3,4] [1,3,5,2,4] </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-15 07:13:00 +0800 +0800'>March 15, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101: 581. Shortest Unsorted Continuous Subarray" href="https://notes.0081800.xyz/notes/20220315071351-leetcode101_581_shortest_unsorted_continuous_subarray/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101: 503. Next Greater Element II
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Monotonic Stack,LeetCode101 related: LeetCode101: 496. Next Greater Element I Mono-descreasing stack / normal order loop twice Loop twice to solve circular interger array Mono-descreasing stack to store index, avoid HashMap in Next Greater Element I, as there is a cicular array. class Solution { public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; res(nums.size(), -1); stack&lt;int&gt; st; for (int j = 0, i = 0; j &lt; nums.size() * 2; &#43;&#43;j) { i = j &gt;= nums.size() ? j - nums.size() : j; while (!st.empty() &amp;&amp; nums[st.top()] &lt; nums[i]) { res[st.top()] = nums[i]; st.pop(); } st.push(i); } return res; } }; </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-15 06:30:00 +0800 +0800'>March 15, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101: 503. Next Greater Element II" href="https://notes.0081800.xyz/notes/20220315063008-leetcode101_503_next_greater_element_ii/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101: 496. Next Greater Element I
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Monotonic Stack,Hash Table,LeetCode101 Mono-descreasing and reverse order travel class Solution { public: vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { // Mono-descreasing and reverse order travel. // The next greater of the popped value is the top of the stack, if it has any. // // For example: [1,3,4,2] // the stack goes: // [2] // [4] -&gt; 2 // [4, 3, 1] stack&lt;int&gt; st; vector&lt;int&gt; res; unordered_map&lt;int, int&gt; m; for (int i = nums2.size() - 1; i &gt;= 0; i--) { while (!st.empty() &amp;&amp; st.top() &lt; nums2[i]) { int c = st.top(); st.pop(); if (!st.empty()) { m[c] = st.top(); } } st.push(nums2[i]); } while (st.size() &gt; 1) { int c = st.top(); st.pop(); m[c] = st.top(); } for (int i = 0; i &lt; nums1.size(); i&#43;&#43;) { if (m.find(nums1[i]) != m.end()) { res.push_back(m[nums1[i]]); } else { res.push_back(-1); } } return res; } }; /* [1,3,5,2,4] [6,5,4,3,2,1,7] The stack goes: [7, 1] [7, 2] -&gt; 1 and 1 is next greater is the top of the stack */ </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-14 08:58:00 +0800 +0800'>March 14, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101: 496. Next Greater Element I" href="https://notes.0081800.xyz/notes/20220314085847-leetcode101_496_next_greater_element_i/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101: 402. Remove K Digits
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Monotonic Stack,LeetCode101 Mono-increasing stack and reverse order travel (Not Work) Notes:
We attempt to remove the most large numbers in the left, first, we use the right n numbers to meet the requirements, which is num.length - k and then, using a monotonic increasing stack to keep the result as samller as we can. (A monotonic increasing stack will remove larger elements before pushing.)
Also note that: the result’s length is not actually equal num.length - k, it’s less than or equal num.length - k, like num = “10200”, k = 1. Which means the result in stack could be longer than the required or leading ‘0’.
...</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-14 07:43:00 +0800 +0800'>March 14, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101: 402. Remove K Digits" href="https://notes.0081800.xyz/notes/20220314074324-leetcode101_402_remove_k_digits/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101: 456. 132 Pattern
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Monotonic Stack,LeetCode101,Tricky We travel the numbers in the reverse order:
Use a mono-increasing stack to find the largest number(3 in the 132 pattern), the value popped from stack is the second large number(2 in the 132 pattern), if any value less than the second large number, returns true. // Note: // // - subsequence is not contiguous, is i &lt; j &lt; k, not i &#43; 1 = j, j &#43; 1 = k // class Solution { public: bool find132pattern(vector&lt;int&gt;&amp; nums) { int K = INT_MIN; stack&lt;int&gt; mst; // mono-increasing stack for (int i = nums.size() - 1; i &gt;= 0; i--) { if (nums[i] &lt; K) { return true; } while (!mst.empty() &amp;&amp; mst.top() &lt; nums[i]) { K = mst.top(); mst.pop(); } mst.push(nums[i]); } return false; } }; </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-13 15:32:00 +0800 +0800'>March 13, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101: 456. 132 Pattern" href="https://notes.0081800.xyz/notes/20220313153222-456_132_pattern/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Monotonic Stack
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Data Structures,Stack source: “Monotonic Stack.” Accessed March 13, 2022. https://liuzhenglaichn.gitbook.io/algorithm/monotonic-stack. A monotonic stack is a stack whose elements are monotonically increasing or descreasing.
It’s not only about the order in the stack, it’s also about remove larger/smaller elements before pushing.
Monotonically descreasing we need to pop smaller elements from the stack before pushing a new element:
vector&lt;int&gt; nums; // fill nums stack&lt;int&gt; st; for (auto i = nums.size() - 1; i &gt;= 0; i--) { while (!st.empty() &amp;&amp; st.top() &gt; nums[i]) { st.pop(); } st.push(nums[i]) } To push 3 to [5, 4, 2, 1], we need pop 2, 1 out first. Then the stack become [5, 4, 3] Monotonically increasing vice versa.
...</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-13 14:51:00 +0800 +0800'>March 13, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Monotonic Stack" href="https://notes.0081800.xyz/notes/20220313145125-monotonic_stack/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">AVL Tree
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Binary Search Tree,Binary Tree,Tree </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-12 21:53:00 +0800 +0800'>March 12, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to AVL Tree" href="https://notes.0081800.xyz/notes/20220312215308-avl_tree/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Binary Search Tree
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Data Structures,Binary Tree,Tree </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-12 21:51:00 +0800 +0800'>March 12, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Binary Search Tree" href="https://notes.0081800.xyz/notes/20220312215158-binary_search_tree/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Red-Black Tree
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Binary Search Tree, AVL Tree,Tree </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-12 21:51:00 +0800 +0800'>March 12, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Red-Black Tree" href="https://notes.0081800.xyz/notes/20220312215140-red_black_tree/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">set vs unordered_set in C&#43;&#43; STL
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: C/C&#43;&#43; source: GeeksforGeeks. “Set vs Unordered_set in C&#43;&#43; STL,” May 28, 2018. https://www.geeksforgeeks.org/set-vs-unordered_set-c-stl/. set Ordered set that implemented by a “Self balancing BST” like Red-Black Tree.
Extra find operations equal_range returns range of elements matching a specific key lower_bound returns an iterator to the first element not less than the given key upper_bound returns an iterator to the first element greater than the given key #include &lt;iostream&gt; #include &lt;set&gt; #include &lt;assert.h&gt; using namespace std; int main(void) { set&lt;int&gt; hset; hset.insert(5); hset.insert(8); hset.insert(13); { // Lower bound equal or greater than auto iter = hset.lower_bound(5); assert(*iter == 5); // 5&#39;s lower bound is 5 itself in the set } { // Upper bound greater than 5 auto iter = hset.upper_bound(5); assert(*iter == 8); // 5&#39;s upper bound is the first value greater than itself } } unordered_set Set that implemented by Hash Table.
...</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-12 21:50:00 +0800 +0800'>March 12, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to set vs unordered_set in C&#43;&#43; STL" href="https://notes.0081800.xyz/notes/20220312215003-set_vs_unordered_set_in_c_stl/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">OrderedSet
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: C/C&#43;&#43;,Java,Data Structures In C&#43;&#43; the set container is an ordered or sorted set, unordered_set is the normal set in C&#43;&#43;. Differences between them please check set vs unordered_set in C&#43;&#43; STL.
In Java there is an java.util.SortedSet interface.
</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-12 21:37:00 +0800 +0800'>March 12, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to OrderedSet" href="https://notes.0081800.xyz/notes/20220312213701-orderedset/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101: 220. Contains Duplicate III
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Sliding Window,OrderedSet Use HashSet to attempt to meet the requirements in the window class Solution { public: bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) { auto left = 0; auto K = 0; set&lt;long&gt; hset; // set in cpp is an sorted set for (auto right = 0; right &lt; nums.size(); right&#43;&#43;) { K = right - left; if (K &gt; k) { hset.erase(nums[left]); left&#43;&#43;; } hset.insert(nums[right]); // some numbers are the same. if (hset.size() &lt; (right - left &#43; 1)) { return true; } // abs less than or equal t auto prev = hset.begin(); for (auto iter = hset.begin(); iter != hset.end(); iter&#43;&#43;) { if (iter != prev &amp;&amp; abs(*prev - *iter) &lt;= t) { return true; } prev = iter; } } return false; } }; // 1. find previous value that meet the requirement, which is abs(nums[i] - nums[j]) &lt;= t // 2. See if also meet the requirement, which is abs(i - j) &lt;= k, otherwise slide left // // Use a fixed window, which size is ~k~. And maintain a set of numbers in the window. // To check if there numbers meet the requirement. It’s too slow and got “Time Limit Exceeded”: https://leetcode.com/submissions/detail/658425251/testcase/. In this case the t is 0, so we can avoid the embed for loop with a if condition:
...</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-12 21:22:00 +0800 +0800'>March 12, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101: 220. Contains Duplicate III" href="https://notes.0081800.xyz/notes/20220312212227-leetcode101_220_contains_duplicate_iii/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101: 219. Contains Duplicate II
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Sliding Window,Hash Table,LeetCode101 This is an “near by” problem that can be solved by Sliding Window. The k in the problem is somehow means contiguous.
And using a HashTable to indicate that two values in the different position are equal.
The steps is following:
Find two values at each side of window are equal. Return true if the offset between their indices is less than or equal k. Otherwise set left to the new position and continue. class Solution { public: bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) { int left = 0; unordered_map&lt;int, int&gt; indices; for (auto right = 0; right &lt; nums.size(); right&#43;&#43;) { auto iter = indices.find(nums[right]); if (iter != indices.end()) { if (abs(right - iter-&gt;second) &lt;= k) { return true; } left = iter-&gt;second &#43; 1; } indices[nums[right]] = right; } return false; } }; </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-12 07:37:00 +0800 +0800'>March 12, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101: 219. Contains Duplicate II" href="https://notes.0081800.xyz/notes/20220312073726-219_contains_duplicate_ii/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Hash Table
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Data Structures </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-11 22:16:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Hash Table" href="https://notes.0081800.xyz/notes/20220311221617-hash_table/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101: 209. Minimum Size Subarray Sum
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Sliding Window,LeetCode101 Key:
sum is greater than or equal to target Compute minimal must above slide left window, as decrease may cause sum less than target. See also 1695. Maximum Erasure Value class Solution { public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { int left = 0; int sum = 0; int minimal = INT_MAX; for (auto right = 0; right &lt; nums.size(); right&#43;&#43;) { sum &#43;= nums[right]; while (sum &gt;= target) { minimal = min(minimal, right - left &#43; 1); sum -= nums[left&#43;&#43;]; } } return minimal == INT_MAX ? 0 : minimal; } }; </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-11 22:08:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101: 209. Minimum Size Subarray Sum" href="https://notes.0081800.xyz/notes/20220311220839-209_minimum_size_subarray_sum/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">187. Repeated DNA Sequences
    </h2>
  </header>
  <div class="entry-content">
    <p></p>
  </div>
  <footer class="entry-footer"><span title='2022-03-11 21:30:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;0 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to 187. Repeated DNA Sequences" href="https://notes.0081800.xyz/notes/20220311213000-187_repeated_dna_sequences/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101: 187. Repeated DNA Sequences
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Sliding Window,LeetCode101,Hash Set Key:
Fixed size window, right should start from 9 class Solution { public: vector&lt;string&gt; findRepeatedDnaSequences(string s) { int left = 0; unordered_set&lt;string&gt; results; unordered_set&lt;string&gt; hset; for (auto right = 9; right &lt; s.size(); right&#43;&#43;) { string sub(s, left, 10); if (hset.find(sub) != hset.end()) { results.insert(sub); } hset.insert(sub); left&#43;&#43;; } return vector&lt;string&gt;(results.begin(), results.end()); } }; </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-11 21:30:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101: 187. Repeated DNA Sequences" href="https://notes.0081800.xyz/notes/20220311213045-187_repeated_dna_sequences/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Hash Set
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Data Structures </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-11 18:39:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Hash Set" href="https://notes.0081800.xyz/notes/20220311183913-hash_set/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101: 1695. Maximum Erasure Value
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Sliding Window,LeetCode101,Hash Set Use HashMap to store indices See also: 3. Longest Substring Without Repeating Characters
class Solution { public: int maximumUniqueSubarray(vector&lt;int&gt;&amp; nums) { int maximum = 0; int left = 0, right = 0; unordered_map&lt;int, int&gt; indices; for (; right &lt; nums.size(); right&#43;&#43;) { int n = nums[right]; if (indices.find(n) != indices.end() &amp;&amp; indices[n] &#43; 1 &gt; left) { left = indices[n] &#43; 1; } maximum = max(maximum, std::accumulate(nums.begin() &#43; left, nums.begin() &#43; right &#43; 1, 0)); indices[n] = right; } return maximum; } }; It is too slow, as there is a \(O(n^2)\) time complexity(std::accmulate is the embed \(O(n)\) ).
...</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-11 18:38:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101: 1695. Maximum Erasure Value" href="https://notes.0081800.xyz/notes/20220311183843-1695_maximum_erasure_value/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">An Introduction to Sliding Window Algorithms
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Sliding Window source: Moore, Jordan. “An Introduction to Sliding Window Algorithms.” Medium, July 26, 2020. https://levelup.gitconnected.com/an-introduction-to-sliding-window-algorithms-5533c4fe1cc7. Efficientive algorithm:
Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away. – Antoine de Saint-Exupéry
The following return values can use a sliding window:
Minimum value Maximum value Longest value Shortest value K-sized value And contiguous is one of the biggest clues.
Common data structures are strings, arrays and even linked lists.
...</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-11 08:38:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to An Introduction to Sliding Window Algorithms" href="https://notes.0081800.xyz/notes/20220311083843-an_introduction_to_sliding_window_algorithms/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Window Sliding Technique
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Sliding Window,Brute Force Approach source: GeeksforGeeks. “Window Sliding Technique,” April 16, 2017. https://www.geeksforgeeks.org/window-sliding-technique/. Use a Sliding Window to instead Brute Force Approach, improve time complexity big O from \(O(n^2)\) to \(O(n)\).
</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-11 08:16:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Window Sliding Technique" href="https://notes.0081800.xyz/notes/20220311081613-window_sliding_technique/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Brute Force Approach
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Algorithm </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-11 08:15:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Brute Force Approach" href="https://notes.0081800.xyz/notes/20220311081528-brute_force_approach/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Two Pointers
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Algorithm </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-11 07:54:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Two Pointers" href="https://notes.0081800.xyz/notes/20220311075423-two_pointer/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Differences between Sliding Window and Two Pointers
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Sliding Window,Two Pointers source: 力扣 LeetCode. “题解：借这个问题科普一下「滑动窗口」和「双指针」的区别 - 力扣（LeetCode）.” Accessed March 11, 2022. https://leetcode-cn.com/problems/get-equal-substrings-within-budget/solution/jie-zhe-ge-wen-ti-ke-pu-yi-xia-hua-dong-6128z/. https://stackoverflow.com/a/64078338 Two Pointer to slove the problem of two elements that two pointes pointed.
Sliding Window to slove the problem of all elements that in the window.
</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-11 07:53:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Differences between Sliding Window and Two Pointers" href="https://notes.0081800.xyz/notes/20220311075357-differences_between_sliding_window_and_two_pointer/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101: 3. Longest Substring Without Repeating Characters
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Sliding Window,LeetCode101,Hash Table Use HashMap to store counts of letters Two points we should be noticed:
The length of substring should be (right - left) &#43; 1, as one side must be counted.
We must decrese the number in the counts first, and then slide the left window, or we must decrese the wrong one, please compare between Wrong and Correct.
Wrong
left&#43;&#43;; counts[s[left]]--; Correct
counts[s[left]]--; left&#43;&#43;; The full code see:
...</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-11 07:48:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101: 3. Longest Substring Without Repeating Characters" href="https://notes.0081800.xyz/notes/20220311074801-3_longest_substring_without_repeating_characters/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Sliding Window
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Algorithm Slide right to move forward to find the solution. Slide left to keep the solution, and collect to the results. Must avoid left go to backward. </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-11 07:48:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Sliding Window" href="https://notes.0081800.xyz/notes/20220311074820-sliding_window/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">445. Add Two Numbers II
    </h2>
  </header>
  <div class="entry-content">
    <p></p>
  </div>
  <footer class="entry-footer"><span title='2022-03-11 07:38:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;0 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to 445. Add Two Numbers II" href="https://notes.0081800.xyz/notes/20220311073803-445_add_two_numbers_ii/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101: 445. Add Two Numbers II
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Linked List,Stack, LeetCode101,2. Add Two Numbers 两数之和的进阶版，位高的数字在链表的头部，常规解法是通过「栈」进行反转链表，然后回退到2. Add Two Numbers的解法。
</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-11 07:38:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101: 445. Add Two Numbers II" href="https://notes.0081800.xyz/notes/20220311073810-445_add_two_numbers_ii/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Stack
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Data Structures </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-11 07:38:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Stack" href="https://notes.0081800.xyz/notes/20220311073821-stack/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Linked List
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Data Structures </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-11 07:08:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Linked List" href="https://notes.0081800.xyz/notes/20220311070813-linked_list/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101: 2. Add Two Numbers
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Linked List, LeetCode101 正常的「链表」遍历操作，需要注意的就是不要在末尾忘记处理进位，如果 carry 大于 0 需要追加到结果链表末尾。
</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-11 07:07:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101: 2. Add Two Numbers" href="https://notes.0081800.xyz/notes/20220311070727-2_add_two_numbers/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Linked List
    </h2>
  </header>
  <div class="entry-content">
    <p></p>
  </div>
  <footer class="entry-footer"><span title='2022-03-11 07:07:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;0 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to Linked List" href="https://notes.0081800.xyz/notes/20220311070749-linked_list/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LeetCode101
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Algorithm,Data Structures 又要开始找工作了，刷题、刷题、刷题！步骤：
按顺序找到题目 解题/学习 总结考察的点（树、双指针、回溯、DP、模拟现实、递归） 刷相同解法框架的题 一些模糊的感觉：
尝试不同的遍历顺序可能是解题关键，正序遍历不行试一下反序遍历，反之亦然！ 以上到达一定量之后在 LeetCode 创建一个新的 session 重新刷起。
</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-11 06:51:00 +0800 +0800'>March 11, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to LeetCode101" href="https://notes.0081800.xyz/notes/20220311065137-leetcode101/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">fork() is evil; vfork() is goodness; afork() would be better; clone() is stupid
    </h2>
  </header>
  <div class="entry-content">
    <p> tags: Computer Systems,Linux source: 262588213843476. “Fork() Is Evil; Vfork() Is Goodness; Afork() Would Be Better; Clone() Is Stupid.” Gist. Accessed March 2, 2022. https://gist.github.com/nicowilliams/a8a07b0fc75df05f684c23c18d7db234. </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-02 11:40:00 +0800 +0800'>March 2, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
  <a class="entry-link" aria-label="post link to fork() is evil; vfork() is goodness; afork() would be better; clone() is stupid" href="https://notes.0081800.xyz/notes/20220302114010-fork_is_evil_vfork_is_goodness_afork_would_be_better_clone_is_stupid/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://notes.0081800.xyz/page/5/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://notes.0081800.xyz/page/7/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://notes.0081800.xyz/">Taking Smart Notes With Org-mode</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
