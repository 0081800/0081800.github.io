<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>How is a Block Executed | Taking Smart Notes With Org-mode</title>
<meta name="keywords" content="">
<meta name="description" content="tags: Starcoin Web3 StarTrek,Move When I start learning Move and looking at the stdlib starcoin-framework and starcoin-framework-commons. Then I realized there are must some magic during the block execution in runtime. To roll the world, the runtime should provide some built in types and call some function in the stdlib.
How does StarcoinVM Validate Transactions? As a miner, it&rsquo;s responsible for executing block, it follows:
Received some transactions from P2P network: EventHandler of PeerTransactionsMessage.">
<meta name="author" content="Gray King">
<link rel="canonical" href="https://notes.0081800.xyz/notes/20220624172625-how_a_block_is_executed/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://notes.0081800.xyz/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://notes.0081800.xyz/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://notes.0081800.xyz/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://notes.0081800.xyz/apple-touch-icon.png">
<link rel="mask-icon" href="https://notes.0081800.xyz/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="How is a Block Executed" />
<meta property="og:description" content="tags: Starcoin Web3 StarTrek,Move When I start learning Move and looking at the stdlib starcoin-framework and starcoin-framework-commons. Then I realized there are must some magic during the block execution in runtime. To roll the world, the runtime should provide some built in types and call some function in the stdlib.
How does StarcoinVM Validate Transactions? As a miner, it&rsquo;s responsible for executing block, it follows:
Received some transactions from P2P network: EventHandler of PeerTransactionsMessage." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://notes.0081800.xyz/notes/20220624172625-how_a_block_is_executed/" /><meta property="article:section" content="notes" />
<meta property="article:published_time" content="2022-06-24T17:26:00+08:00" />
<meta property="article:modified_time" content="2022-06-24T17:26:00+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="How is a Block Executed"/>
<meta name="twitter:description" content="tags: Starcoin Web3 StarTrek,Move When I start learning Move and looking at the stdlib starcoin-framework and starcoin-framework-commons. Then I realized there are must some magic during the block execution in runtime. To roll the world, the runtime should provide some built in types and call some function in the stdlib.
How does StarcoinVM Validate Transactions? As a miner, it&rsquo;s responsible for executing block, it follows:
Received some transactions from P2P network: EventHandler of PeerTransactionsMessage."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://notes.0081800.xyz/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "How is a Block Executed",
      "item": "https://notes.0081800.xyz/notes/20220624172625-how_a_block_is_executed/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "How is a Block Executed",
  "name": "How is a Block Executed",
  "description": "tags: Starcoin Web3 StarTrek,Move When I start learning Move and looking at the stdlib starcoin-framework and starcoin-framework-commons. Then I realized there are must some magic during the block execution in runtime. To roll the world, the runtime should provide some built in types and call some function in the stdlib.\nHow does StarcoinVM Validate Transactions? As a miner, it\u0026rsquo;s responsible for executing block, it follows:\nReceived some transactions from P2P network: EventHandler of PeerTransactionsMessage.",
  "keywords": [
    
  ],
  "articleBody": " tags: Starcoin Web3 StarTrek,Move When I start learning Move and looking at the stdlib starcoin-framework and starcoin-framework-commons. Then I realized there are must some magic during the block execution in runtime. To roll the world, the runtime should provide some built in types and call some function in the stdlib.\nHow does StarcoinVM Validate Transactions? As a miner, it’s responsible for executing block, it follows:\nReceived some transactions from P2P network: EventHandler of PeerTransactionsMessage.\nImport transactions into transactions pool as pending transactions: txpool::pool::queue::TransactionQueue::import\nDuring importing, it’ll verify those transactions by calling verify_transaction.\nRetrieve pending transactions and put it into the a block prepare to execute.\nIn the step 2, the miner need to verify the received transactions before put it into queue as pending transactions.\nThe actually verify logic are defined at StarcoinVM::verify_transaction, it follows:\nCheck signature. Load configs from chain by calling some smart contract functions, see below. Verify transactions. Run 0x01::TransactionManager::prologue smart contract. How is StarcoinVM be Involved? The main functionality is provided by a struct StarcoinVM which is a wrapper of MoveVM.\nA starcoin_open_block::OpenedBlock will be created, when a block is created on chain by starcoin_chain::chain::BlockChain::create_block_template. Some pending transactions (if have any) will push into it by its push_txns, then it’s time to get StarcoinVM involved.\nStarcoinVM is on duty to execute those transactions.\nHow does StarcoinVM Execute Transactions in Block? StarcoinVM::execute_block_transactions will be invoked to execute transactions.\nPreparation Inject natives to MoveVM When we created a StarcoinVM by StarcoinVM::new, its will create MoveVM by:\npub fn new(metrics: Option\u003cVMMetrics\u003e) -\u003e Self { let inner = MoveVM::new(super::natives::starcoin_natives()) .expect(\"should be able to create Move VM; check if there are duplicated natives\"); Self { move_vm: Arc::new(inner), vm_config: None, version: None, move_version: None, metrics, } } All the natives that been injected to MoveVM are defined at starcoin_natives::starcoin_natives().\nLoad Configs by Calling Move Module Defined in stdlib The first thing it will do is load configs and call some functions in stdlib(Here we will skip the operations of genesis, there in different branch).\nThose smart contract functions are invoked by StarcoinVM::execute_readonly_function:\n0x1::VMConfig::instruction_schedule() defines how many gas will be cost to execute each Move instruction. 0x1::VMConfig::native_schedule() defines how many gas will be cost to execute each native Move expression. 0x1::VMConfig::gas_constants() some constans about gas. With those configurations, the StarcoinVM knows how many gas will be cost during a execution. I think this way to maintain config is very smart, as it can change the gas cost way without change the node(Rust). Further more, can change it with DAO.\nWait a minute, How those smart contract functions are executed?\nExecute Readonly Function Let’s see what have done in StarcoinVM::execute_readonly_function:\nIn short words, provide a StateViewCache to a new session of MoveVM, then call session.execute_function.\nStateViewCache implements some necessary resolver traits that help MoveVM session to locate the module and resource:\nModuleResolver find module by ModuleID ResourceResolver find resource by address and type As the stdlib has already deployed on the chain at 0x01 address in the genesis process, so the StateViewCache with those resolver resolver implementations will lead MoveVM locate the stdlib module.\nExecute Block Transactions Now it’s time to check the remain logic, there two types of transactions we need to care about:\nTransactionBlock::Prologue Each block whether it contains transactions or not, a prologue always need to be done, mainly invoke a smart contract function in stdlib:\n0x01::TransactionManager::block_prologue TransactionBlock::UserTransaction When a block contains transactions, it have three kinds of payload, which are defined as:\n#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize, JsonSchema)] pub enum TransactionPayload { /// A transaction that executes code. Script(Script), /// A transaction that publish or update module code by a package. Package(Package), /// A transaction that executes an existing script function published on-chain. ScriptFunction(ScriptFunction), } TransactionPayload::Script and TransactionPayload::ScriptFuntion have the same behaviour, that defined in StarcoinVM::execute_script_or_script_function. Before the script or script funciton been executed, a prologue which defined in stdlib will be executed first, and then an epilogue will be executed when the transactions is exeucted successfully:\n0x01::TransactionManager::prologue\n0x01::TransactionManager::epilogue or 0x01::TransactionManager::epilogue_v2, it depends on which version of stdlib is used in current runtime.\nTransactionPayload::Package invovled the same smart contract functions, but it’s code logic is more complex, check StarcoinVM::execute_package:\nPublish the package as move module bundle. session .publish_module_bundle_with_option( package .modules() .iter() .map(|m| m.code().to_vec()) .collect(), package.package_address(), // be careful with the sender. cost_strategy, PublishModuleBundleOption { force_publish: enforced, only_new_module, }, ) .map_err(|e| e.into_vm_status())?; Invoke init_script of the package if has any. Same question as above, how this module stored into chain? Let’s check StateViewCache again, it haven’t the corresponding traits. After doing some research, I found the session we are used isn’t in the offcial Move language, it defined as move_vm::move_vm_runtime::move_vm_adapter::SessionAdapter. It’ll invoke DataStore::publish_module, it just put our package into our account cache. This explains how a smart contract is deployed.\nHow does a Smart Contract Be Executed I’m curious about how a smart contract been executed.\nSo, with those questions, let’s see how a block is executed on chain.\nTo execute a smart contract, or in starcoin to invoke Move modules from a Move script, we can simply make a RPC invocation contract.call_v2, which defines at rpc/server/src/module/contract_rpc.rs#L145:\nfn call_v2(\u0026self, call: ContractCall) -\u003e FutureResult\u003cVec\u003cDecodedMoveValue\u003e\u003e { let service = self.chain_state.clone(); let storage = self.storage.clone(); let ContractCall { function_id, type_args, args, } = call; let metrics = self.playground.metrics.clone(); let f = async move { let state_root = service.state_root().await?; let state = ChainStateDB::new(storage, Some(state_root)); let output = call_contract( \u0026state, function_id.0.module, function_id.0.function.as_str(), type_args.into_iter().map(|v| v.0).collect(), args.into_iter().map(|v| v.0).collect(), metrics, )?; let annotator = MoveValueAnnotator::new(\u0026state); output .into_iter() .map(|(ty, v)| annotator.view_value(\u0026ty, \u0026v).map(Into::into)) .collect::\u003canyhow::Result\u003cVec\u003c_\u003e\u003e\u003e() } .map_err(map_err); Box::pin(f.boxed()) } The call_contract will eventually call StarcoinVM::execute_readonly_function which we have already discussed above.\nMint Block Once the block had been created and executed, the miner is going to mint the block: generate nounces to meet the diffculty. When it has been done, the block is ready to append to the chain, which means all the transactions in the block are take effect.\n",
  "wordCount" : "980",
  "inLanguage": "en",
  "datePublished": "2022-06-24T17:26:00+08:00",
  "dateModified": "2022-06-24T17:26:00+08:00",
  "author":[{
    "@type": "Person",
    "name": "Gray King"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://notes.0081800.xyz/notes/20220624172625-how_a_block_is_executed/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Taking Smart Notes With Org-mode",
    "logo": {
      "@type": "ImageObject",
      "url": "https://notes.0081800.xyz/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://notes.0081800.xyz/" accesskey="h" title="Taking Smart Notes With Org-mode (Alt + H)">Taking Smart Notes With Org-mode</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://notes.0081800.xyz/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://notes.0081800.xyz/articles/" title="Articles">
                    <span>Articles</span>
                </a>
            </li>
            <li>
                <a href="https://notes.0081800.xyz/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://notes.0081800.xyz/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://notes.0081800.xyz/">Home</a>&nbsp;»&nbsp;<a href="https://notes.0081800.xyz/notes/">Notes</a></div>
    <h1 class="post-title">
      How is a Block Executed
    </h1>
    <div class="post-meta"><span title='2022-06-24 17:26:00 +0800 +0800'>June 24, 2022</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Gray King

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#how-does-starcoinvm-validate-transactions" aria-label="How does StarcoinVM Validate Transactions?">How does StarcoinVM Validate Transactions?</a></li>
                <li>
                    <a href="#how-is-starcoinvm-be-involved" aria-label="How is StarcoinVM be Involved?">How is StarcoinVM be Involved?</a></li>
                <li>
                    <a href="#how-does-starcoinvm-execute-transactions-in-block" aria-label="How does StarcoinVM Execute Transactions in Block?">How does StarcoinVM Execute Transactions in Block?</a><ul>
                        
                <li>
                    <a href="#preparation" aria-label="Preparation">Preparation</a><ul>
                        
                <li>
                    <a href="#inject-natives-to-movevm" aria-label="Inject natives to MoveVM">Inject natives to <code>MoveVM</code></a></li>
                <li>
                    <a href="#load-configs-by-calling-move-module-defined-in-stdlib" aria-label="Load Configs by Calling Move Module Defined in stdlib">Load Configs by Calling Move Module Defined in stdlib</a></li>
                <li>
                    <a href="#execute-readonly-function" aria-label="Execute Readonly Function">Execute Readonly Function</a></li></ul>
                </li>
                <li>
                    <a href="#execute-block-transactions" aria-label="Execute Block Transactions">Execute Block Transactions</a><ul>
                        
                <li>
                    <a href="#transactionblock-prologue" aria-label="TransactionBlock::Prologue"><code>TransactionBlock::Prologue</code></a></li>
                <li>
                    <a href="#transactionblock-usertransaction" aria-label="TransactionBlock::UserTransaction"><code>TransactionBlock::UserTransaction</code></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#how-does-a-smart-contract-be-executed" aria-label="How does a Smart Contract Be Executed">How does a Smart Contract Be Executed</a></li>
                <li>
                    <a href="#mint-block" aria-label="Mint Block">Mint Block</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><ul>
<li>tags: <a href="/notes/20220531104515-starcoin_web3_startrek/">Starcoin Web3 StarTrek</a>,<a href="/notes/20220618163155-move/">Move</a></li>
</ul>
<p>When I start learning Move and looking at the stdlib <a href="https://github.com/starcoinorg/starcoin-framework">starcoin-framework</a> and <a href="https://github.com/starcoinorg/starcoin-framework-commons/">starcoin-framework-commons</a>.
Then I realized there are must some magic during the block execution in runtime.
To roll the world, the runtime should provide some built in types and call some function in the
stdlib.</p>
<h2 id="how-does-starcoinvm-validate-transactions">How does StarcoinVM Validate Transactions?<a hidden class="anchor" aria-hidden="true" href="#how-does-starcoinvm-validate-transactions">#</a></h2>
<p>As a miner, it&rsquo;s responsible for executing block, it follows:</p>
<ol>
<li>
<p>Received some transactions from P2P network: <a href="https://github.com/starcoinorg/starcoin/blob/fc4f61666be98c64161b08b94f12eddcec1a78f8/txpool/src/lib.rs#L214-L224">EventHandler of PeerTransactionsMessage</a>.</p>
</li>
<li>
<p>Import transactions into transactions pool as pending transactions: <a href="https://github.com/starcoinorg/starcoin/blob/fc4f61666be98c64161b08b94f12eddcec1a78f8/txpool/src/pool/queue.rs#L267-L346">txpool::pool::queue::TransactionQueue::import</a></p>
<p>During importing, it&rsquo;ll verify those transactions by calling <a href="https://github.com/starcoinorg/starcoin/blob/fc4f61666be98c64161b08b94f12eddcec1a78f8/txpool/src/pool/queue.rs#L321-L336">verify_transaction</a>.</p>
</li>
<li>
<p>Retrieve pending transactions and put it into the a block prepare to execute.</p>
</li>
</ol>
<p>In the step 2, the miner need to verify the received transactions before put it into queue as pending transactions.</p>
<p>The actually verify logic are defined at <a href="https://github.com/starcoinorg/starcoin/blob/fc4f61666be98c64161b08b94f12eddcec1a78f8/txpool/src/pool/queue.rs#L321-L336">StarcoinVM::verify_transaction</a>, it follows:</p>
<ol>
<li>Check signature.</li>
<li>Load configs from chain by calling some smart contract functions, see below.</li>
<li>Verify transactions.</li>
<li>Run <code>0x01::TransactionManager::prologue</code> smart contract.</li>
</ol>
<h2 id="how-is-starcoinvm-be-involved">How is StarcoinVM be Involved?<a hidden class="anchor" aria-hidden="true" href="#how-is-starcoinvm-be-involved">#</a></h2>
<p>The main functionality is provided by a struct <a href="https://github.com/starcoinorg/starcoin/blob/562a8f65fbd9b5305b7364219a2e9e2e727e09be/vm/vm-runtime/src/starcoin_vm.rs#L76">StarcoinVM</a> which is a wrapper of <code>MoveVM</code>.</p>
<p>A <a href="https://github.com/starcoinorg/starcoin/blob/562a8f65fbd9b5305b7364219a2e9e2e727e09be/chain/open-block/src/lib.rs#L27">starcoin_open_block::OpenedBlock</a> will be created, when a block is created on chain by <a href="https://github.com/starcoinorg/starcoin/blob/562a8f65fbd9b5305b7364219a2e9e2e727e09be/chain/src/chain.rs#L215-L272">starcoin_chain::chain::BlockChain::create_block_template</a>.
Some <code>pending transactions</code> (if have any) will push into it by its <a href="https://github.com/starcoinorg/starcoin/blob/562a8f65fbd9b5305b7364219a2e9e2e727e09be/chain/open-block/src/lib.rs#L138">push_txns</a>, then it&rsquo;s time to get <code>StarcoinVM</code> involved.</p>
<p><code>StarcoinVM</code> is on duty to execute those <code>transactions</code>.</p>
<h2 id="how-does-starcoinvm-execute-transactions-in-block">How does StarcoinVM Execute Transactions in Block?<a hidden class="anchor" aria-hidden="true" href="#how-does-starcoinvm-execute-transactions-in-block">#</a></h2>
<p><a href="https://github.com/starcoinorg/starcoin/blob/562a8f65fbd9b5305b7364219a2e9e2e727e09be/vm/vm-runtime/src/starcoin_vm.rs#L986">StarcoinVM::execute_block_transactions</a> will be invoked to execute transactions.</p>
<h3 id="preparation">Preparation<a hidden class="anchor" aria-hidden="true" href="#preparation">#</a></h3>
<h4 id="inject-natives-to-movevm">Inject natives to <code>MoveVM</code><a hidden class="anchor" aria-hidden="true" href="#inject-natives-to-movevm">#</a></h4>
<p>When we created a <code>StarcoinVM</code> by <a href="https://github.com/starcoinorg/starcoin/blob/562a8f65fbd9b5305b7364219a2e9e2e727e09be/vm/vm-runtime/src/starcoin_vm.rs#L88-L98">StarcoinVM::new</a>, its will create <code>MoveVM</code> by:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(metrics: Option<span style="color:#f92672">&lt;</span>VMMetrics<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> inner <span style="color:#f92672">=</span> MoveVM::new(<span style="color:#66d9ef">super</span>::natives::starcoin_natives())
</span></span><span style="display:flex;"><span>        .expect(<span style="color:#e6db74">&#34;should be able to create Move VM; check if there are duplicated natives&#34;</span>);
</span></span><span style="display:flex;"><span>    Self {
</span></span><span style="display:flex;"><span>        move_vm: <span style="color:#a6e22e">Arc</span>::new(inner),
</span></span><span style="display:flex;"><span>        vm_config: None,
</span></span><span style="display:flex;"><span>        version: None,
</span></span><span style="display:flex;"><span>        move_version: None,
</span></span><span style="display:flex;"><span>        metrics,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>All the natives that been injected to <code>MoveVM</code> are defined at <a href="https://github.com/starcoinorg/starcoin/blob/562a8f65fbd9b5305b7364219a2e9e2e727e09be/vm/natives/src/lib.rs#L24-L139">starcoin_natives::starcoin_natives()</a>.</p>
<h4 id="load-configs-by-calling-move-module-defined-in-stdlib">Load Configs by Calling Move Module Defined in stdlib<a hidden class="anchor" aria-hidden="true" href="#load-configs-by-calling-move-module-defined-in-stdlib">#</a></h4>
<p>The first thing it will do is load configs and call some functions in stdlib(Here we will skip the operations of genesis, there in different branch).</p>
<p>Those smart contract functions are invoked by <code>StarcoinVM::execute_readonly_function</code>:</p>
<ul>
<li><a href="https://github.com/starcoinorg/starcoin-framework/blob/main/sources/VMConfig.move#L74-L222">0x1::VMConfig::instruction_schedule()</a> defines how many gas will be cost to execute each Move instruction.</li>
<li><a href="https://github.com/starcoinorg/starcoin-framework/blob/main/sources/VMConfig.move#L224-L295">0x1::VMConfig::native_schedule()</a> defines how many gas will be cost to execute each native Move expression.</li>
<li><a href="https://github.com/starcoinorg/starcoin-framework/blob/main/sources/VMConfig.move#L297-L317">0x1::VMConfig::gas_constants()</a> some constans about gas.</li>
</ul>
<p>With those configurations, the <code>StarcoinVM</code> knows how many gas will be cost during a execution.
I think this way to maintain config is very smart, as it can change the gas cost way without change
the node(Rust). Further more, can change it with DAO.</p>
<p>Wait a minute, How those smart contract functions are executed?</p>
<h4 id="execute-readonly-function">Execute Readonly Function<a hidden class="anchor" aria-hidden="true" href="#execute-readonly-function">#</a></h4>
<p>Let&rsquo;s see what have done in <a href="https://github.com/starcoinorg/starcoin/blob/562a8f65fbd9b5305b7364219a2e9e2e727e09be/vm/vm-runtime/src/starcoin_vm.rs#L1091-L1125">StarcoinVM::execute_readonly_function</a>:</p>
<p>In short words, provide a <a href="https://github.com/starcoinorg/starcoin/blob/562a8f65fbd9b5305b7364219a2e9e2e727e09be/vm/vm-runtime/src/data_cache.rs#L33-L36">StateViewCache</a> to a new session of <code>MoveVM</code>, then call <code>session.execute_function</code>.</p>
<p><code>StateViewCache</code> implements some necessary resolver traits that help MoveVM session to locate the module and resource:</p>
<ul>
<li><a href="https://github.com/starcoinorg/move/blob/ae12f353227a01da84efeec99943c6185afec338/language/move-core/types/src/resolver.rs#L10-L25">ModuleResolver</a> find module by ModuleID</li>
<li><a href="https://github.com/starcoinorg/move/blob/ae12f353227a01da84efeec99943c6185afec338/language/move-core/types/src/resolver.rs#L27-L44">ResourceResolver</a> find resource by address and type</li>
</ul>
<p>As the stdlib has already deployed on the chain at <code>0x01</code> address in the genesis process, so the <code>StateViewCache</code> with
those resolver resolver implementations will lead <code>MoveVM</code> locate the stdlib module.</p>
<h3 id="execute-block-transactions">Execute Block Transactions<a hidden class="anchor" aria-hidden="true" href="#execute-block-transactions">#</a></h3>
<p>Now it&rsquo;s time to check the remain logic, there two types of transactions we need to care about:</p>
<h4 id="transactionblock-prologue"><code>TransactionBlock::Prologue</code><a hidden class="anchor" aria-hidden="true" href="#transactionblock-prologue">#</a></h4>
<p>Each block whether it contains transactions or not, a prologue always need to be done, mainly invoke a smart contract function in stdlib:</p>
<ul>
<li><a href="https://github.com/starcoinorg/starcoin-framework/blob/e39dfeb6402b913324262cd2972514b918ef7df8/sources/TransactionManager.move#L197-L236">0x01::TransactionManager::block_prologue</a></li>
</ul>
<h4 id="transactionblock-usertransaction"><code>TransactionBlock::UserTransaction</code><a hidden class="anchor" aria-hidden="true" href="#transactionblock-usertransaction">#</a></h4>
<p>When a block contains transactions, it have three kinds of payload, which are defined as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize, JsonSchema)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">TransactionPayload</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// A transaction that executes code.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    Script(Script),
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// A transaction that publish or update module code by a package.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    Package(Package),
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// A transaction that executes an existing script function published on-chain.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    ScriptFunction(ScriptFunction),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>TransactionPayload::Script</code> and <code>TransactionPayload::ScriptFuntion</code> have the same behaviour, that defined in <a href="https://github.com/starcoinorg/starcoin/blob/c656e4be9c9a507ed85819d165b62419bfb3b367/vm/vm-runtime/src/starcoin_vm.rs#L545-L611">StarcoinVM::execute_script_or_script_function</a>.
Before the script or script funciton been executed, a <code>prologue</code> which defined in stdlib will be executed first, and then an <code>epilogue</code> will
be executed when the transactions is exeucted successfully:</p>
<ul>
<li>
<p><a href="https://github.com/starcoinorg/starcoin-framework/blob/e39dfeb6402b913324262cd2972514b918ef7df8/sources/TransactionManager.move#L44-L125">0x01::TransactionManager::prologue</a></p>
</li>
<li>
<p><a href="https://github.com/starcoinorg/starcoin-framework/blob/e39dfeb6402b913324262cd2972514b918ef7df8/sources/TransactionManager.move#L127-L196">0x01::TransactionManager::epilogue or 0x01::TransactionManager::epilogue_v2</a>, it depends on which version of stdlib is used in current runtime.</p>
<p><code>TransactionPayload::Package</code> invovled the same smart contract functions, but it&rsquo;s code logic is more complex, check <a href="https://github.com/starcoinorg/starcoin/blob/c656e4be9c9a507ed85819d165b62419bfb3b367/vm/vm-runtime/src/starcoin_vm.rs#L435-L543">StarcoinVM::execute_package</a>:</p>
<ol>
<li>Publish the package as move module bundle.
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>session
</span></span><span style="display:flex;"><span>    .publish_module_bundle_with_option(
</span></span><span style="display:flex;"><span>        package
</span></span><span style="display:flex;"><span>            .modules()
</span></span><span style="display:flex;"><span>            .iter()
</span></span><span style="display:flex;"><span>            .map(<span style="color:#f92672">|</span>m<span style="color:#f92672">|</span> m.code().to_vec())
</span></span><span style="display:flex;"><span>            .collect(),
</span></span><span style="display:flex;"><span>        package.package_address(), <span style="color:#75715e">// be careful with the sender.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        cost_strategy,
</span></span><span style="display:flex;"><span>        PublishModuleBundleOption {
</span></span><span style="display:flex;"><span>            force_publish: <span style="color:#a6e22e">enforced</span>,
</span></span><span style="display:flex;"><span>            only_new_module,
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    .map_err(<span style="color:#f92672">|</span>e<span style="color:#f92672">|</span> e.into_vm_status())<span style="color:#f92672">?</span>;
</span></span></code></pre></div></li>
<li>Invoke <code>init_script</code> of the package if has any.</li>
</ol>
</li>
</ul>
<p>Same question as above, how this module stored into chain? Let&rsquo;s check <a href="https://github.com/starcoinorg/starcoin/blob/562a8f65fbd9b5305b7364219a2e9e2e727e09be/vm/vm-runtime/src/data_cache.rs#L33-L36">StateViewCache</a> again, it haven&rsquo;t the corresponding traits.
After doing some research, I found the session we are used isn&rsquo;t in the offcial Move language, it defined as <a href="https://github.com/starcoinorg/move/blob/4735fa59b63e1b30622411d8af65129e4c80b3bc/language/move-vm/runtime/src/move_vm_adapter.rs#L59-L77">move_vm::move_vm_runtime::move_vm_adapter::SessionAdapter</a>.
It&rsquo;ll invoke <a href="https://github.com/starcoinorg/move/blob/4735fa59b63e1b30622411d8af65129e4c80b3bc/language/move-vm/runtime/src/data_cache.rs#L223-L234">DataStore::publish_module</a>, it just put our package into our account cache. This explains how a smart contract is deployed.</p>
<h2 id="how-does-a-smart-contract-be-executed">How does a Smart Contract Be Executed<a hidden class="anchor" aria-hidden="true" href="#how-does-a-smart-contract-be-executed">#</a></h2>
<p>I&rsquo;m curious about how a smart contract been executed.</p>
<p>So, with those questions, let&rsquo;s see how a block is executed on chain.</p>
<p>To execute a smart contract, or in <code>starcoin</code> to invoke Move modules from a Move script,
we can simply make a RPC invocation <code>contract.call_v2</code>, which defines at <a href="https://github.com/starcoinorg/starcoin/blob/562a8f65fbd9b5305b7364219a2e9e2e727e09be/rpc/server/src/module/contract_rpc.rs#L145">rpc/server/src/module/contract_rpc.rs#L145</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">call_v2</span>(<span style="color:#f92672">&amp;</span>self, call: <span style="color:#a6e22e">ContractCall</span>) -&gt; <span style="color:#a6e22e">FutureResult</span><span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>DecodedMoveValue<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> service <span style="color:#f92672">=</span> self.chain_state.clone();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> storage <span style="color:#f92672">=</span> self.storage.clone();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> ContractCall {
</span></span><span style="display:flex;"><span>        function_id,
</span></span><span style="display:flex;"><span>        type_args,
</span></span><span style="display:flex;"><span>        args,
</span></span><span style="display:flex;"><span>    } <span style="color:#f92672">=</span> call;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> metrics <span style="color:#f92672">=</span> self.playground.metrics.clone();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> f <span style="color:#f92672">=</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> state_root <span style="color:#f92672">=</span> service.state_root().<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> state <span style="color:#f92672">=</span> ChainStateDB::new(storage, Some(state_root));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> output <span style="color:#f92672">=</span> call_contract(
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;</span>state,
</span></span><span style="display:flex;"><span>            function_id.<span style="color:#ae81ff">0.</span>module,
</span></span><span style="display:flex;"><span>            function_id.<span style="color:#ae81ff">0.</span>function.as_str(),
</span></span><span style="display:flex;"><span>            type_args.into_iter().map(<span style="color:#f92672">|</span>v<span style="color:#f92672">|</span> v.<span style="color:#ae81ff">0</span>).collect(),
</span></span><span style="display:flex;"><span>            args.into_iter().map(<span style="color:#f92672">|</span>v<span style="color:#f92672">|</span> v.<span style="color:#ae81ff">0</span>).collect(),
</span></span><span style="display:flex;"><span>            metrics,
</span></span><span style="display:flex;"><span>        )<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> annotator <span style="color:#f92672">=</span> MoveValueAnnotator::new(<span style="color:#f92672">&amp;</span>state);
</span></span><span style="display:flex;"><span>        output
</span></span><span style="display:flex;"><span>            .into_iter()
</span></span><span style="display:flex;"><span>            .map(<span style="color:#f92672">|</span>(ty, v)<span style="color:#f92672">|</span> annotator.view_value(<span style="color:#f92672">&amp;</span>ty, <span style="color:#f92672">&amp;</span>v).map(Into::into))
</span></span><span style="display:flex;"><span>            .collect::<span style="color:#f92672">&lt;</span>anyhow::Result<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;&gt;</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    .map_err(map_err);
</span></span><span style="display:flex;"><span>    Box::pin(f.boxed())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>call_contract</code> will eventually call <code>StarcoinVM::execute_readonly_function</code> which we have already discussed above.</p>
<h2 id="mint-block">Mint Block<a hidden class="anchor" aria-hidden="true" href="#mint-block">#</a></h2>
<p>Once the block had been created and executed, the miner is going to mint the block: generate nounces to meet the diffculty.
When it has been done, the block is ready to append to the chain, which means all the transactions in the block are take effect.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>


   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   


<hr />

  <div class="bl-section">
    <h4>No notes link to this note</h4>
  </div>


</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://notes.0081800.xyz/">Taking Smart Notes With Org-mode</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
