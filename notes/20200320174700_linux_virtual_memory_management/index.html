<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Linux Virtual Memory Management | Taking Smart Notes With Org-mode</title>
<meta name="keywords" content="">
<meta name="description" content="tags: Linux 原文连接：Linux Virtual Memory Management Chapter 2 Describing Physical Memory：描述物理内存 独立于平台架构的方式描述内存 — 更好的支持多平台
本章包含描述存储器、内存页的结构体（structures）和一些影响 VM 行为的标识位（flags）
VM 中普遍（prevlent）认为第一重要（principal）的概念是 NUMA。
大型机器中内存访问速度取决于 CPU 到内存的距离。比如一组（bank）内存分配给每一个处理器或者一组内存非常适合靠近的 DMA 设备卡。
这里的每组（bank）内存被称为节点（node）并且这个概念在 Linux 中通过 struct pglist_data（typedef pg_data_t) 表示，即使在 UMA 架构下也是如此。每一个节点是一个由 NULL 结尾的链表，通过 pg_data_t-&gt;next_node 指向下一个节点。
每一个节点都被分割成多个块（block）称为分区（zone）用于表示内存中的范围。分区使用 struct zone_struct(typedef zone_t) 结构体描述，每一个分区都是以下三种类型的一种
ZONE_DMA 开始 16MB 内存，供 ISA 设备使用 ZONE_NORMAL 16MB - 896MB，由内核直接映射到线性地址空间的上部区域（将在第四章讨论） ZONE_HIGHMEM 896MB - END，剩余不由内核直接映射的系统可用内存， 大部分内核操作都只能使用这种类型的分区，所以这里也是这里也是最关键的性能区域（most performance critical zone） 每一个物理页帧（physical page frame）都使用结构体 struct page 表示，所有的结构体都保存在全局数组 mem_map 中，mem_map 通常存储在 ZONE_NORMAL 的开始处；">
<meta name="author" content="Gray King">
<link rel="canonical" href="https://notes.0081800.xyz/notes/20200320174700_linux_virtual_memory_management/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://notes.0081800.xyz/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://notes.0081800.xyz/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://notes.0081800.xyz/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://notes.0081800.xyz/apple-touch-icon.png">
<link rel="mask-icon" href="https://notes.0081800.xyz/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://notes.0081800.xyz/notes/20200320174700_linux_virtual_memory_management/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:title" content="Linux Virtual Memory Management" />
<meta property="og:description" content="tags: Linux 原文连接：Linux Virtual Memory Management Chapter 2 Describing Physical Memory：描述物理内存 独立于平台架构的方式描述内存 — 更好的支持多平台
本章包含描述存储器、内存页的结构体（structures）和一些影响 VM 行为的标识位（flags）
VM 中普遍（prevlent）认为第一重要（principal）的概念是 NUMA。
大型机器中内存访问速度取决于 CPU 到内存的距离。比如一组（bank）内存分配给每一个处理器或者一组内存非常适合靠近的 DMA 设备卡。
这里的每组（bank）内存被称为节点（node）并且这个概念在 Linux 中通过 struct pglist_data（typedef pg_data_t) 表示，即使在 UMA 架构下也是如此。每一个节点是一个由 NULL 结尾的链表，通过 pg_data_t-&gt;next_node 指向下一个节点。
每一个节点都被分割成多个块（block）称为分区（zone）用于表示内存中的范围。分区使用 struct zone_struct(typedef zone_t) 结构体描述，每一个分区都是以下三种类型的一种
ZONE_DMA 开始 16MB 内存，供 ISA 设备使用 ZONE_NORMAL 16MB - 896MB，由内核直接映射到线性地址空间的上部区域（将在第四章讨论） ZONE_HIGHMEM 896MB - END，剩余不由内核直接映射的系统可用内存， 大部分内核操作都只能使用这种类型的分区，所以这里也是这里也是最关键的性能区域（most performance critical zone） 每一个物理页帧（physical page frame）都使用结构体 struct page 表示，所有的结构体都保存在全局数组 mem_map 中，mem_map 通常存储在 ZONE_NORMAL 的开始处；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://notes.0081800.xyz/notes/20200320174700_linux_virtual_memory_management/" /><meta property="article:section" content="notes" />
<meta property="article:published_time" content="2020-03-20T00:00:00+08:00" />
<meta property="article:modified_time" content="2020-03-20T00:00:00+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Linux Virtual Memory Management"/>
<meta name="twitter:description" content="tags: Linux 原文连接：Linux Virtual Memory Management Chapter 2 Describing Physical Memory：描述物理内存 独立于平台架构的方式描述内存 — 更好的支持多平台
本章包含描述存储器、内存页的结构体（structures）和一些影响 VM 行为的标识位（flags）
VM 中普遍（prevlent）认为第一重要（principal）的概念是 NUMA。
大型机器中内存访问速度取决于 CPU 到内存的距离。比如一组（bank）内存分配给每一个处理器或者一组内存非常适合靠近的 DMA 设备卡。
这里的每组（bank）内存被称为节点（node）并且这个概念在 Linux 中通过 struct pglist_data（typedef pg_data_t) 表示，即使在 UMA 架构下也是如此。每一个节点是一个由 NULL 结尾的链表，通过 pg_data_t-&gt;next_node 指向下一个节点。
每一个节点都被分割成多个块（block）称为分区（zone）用于表示内存中的范围。分区使用 struct zone_struct(typedef zone_t) 结构体描述，每一个分区都是以下三种类型的一种
ZONE_DMA 开始 16MB 内存，供 ISA 设备使用 ZONE_NORMAL 16MB - 896MB，由内核直接映射到线性地址空间的上部区域（将在第四章讨论） ZONE_HIGHMEM 896MB - END，剩余不由内核直接映射的系统可用内存， 大部分内核操作都只能使用这种类型的分区，所以这里也是这里也是最关键的性能区域（most performance critical zone） 每一个物理页帧（physical page frame）都使用结构体 struct page 表示，所有的结构体都保存在全局数组 mem_map 中，mem_map 通常存储在 ZONE_NORMAL 的开始处；"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://notes.0081800.xyz/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Linux Virtual Memory Management",
      "item": "https://notes.0081800.xyz/notes/20200320174700_linux_virtual_memory_management/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Linux Virtual Memory Management",
  "name": "Linux Virtual Memory Management",
  "description": "tags: Linux 原文连接：Linux Virtual Memory Management Chapter 2 Describing Physical Memory：描述物理内存 独立于平台架构的方式描述内存 — 更好的支持多平台\n本章包含描述存储器、内存页的结构体（structures）和一些影响 VM 行为的标识位（flags）\nVM 中普遍（prevlent）认为第一重要（principal）的概念是 NUMA。\n大型机器中内存访问速度取决于 CPU 到内存的距离。比如一组（bank）内存分配给每一个处理器或者一组内存非常适合靠近的 DMA 设备卡。\n这里的每组（bank）内存被称为节点（node）并且这个概念在 Linux 中通过 struct pglist_data（typedef pg_data_t) 表示，即使在 UMA 架构下也是如此。每一个节点是一个由 NULL 结尾的链表，通过 pg_data_t-\u0026gt;next_node 指向下一个节点。\n每一个节点都被分割成多个块（block）称为分区（zone）用于表示内存中的范围。分区使用 struct zone_struct(typedef zone_t) 结构体描述，每一个分区都是以下三种类型的一种\nZONE_DMA 开始 16MB 内存，供 ISA 设备使用 ZONE_NORMAL 16MB - 896MB，由内核直接映射到线性地址空间的上部区域（将在第四章讨论） ZONE_HIGHMEM 896MB - END，剩余不由内核直接映射的系统可用内存， 大部分内核操作都只能使用这种类型的分区，所以这里也是这里也是最关键的性能区域（most performance critical zone） 每一个物理页帧（physical page frame）都使用结构体 struct page 表示，所有的结构体都保存在全局数组 mem_map 中，mem_map 通常存储在 ZONE_NORMAL 的开始处；",
  "keywords": [
    
  ],
  "articleBody": " tags: Linux 原文连接：Linux Virtual Memory Management Chapter 2 Describing Physical Memory：描述物理内存 独立于平台架构的方式描述内存 — 更好的支持多平台\n本章包含描述存储器、内存页的结构体（structures）和一些影响 VM 行为的标识位（flags）\nVM 中普遍（prevlent）认为第一重要（principal）的概念是 NUMA。\n大型机器中内存访问速度取决于 CPU 到内存的距离。比如一组（bank）内存分配给每一个处理器或者一组内存非常适合靠近的 DMA 设备卡。\n这里的每组（bank）内存被称为节点（node）并且这个概念在 Linux 中通过 struct pglist_data（typedef pg_data_t) 表示，即使在 UMA 架构下也是如此。每一个节点是一个由 NULL 结尾的链表，通过 pg_data_t-\u003enext_node 指向下一个节点。\n每一个节点都被分割成多个块（block）称为分区（zone）用于表示内存中的范围。分区使用 struct zone_struct(typedef zone_t) 结构体描述，每一个分区都是以下三种类型的一种\nZONE_DMA 开始 16MB 内存，供 ISA 设备使用 ZONE_NORMAL 16MB - 896MB，由内核直接映射到线性地址空间的上部区域（将在第四章讨论） ZONE_HIGHMEM 896MB - END，剩余不由内核直接映射的系统可用内存， 大部分内核操作都只能使用这种类型的分区，所以这里也是这里也是最关键的性能区域（most performance critical zone） 每一个物理页帧（physical page frame）都使用结构体 struct page 表示，所有的结构体都保存在全局数组 mem_map 中，mem_map 通常存储在 ZONE_NORMAL 的开始处；\n结构体之间的关系\n内存节点 Linux 在分配内存页的时候采用 本地节点分配策略（node-local allocation policy） 通过最靠近当前运行 CPU 的节点去分配内存。同时进程也会趋向于采用同一 CPU 运行。\n节点的结构体定义在 下\ntypedef struct pglist_data { // 当前节点包含的分区：ZONE_HIGHMEM,ZONE_NORMAL,ZONE_DMA zone_t node_zones[MAX_NR_ZONES]; // 定义的顺序决定分配优先采用的分区 zonelist_t node_zonelists[GFP_ZONEMASK+1]; // 当前节点包含的分区数量，1 到 3 之间，不一定全有，比如一个 CPU Bank 可能没有 ZONE_DMA int nr_zones; // 节点上每一个物理的帧的页数组的第一个元素（第一页），会在某个地方被全局 mem_map 数组替换 struct page *node_mem_map; // 位图（bitmap）表示节点中没有内存的“洞（holes）”，仅用在 Sparc 和 Sparc64 架构 unsigned long *valid_addr_bitmap; // 第五章关于启动内存分配器 struct bootmem_data *bdata; // 当前节点的起始物理地址 unsigned long node_start_paddr; // 用于全局 mem_map 设置页偏移量，用于计算全局 mem_map 和当前节点（lmem_map）之间的页数 unsigned long node_start_mapnr; // 当前分区的总页数 unsigned long node_size; // 从 0 开始的节点 id int node_id; // 指向下一个节点，NULL 表示结尾 struct pglist_data *node_next; } pg_data_t; 系统中的所有节点都维护在 pgdat_list 中。\n分区 用于跟踪信息，如\n页请用情况 可用区域 锁，等 定义在 typedef struct zone_struct { // 自旋锁用于保护并发访问 spinlock_t lock; // 全部可用页数 unsigned long free_pages; // 分区水印（watermarks） unsigned long pages_min, pages_low, pages_high; // 标识位用于告知换页（pageout）守护 kswapd 平衡当前分区（当获取任意水印后则需要进行平衡） int need_balance; // 可用区域位图用于其他分配器（buddy allocator） free_area_t free_area[MAX_ORDER]; // 进程等待页被释放的 Hash table 实现的等待队列， wait_queue_head_t * wait_table; // Hash 表中等待队列的数量（2的次方） unsigned long wait_table_size; // 用 long 定义上面大小减去二进制对数位的数量 unsigned long wait_table_shift; // 指向父 struct pglist_data *zone_pgdat; // 当前分区指向的全局 mem_map 的第一页 struct page *zone_mem_map; // 同 node_start_paddr unsigned long zone_start_paddr; // 同 node_start_mapnr unsigned long zone_start_mapnr; // 字符串名字，如 “DMA”, “Norma” or “HighMem” char *name; // 当前分区包含的页数 unsigned long size; } zone_t; 分区水印 当系统可用内存非常少时会唤醒换页守护 kswapd 释放内存页。如果压力过大 kswapd 会进行同步释放内存，有时被称为直接回收（direct-reclaim）路径。\n每个分区有三个水印\npages_low，当阈值达到这个值则唤醒 kswapd 释放内存页 pages_min，通过 free_area_init_core 根据分区大小页数比（ZoneSizeInPages / 128）初始化，最小 20 页（x86 80K），最大 255 页（x86 1MB ），阈值达到这个值触发 kswapd 同步方式（fashion）工作 pages_high，不会触发 kswapd 平衡内存页，并使 kswapd 陷入休眠 计算分区大小 PFN(Page Frame Number) 是一个包含物理内存映射的偏移量用于内存页计数，第一个 PFN被系统使用\nmin\\_low\\_pfn 用于定位第一页加载内核镜像的后的开始 max_fpn 指示系统中最后一个内存页帧 max_low_pfn 标记 ZONE_NORMAL 结尾， 内存少的机器 max_pfn 和 max_low_pfn 一致 通过上面三个值可以直接计算出高区内存的开始和结束。\n分区等待队列表 当 IO 在一页内存上开始执行时（page-in or page-out）会进行锁定防止获取到不一致的数据。\n进程使用页时调用 wait_on_page 加入到一个等待队列 IO 完成后调用 UnlockPage 解锁 唤醒所有等待的进程 每次换页都会有一个等待队列，且代价非常昂贵，通过分离许多队列进行优化，等待队列存在 zone_t 中。\n如果一个分区仅有一个等待队列就会产生惊群效应（thundering herd）。为了解决这个问题会有多个等待队列存储在哈希表 zone_t-\u003ewait_table 中（极少的哈希碰撞依然会导致不必要的进程被唤醒）。\n分区初始化 内核页完全初始化后（paging_init）后开始初始化分区，可以预见的是（perdictably）各个平台实现不一致，但是确定（determine）发送给 free_area_init 的参数的逻辑是一致的，支持以下参数\nnid 分区所属节点的逻辑 ID pgdat 初始化的所属节点的 pg_data_t ，UMA 下则为 contig_page_data pmap 指向分配给节点的本地数组 lmem_map 的开始，稍后由 free_area_core 初始化 zones_sizes 一个包含内存页中所有分区大小的数组 zone_start_paddr 第一个分区的起始物理地址 *zone_holes 包含分区内内存段（memory holes）总大小的数组 free_area_init_core 负责使用相应的信息填充 zone_t 并为节点分配 mem_map 数组。\n初始化 mem_map me_map 会在系统启动中以两种方式（fashions）之一进行创建\nNUMA：当作一个起始于 PAGE_OFFSET ，调用 free_area_init_node 初始化这个数组中分配的系统中每一个活跃的节点 UMA： free_area_init 使用 contig_page_data 作为当前节点，使用全局 mem_map 作为当前节点的“本地” mem_map 两个函数的调用关系如下图所示\n页 每页物理页帧在系统中都通过 struct page 关联，用于跟踪状态。\n声明在 中\ntypedef struct page { // 页可能归属于多个列表，此字段用于存放所属链表的表头（多个），也用于将多个（blocks）空闲的表连接在一起 struct list_head list; // 用于当文件或设备映射到内存后关联 inode // 如果页属于文件则指向当前地址空间（address space） // 如果是匿名页但被设置则说明是 swap 地址空间 struct address_space *mapping; // 意义取决于页的状态 // 1. 页是文件映射的一部分表示文件的偏移量（offset） // 2. 页是 swap 缓存的一部分表示 address_space 对 swap 地址空间的偏移量 unsigned long index; // 作为文件映射一部分的页的 inode 和偏移量的哈希，将共享同一个哈希桶（hash_bucket）的页连接在一起 struct page *next_hash; // 当前页的引用计数，变成 0 表示可能被释放，否则就被一个或多个进程使用或用于内核 IO 等待 atomic_t count; // 定义页的状态，见下表 unsigned long flags; // 用于页替换策略 struct list_head lru; // 配合 next_hash 实现类似双端链表的操作 struct page **pprev_hash; // 1. 块设备用于跟踪 buffer_head // 2. 由进程映射的匿名页如果支持交换文件可能关联一个 buffer_head，如果页必须以底层文件系统定义的大小的块和支持的存储同步则有必要 struct buffer_head * buffers; #if defined(CONFIG_HIGHMEM) || defined(WANT_PAGE_VIRTUAL) // ZONE_HIGHMEM 的虚拟地址 void *virtual; #endif /* CONFIG_HIGMEM || WANT_PAGE_VIRTUAL */ } mem_map_t; 映射页到分区 page-\u003ezone 内核版本 2.4.18 之前 struct page 通过 page-\u003ezone 引用所属的分区 page-\u003eflags 内核版本 2.4.18 之后通过顶部 ZONE_SHIFT (8 in x86) 个位替代 page-\u003ezone 来计算页所属的分区。 映射过程\n在 mm/page_alloc.c 中初始化 zone_table\n33 zone_t *zone_table[MAX_NR_ZONES*MAX_NR_NODES]; 34 EXPORT_SYMBOL(zone_table); MAX_NR_ZONE 定义一个内存节点中的最大分区数量 MAX_NR_NODES 定义最大可存在的内存节点数量 EXPORT_SYMBOL() 使 zone_table 可被可加载模块（loadable modules）访问。 这个表将被当作一个多维数组对待。\n在 free_area_init_core 中初始化内存节点中所有的页\n设置分区表(zone table)的值\n733 zone_table[nid * MAX_NR_ZONES + j] = zone; nid – 当前内存节点 ID j – 分区（ struct zone_t ）索引 调用 set_page_zone\n788 set_page_zone(page, nid * MAX_NR_ZONES + j); page 分区内被初始的页，所以 zone_table 的索引存储在页中 High Memory 内核支持 High Memory 用于解决内核可使用的地址空间不足的情况（目前 64 位平台下基本上所有内存都可以映射到内核，所以基本不会存在这种情况）。\n32 位 x86 系统关于 High Memory 存在两个阈值\n4GiB：32 位物理地址最大可寻址大小，内核 通过 kmap() 临时将内存页从 High Memory 映射到 ZONE_NORMAL 用于访问 1GiB 到 4GiB 的内存 64GiB：Intel 发明的 PAE（Physical Address Extension）允许 32 位系统下使用更多内存，通过增加额外的 4 位用于内存寻址最大可以支持 2 的 36 次方个字节（64GiB)的内存寻址 缺陷\n理论上 PAE 允许处理器最大可寻址 64GiB，但是由于 Linux 的虚拟地址空间最大仅支持 4GiB，所以进程依然不能使用这么多内存。 PAE 同时也不允许内核本身使用这么多内存：描述 1GiB 内存需要消耗 11MiB 内核内存（每个 struct page 需要在内核虚拟地址空间中（ZONE_NORMAL）消耗 44 字节），16GiB 需要 176MiB，这样会给 ZONE_NORMAL 造成很大的压力 2.6 中的变更 描述内存节点的 pg_data_t\nnode_start_fpn 替换了 node_start_paddr，用于适配 PAE 架构可以突破 32 位寻址解决通过旧字段无法访问 4GiB 之后的内存节点 kswapd_wait 用于 kswapd 的新的等待队列替换之前的全局等待队列。2.6 中每一个内存节点都有一个对应的 kswapdN（N 对应内存节点的 ID），同时每一个 kswapd 也通过此字段用于自己的等待队列 node_size 字段被以下两个字段替代，引入这一变化主要是认识到节点中可能有 “holes” 导致没有物理内存支持寻址这一事实。\nnode_present_pages 内存节点中存在的总物理页数 node_spanned_pages 被当前内存节点寻址的总区域，包括任意可能存在的 “holes” zone_t 改为 struct zone ，同时 LRU 列表由全局改为存储再 struct zone 中（LRU 用于确定内存页释放或切出的顺序）\n相关链接 ",
  "wordCount" : "680",
  "inLanguage": "en",
  "datePublished": "2020-03-20T00:00:00+08:00",
  "dateModified": "2020-03-20T00:00:00+08:00",
  "author":[{
    "@type": "Person",
    "name": "Gray King"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://notes.0081800.xyz/notes/20200320174700_linux_virtual_memory_management/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Taking Smart Notes With Org-mode",
    "logo": {
      "@type": "ImageObject",
      "url": "https://notes.0081800.xyz/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://notes.0081800.xyz/" accesskey="h" title="Taking Smart Notes With Org-mode (Alt + H)">Taking Smart Notes With Org-mode</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://notes.0081800.xyz/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://notes.0081800.xyz/articles/" title="Articles">
                    <span>Articles</span>
                </a>
            </li>
            <li>
                <a href="https://notes.0081800.xyz/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://notes.0081800.xyz/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://notes.0081800.xyz/">Home</a>&nbsp;»&nbsp;<a href="https://notes.0081800.xyz/notes/">Notes</a></div>
    <h1 class="post-title">
      Linux Virtual Memory Management
    </h1>
    <div class="post-meta"><span title='2020-03-20 00:00:00 +0800 +0800'>March 20, 2020</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Gray King

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#chapter-2-describing-physical-memory-%e6%8f%8f%e8%bf%b0%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98" aria-label="Chapter 2 Describing Physical Memory：描述物理内存">Chapter 2 Describing Physical Memory：描述物理内存</a><ul>
                        <ul>
                        
                <li>
                    <a href="#%e5%86%85%e5%ad%98%e8%8a%82%e7%82%b9" aria-label="内存节点">内存节点</a></li>
                <li>
                    <a href="#%e5%88%86%e5%8c%ba" aria-label="分区">分区</a></li>
                <li>
                    <a href="#%e5%88%86%e5%8c%ba%e6%b0%b4%e5%8d%b0" aria-label="分区水印">分区水印</a></li>
                <li>
                    <a href="#%e8%ae%a1%e7%ae%97%e5%88%86%e5%8c%ba%e5%a4%a7%e5%b0%8f" aria-label="计算分区大小">计算分区大小</a></li>
                <li>
                    <a href="#%e5%88%86%e5%8c%ba%e7%ad%89%e5%be%85%e9%98%9f%e5%88%97%e8%a1%a8" aria-label="分区等待队列表">分区等待队列表</a></li>
                <li>
                    <a href="#%e5%88%86%e5%8c%ba%e5%88%9d%e5%a7%8b%e5%8c%96" aria-label="分区初始化">分区初始化</a></li>
                <li>
                    <a href="#%e5%88%9d%e5%a7%8b%e5%8c%96-mem-map" aria-label="初始化 mem_map">初始化 mem_map</a></li>
                <li>
                    <a href="#%e9%a1%b5" aria-label="页">页</a></li>
                <li>
                    <a href="#%e6%98%a0%e5%b0%84%e9%a1%b5%e5%88%b0%e5%88%86%e5%8c%ba" aria-label="映射页到分区">映射页到分区</a></li>
                <li>
                    <a href="#high-memory" aria-label="High Memory">High Memory</a></li>
                <li>
                    <a href="#2-dot-6-%e4%b8%ad%e7%9a%84%e5%8f%98%e6%9b%b4" aria-label="2.6 中的变更">2.6 中的变更</a></li>
                <li>
                    <a href="#%e7%9b%b8%e5%85%b3%e9%93%be%e6%8e%a5" aria-label="相关链接">相关链接</a>
                </li>
            </ul>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><ul>
<li>tags: <a href="/notes/20220104103936-linux/">Linux</a></li>
<li>原文连接：<a href="https://tldp.org/LDP/tlk/tlk-toc.html">Linux Virtual Memory Management</a></li>
</ul>
<h2 id="chapter-2-describing-physical-memory-描述物理内存">Chapter 2 Describing Physical Memory：描述物理内存<a hidden class="anchor" aria-hidden="true" href="#chapter-2-describing-physical-memory-描述物理内存">#</a></h2>
<ul>
<li>
<p>独立于平台架构的方式描述内存 — 更好的支持多平台</p>
</li>
<li>
<p>本章包含描述存储器、内存页的结构体（structures）和一些影响 VM 行为的标识位（flags）</p>
</li>
<li>
<p>VM 中普遍（prevlent）认为第一重要（principal）的概念是 <a href="https://zh.wikipedia.org/wiki/%E9%9D%9E%E5%9D%87%E5%8C%80%E8%AE%BF%E5%AD%98%E6%A8%A1%E5%9E%8B">NUMA</a>。</p>
</li>
<li>
<p>大型机器中内存访问速度取决于 CPU 到内存的距离。比如一组（bank）内存分配给每一个处理器或者一组内存非常适合靠近的 <a href="https://zh.wikipedia.org/zh/%E7%9B%B4%E6%8E%A5%E8%A8%98%E6%86%B6%E9%AB%94%E5%AD%98%E5%8F%96">DMA</a> 设备卡。</p>
</li>
<li>
<p>这里的每组（bank）内存被称为节点（node）并且这个概念在     Linux 中通过 <strong><strong>struct pglist_data（typedef pg_data_t)</strong></strong> 表示，即使在 <a href="https://zh.wikipedia.org/wiki/%E5%9D%87%E5%8C%80%E8%AE%BF%E5%AD%98%E6%A8%A1%E5%9E%8B">UMA</a> 架构下也是如此。每一个节点是一个由 NULL 结尾的链表，通过 <strong><strong>pg_data_t-&gt;next_node</strong></strong> 指向下一个节点。</p>
</li>
<li>
<p>每一个节点都被分割成多个块（block）称为分区（zone）用于表示内存中的范围。分区使用 <strong><strong>struct zone_struct(typedef zone_t)</strong></strong> 结构体描述，每一个分区都是以下三种类型的一种</p>
<ul>
<li>ZONE_DMA 开始 16MB 内存，供 <a href="https://zh.m.wikipedia.org/wiki/%E5%B7%A5%E4%B8%9A%E6%A0%87%E5%87%86%E7%BB%93%E6%9E%84">ISA</a> 设备使用</li>
<li>ZONE_NORMAL 16MB - 896MB，由内核直接映射到线性地址空间的上部区域（将在第四章讨论）</li>
<li>ZONE_HIGHMEM 896MB - END，剩余不由内核直接映射的系统可用内存， <strong><strong>大部分内核操作都只能使用这种类型的分区，所以这里也是这里也是最关键的性能区域（most performance critical zone）</strong></strong></li>
</ul>
</li>
<li>
<p>每一个物理页帧（physical page frame）都使用结构体 <strong><strong>struct page</strong></strong> 表示，所有的结构体都保存在全局数组 <strong><strong>mem_map</strong></strong> 中，mem_map 通常存储在 <strong><strong>ZONE_NORMAL</strong></strong> 的开始处；</p>
</li>
<li>
<p>结构体之间的关系</p>
<figure>
        <img loading="lazy" src="/images/linux-vm-2/1554100733254_3.jpeg"/> 
    </figure>

</li>
</ul>
<h4 id="内存节点">内存节点<a hidden class="anchor" aria-hidden="true" href="#内存节点">#</a></h4>
<p>Linux 在分配内存页的时候采用 <strong>本地节点分配策略（node-local allocation policy）</strong> 通过最靠近当前运行 CPU 的节点去分配内存。同时进程也会趋向于采用同一 CPU 运行。</p>
<p>节点的结构体定义在 <code>&lt;linux/memzone.h&gt;</code> 下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> pglist_data {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 当前节点包含的分区：ZONE_HIGHMEM,ZONE_NORMAL,ZONE_DMA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">zone_t</span> node_zones[MAX_NR_ZONES];
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 定义的顺序决定分配优先采用的分区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">zonelist_t</span> node_zonelists[GFP_ZONEMASK<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 当前节点包含的分区数量，1 到 3 之间，不一定全有，比如一个 CPU Bank 可能没有 ZONE_DMA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">int</span> nr_zones;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 节点上每一个物理的帧的页数组的第一个元素（第一页），会在某个地方被全局 mem_map 数组替换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>node_mem_map;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 位图（bitmap）表示节点中没有内存的“洞（holes）”，仅用在 Sparc 和 Sparc64 架构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>valid_addr_bitmap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 第五章关于启动内存分配器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">struct</span> bootmem_data <span style="color:#f92672">*</span>bdata;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 当前节点的起始物理地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> node_start_paddr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 用于全局 mem_map 设置页偏移量，用于计算全局 mem_map 和当前节点（lmem_map）之间的页数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> node_start_mapnr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 当前分区的总页数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> node_size;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 从 0 开始的节点 id
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">int</span> node_id;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 指向下一个节点，NULL 表示结尾
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">struct</span> pglist_data <span style="color:#f92672">*</span>node_next;
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">pg_data_t</span>;
</span></span></code></pre></div><p>系统中的所有节点都维护在 <strong><strong>pgdat_list</strong></strong> 中。</p>
<h4 id="分区">分区<a hidden class="anchor" aria-hidden="true" href="#分区">#</a></h4>
<p>用于跟踪信息，如</p>
<ul>
<li>页请用情况</li>
<li>可用区域</li>
<li>锁，等</li>
</ul>
<p>定义在 <code>&lt;linux/memzone.h&gt;</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> zone_struct {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 自旋锁用于保护并发访问
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">spinlock_t</span> lock;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 全部可用页数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> free_pages;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 分区水印（watermarks）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> pages_min, pages_low, pages_high;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 标识位用于告知换页（pageout）守护 kswapd 平衡当前分区（当获取任意水印后则需要进行平衡）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">int</span> need_balance;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 可用区域位图用于其他分配器（buddy allocator）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">free_area_t</span> free_area[MAX_ORDER];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 进程等待页被释放的 Hash table 实现的等待队列，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">wait_queue_head_t</span> <span style="color:#f92672">*</span> wait_table;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Hash 表中等待队列的数量（2的次方）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> wait_table_size;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 用 long 定义上面大小减去二进制对数位的数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	 <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> wait_table_shift;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 指向父
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	 <span style="color:#66d9ef">struct</span> pglist_data <span style="color:#f92672">*</span>zone_pgdat;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	 <span style="color:#75715e">// 当前分区指向的全局 mem_map 的第一页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	 <span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>zone_mem_map;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 同 node_start_paddr
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> zone_start_paddr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 同 node_start_mapnr
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> zone_start_mapnr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 字符串名字，如 “DMA”, “Norma” or “HighMem”
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 当前分区包含的页数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size;
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">zone_t</span>;
</span></span></code></pre></div><h4 id="分区水印">分区水印<a hidden class="anchor" aria-hidden="true" href="#分区水印">#</a></h4>
<p>当系统可用内存非常少时会唤醒换页守护 kswapd 释放内存页。如果压力过大 kswapd 会进行同步释放内存，有时被称为直接回收（direct-reclaim）路径。</p>
<p>每个分区有三个水印</p>
<ul>
<li>pages_low，当阈值达到这个值则唤醒 kswapd 释放内存页</li>
<li>pages_min，通过 <strong><strong>free_area_init_core</strong></strong> 根据分区大小页数比（ZoneSizeInPages / 128）初始化，最小 20 页（x86 80K），最大 255 页（x86 1MB ），阈值达到这个值触发 kswapd 同步方式（fashion）工作</li>
<li>pages_high，不会触发 kswapd 平衡内存页，并使 kswapd 陷入休眠</li>
</ul>
<h4 id="计算分区大小">计算分区大小<a hidden class="anchor" aria-hidden="true" href="#计算分区大小">#</a></h4>
<p><strong>PFN(Page Frame Number)</strong> 是一个包含物理内存映射的偏移量用于内存页计数，第一个 PFN被系统使用</p>
<ul>
<li><strong><strong>min\_low\_pfn</strong></strong> 用于定位第一页加载内核镜像的后的开始</li>
<li><strong><strong>max_fpn</strong></strong> 指示系统中最后一个内存页帧</li>
<li><strong><strong>max_low_pfn</strong></strong> 标记 ZONE_NORMAL 结尾，</li>
<li>内存少的机器 <strong><strong>max_pfn</strong></strong> 和 <strong><strong>max_low_pfn</strong></strong> 一致</li>
</ul>
<p>通过上面三个值可以直接计算出高区内存的开始和结束。</p>
<h4 id="分区等待队列表">分区等待队列表<a hidden class="anchor" aria-hidden="true" href="#分区等待队列表">#</a></h4>
<p>当 IO 在一页内存上开始执行时（page-in or page-out）会进行锁定防止获取到不一致的数据。</p>
<ol>
<li>进程使用页时调用 <strong><strong>wait_on_page</strong></strong> 加入到一个等待队列</li>
<li>IO 完成后调用 <strong><strong>UnlockPage</strong></strong> 解锁</li>
<li>唤醒所有等待的进程</li>
</ol>
<p>每次换页都会有一个等待队列，且代价非常昂贵，通过分离许多队列进行优化，等待队列存在 <strong><strong>zone_t</strong></strong> 中。</p>
<p>如果一个分区仅有一个等待队列就会产生<a href="https://zh.m.wikipedia.org/zh-cn/%E6%83%8A%E7%BE%A4%E9%97%AE%E9%A2%98">惊群效应（thundering herd）</a>。为了解决这个问题会有多个等待队列存储在哈希表 <strong><strong>zone_t-&gt;wait_table</strong></strong> 中（极少的哈希碰撞依然会导致不必要的进程被唤醒）。</p>
<h4 id="分区初始化">分区初始化<a hidden class="anchor" aria-hidden="true" href="#分区初始化">#</a></h4>
<p>内核页完全初始化后（paging_init）后开始初始化分区，可以预见的是（perdictably）各个平台实现不一致，但是确定（determine）发送给 <code>free_area_init</code> 的参数的逻辑是一致的，支持以下参数</p>
<ul>
<li><strong><strong>nid</strong></strong> 分区所属节点的逻辑 ID</li>
<li><strong><strong>pgdat</strong></strong> 初始化的所属节点的 <code>pg_data_t</code> ，UMA 下则为 <code>contig_page_data</code></li>
<li><strong><strong>pmap</strong></strong> 指向分配给节点的本地数组 <code>lmem_map</code> 的开始，稍后由 <code>free_area_core</code> 初始化</li>
<li><strong><strong>zones_sizes</strong></strong> 一个包含内存页中所有分区大小的数组</li>
<li><strong><strong>zone_start_paddr</strong></strong> 第一个分区的起始物理地址</li>
<li><strong>*zone_holes</strong> 包含分区内内存段（memory holes）总大小的数组</li>
</ul>
<p><code>free_area_init_core</code> 负责使用相应的信息填充 <code>zone_t</code> 并为节点分配 <code>mem_map</code> 数组。</p>
<h4 id="初始化-mem-map">初始化 mem_map<a hidden class="anchor" aria-hidden="true" href="#初始化-mem-map">#</a></h4>
<p><strong><strong>me_map</strong></strong> 会在系统启动中以两种方式（fashions）之一进行创建</p>
<ol>
<li>NUMA：当作一个起始于 <strong><strong>PAGE_OFFSET</strong></strong> ，调用 <code>free_area_init_node</code> 初始化这个数组中分配的系统中每一个活跃的节点</li>
<li>UMA： <code>free_area_init</code> 使用 <code>contig_page_data</code> 作为当前节点，使用全局 <code>mem_map</code> 作为当前节点的“本地” <code>mem_map</code></li>
</ol>
<p>两个函数的调用关系如下图所示</p>
<figure>
    <img loading="lazy" src="/images/linux-vm-2/1554100733194_2.jpeg"/> 
</figure>

<h4 id="页">页<a hidden class="anchor" aria-hidden="true" href="#页">#</a></h4>
<p>每页物理页帧在系统中都通过 <code>struct page</code> 关联，用于跟踪状态。</p>
<p>声明在 <code>&lt;linux/mm.h&gt;</code> 中</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> page {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 页可能归属于多个列表，此字段用于存放所属链表的表头（多个），也用于将多个（blocks）空闲的表连接在一起
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">struct</span> list_head list;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 用于当文件或设备映射到内存后关联 inode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 如果页属于文件则指向当前地址空间（address space）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 如果是匿名页但被设置则说明是 swap 地址空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">struct</span> address_space <span style="color:#f92672">*</span>mapping;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 意义取决于页的状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 1. 页是文件映射的一部分表示文件的偏移量（offset）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 2. 页是 swap 缓存的一部分表示 address_space 对 swap 地址空间的偏移量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> index;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 作为文件映射一部分的页的 inode 和偏移量的哈希，将共享同一个哈希桶（hash_bucket）的页连接在一起
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>next_hash;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 当前页的引用计数，变成 0 表示可能被释放，否则就被一个或多个进程使用或用于内核 IO 等待
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">atomic_t</span> count;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 定义页的状态，见下表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 用于页替换策略
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">struct</span> list_head lru;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 配合 next_hash 实现类似双端链表的操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">**</span>pprev_hash;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 1. 块设备用于跟踪 buffer_head
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 2. 由进程映射的匿名页如果支持交换文件可能关联一个 buffer_head，如果页必须以底层文件系统定义的大小的块和支持的存储同步则有必要
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">struct</span> buffer_head <span style="color:#f92672">*</span> buffers;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">#if defined(CONFIG_HIGHMEM) || defined(WANT_PAGE_VIRTUAL)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// ZONE_HIGHMEM 的虚拟地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>virtual;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">#endif </span><span style="color:#75715e">/* CONFIG_HIGMEM || WANT_PAGE_VIRTUAL */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#66d9ef">mem_map_t</span>;
</span></span></code></pre></div><h4 id="映射页到分区">映射页到分区<a hidden class="anchor" aria-hidden="true" href="#映射页到分区">#</a></h4>
<ul>
<li><code>page-&gt;zone</code> 内核版本 2.4.18 之前 <code>struct page</code> 通过 <code>page-&gt;zone</code> 引用所属的分区</li>
<li><code>page-&gt;flags</code> 内核版本 2.4.18 之后通过顶部 <code>ZONE_SHIFT</code> (8 in x86) 个位替代 <code>page-&gt;zone</code> 来计算页所属的分区。</li>
</ul>
<p>映射过程</p>
<ol>
<li>
<p>在 <code>mm/page_alloc.c</code> 中初始化 <code>zone_table</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">33</span> <span style="color:#66d9ef">zone_t</span> <span style="color:#f92672">*</span>zone_table[MAX_NR_ZONES<span style="color:#f92672">*</span>MAX_NR_NODES];
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">34</span> <span style="color:#a6e22e">EXPORT_SYMBOL</span>(zone_table);
</span></span></code></pre></div><ul>
<li><code>MAX_NR_ZONE</code> 定义一个内存节点中的最大分区数量</li>
<li><code>MAX_NR_NODES</code> 定义最大可存在的内存节点数量</li>
<li><code>EXPORT_SYMBOL()</code> 使 <code>zone_table</code> 可被可加载模块（loadable modules）访问。</li>
</ul>
<p>这个表将被当作一个多维数组对待。</p>
</li>
<li>
<p>在 <code>free_area_init_core</code> 中初始化内存节点中所有的页</p>
<ol>
<li>
<p>设置分区表(zone table)的值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ae81ff">733</span>           zone_table[nid <span style="color:#f92672">*</span> MAX_NR_ZONES <span style="color:#f92672">+</span> j] <span style="color:#f92672">=</span> zone;
</span></span></code></pre></div><ul>
<li><code>nid</code> &ndash; 当前内存节点 ID</li>
<li><code>j</code> &ndash; 分区（ <code>struct zone_t</code> ）索引</li>
</ul>
</li>
<li>
<p>调用 <code>set_page_zone</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ae81ff">788</span>           <span style="color:#a6e22e">set_page_zone</span>(page, nid <span style="color:#f92672">*</span> MAX_NR_ZONES <span style="color:#f92672">+</span> j);
</span></span></code></pre></div><ul>
<li><code>page</code> 分区内被初始的页，所以 <code>zone_table</code> 的索引存储在页中</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="high-memory">High Memory<a hidden class="anchor" aria-hidden="true" href="#high-memory">#</a></h4>
<p>内核支持 High Memory 用于解决内核可使用的地址空间不足的情况（目前 64 位平台下基本上所有内存都可以映射到内核，所以基本不会存在这种情况）。</p>
<p>32 位 x86 系统关于 High Memory 存在两个阈值</p>
<ul>
<li>4GiB：32 位物理地址最大可寻址大小，内核 通过 <code>kmap()</code> 临时将内存页从 High Memory 映射到 <code>ZONE_NORMAL</code> 用于访问 1GiB 到 4GiB 的内存</li>
<li>64GiB：Intel 发明的 PAE（Physical Address Extension）允许 32 位系统下使用更多内存，通过增加额外的 4 位用于内存寻址最大可以支持 2 的 36 次方个字节（64GiB)的内存寻址</li>
</ul>
<p>缺陷</p>
<ul>
<li>理论上 PAE 允许处理器最大可寻址 64GiB，但是由于 Linux 的虚拟地址空间最大仅支持 4GiB，所以进程依然不能使用这么多内存。</li>
<li>PAE 同时也不允许内核本身使用这么多内存：描述 1GiB 内存需要消耗 11MiB 内核内存（每个 <code>struct page</code> 需要在内核虚拟地址空间中（<code>ZONE_NORMAL</code>）消耗 44 字节），16GiB 需要 176MiB，这样会给 <code>ZONE_NORMAL</code> 造成很大的压力</li>
</ul>
<h4 id="2-dot-6-中的变更">2.6 中的变更<a hidden class="anchor" aria-hidden="true" href="#2-dot-6-中的变更">#</a></h4>
<ol>
<li>
<p>描述内存节点的 <code>pg_data_t</code></p>
<ul>
<li><strong><strong>node_start_fpn</strong></strong> 替换了 <code>node_start_paddr</code>，用于适配 PAE 架构可以突破 32 位寻址解决通过旧字段无法访问 4GiB 之后的内存节点</li>
<li><strong><strong>kswapd_wait</strong></strong> 用于 <strong><strong>kswapd</strong></strong> 的新的等待队列替换之前的全局等待队列。2.6 中每一个内存节点都有一个对应的 <strong><strong>kswapdN</strong></strong>（N 对应内存节点的 ID），同时每一个 <strong><strong>kswapd</strong></strong> 也通过此字段用于自己的等待队列</li>
</ul>
</li>
<li>
<p><code>node_size</code> 字段被以下两个字段替代，引入这一变化主要是认识到节点中可能有 “holes” 导致没有物理内存支持寻址这一事实。</p>
<ul>
<li><strong><strong>node_present_pages</strong></strong> 内存节点中存在的总物理页数</li>
<li><strong><strong>node_spanned_pages</strong></strong> 被当前内存节点寻址的总区域，包括任意可能存在的 &ldquo;holes&rdquo;</li>
</ul>
</li>
<li>
<p><code>zone_t</code> 改为 <code>struct zone</code> ，同时 LRU 列表由全局改为存储再 <code>struct zone</code> 中（LRU 用于确定内存页释放或切出的顺序）</p>
</li>
</ol>
<h4 id="相关链接">相关链接<a hidden class="anchor" aria-hidden="true" href="#相关链接">#</a></h4>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>


   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   
      
   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   


<hr />

  <div class="bl-section">
    <h3>Links to this note</h3>
    <br />
    <div class="backlinks">
      <ul>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>Linux kernel
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: Linux Linux I/O Linux I/O 演进 阻塞式：read()/write() 非阻塞式：select()/poll()/epoll()，不支持文件 I/O Thread Pool Direct I/O（数据软件）：绕过 page cache 异步 IO（Linux AIO）：早起进支持文件 I/O，近期支持了 epoll 支持非文件 I/O Linux io_uring [译] Linux 异步 I/O 框架 io_uring：基本原理、程序示例与性能压测 对比 Linux AIO：
重新设计实现真正的是不。 支持任何类型的 I/O：cached files、direct-access files 甚至 blocking sockets。 灵活、可扩展：基于 io_uring 能够重写 Linux 的每个系统调用。 原理及核心数据结构：SQ/CQ/SQE/CQE 每个 io_uring 实例都有两个环形队列，在内核和应用程序之间共享：
提交队列：submission queue（SQ） 完成队列：completion queue（CQ） 这两个队列：
都是单生产者、单消费者，size 是 2 的幂次； 提供无锁接口（lock-less access interface），内部使用内存屏障做同步（coordinated with memory barrers）。 使用方式：
请求 应用创建 SQ entries（SQE），更新 SQ tail； 内核消费 SQE，更新 SQ head 完成 内核为完成一个或多个请求创建 CQ enries（CQE），更新 CQ tail； 应用消费 CQE，更新 CQ head 完成事件（completion events）可能以任意顺序到达，到总是与特定的 SQE 相关联的。 消费 CQE 过程无需切换到内核态 带来的好处 支持批处理 支持文件 I/O 系统调用：read、write、send、recv、accept、opentat、stat、专用的一些系统调用，如 fallocate 不再局限于数据库应用 应对现在硬件架构：将硬件架构本身作为一个网络（多核多 CPU 是一个基础网络、CPU 之间是一个网络、CPU 和磁盘 I/O 之间又是一个网络） 三种工作模式 中断驱动模式（interrupt driven）：默认模式。可通过 io_uring_enter() 提交 I/O 请求，然后直接检查 CQ 状态判断是否完成。...</p>
            </div>
            <footer class="entry-footer"><span title='2021-09-07 14:28:00 +0800 +0800'>September 7, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to Linux kernel" href="https://notes.0081800.xyz/notes/20210907142848-linux_kernel/"></a>
          </article>
       
     </ul>
    </div>
  </div>


</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://notes.0081800.xyz/">Taking Smart Notes With Org-mode</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
