<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>领域模式 | Taking Smart Notes With Org-mode</title>
<meta name="keywords" content="">
<meta name="description" content="tags: DDD,《领域驱动设计》读书笔记 领域基础模式 模式：UBIQUITOUS LANGUAGE 在同领域专家、开发人员和项目管理沟通的过程中建立并使用 UBIQUITOUS LANGUAGE，，并在模型实现时依然使用 UBIQUITOUS LANGUAGE 来让设计与沟通相一致（中文语境下稍显困难），UBIQUITOUS LANGUAGE 让知识消化后直接驱动变更模型。
应用 UBIQUITOUS LANGUAGE 需要大声的建模。
模式：MODEL-DRIVEN DESIGN 严格按照模型来编写代码，让模型与实际系统相结合。 不再分离「分析模型」和程序设计，而是寻求一种能够满足这两方面需求的单一模型。 工具：面向对象编程语言、UML等。 更好的支持 UBIQUITOUS LANGUAGE. 模式：HANDS-ON MODELER 开发设计和模型设计紧密合作，避免模型设计者不参与编写和程序设计者不参与模型设计。 每一个开发人员都必须不同程度的参与模型讨论并且与领域专家保持联系，模型设计者及时通过 UBIQUITOUS LANGUAGE 与接触代码的人及时交换关于模型的想法。 领域模式构造块 模式：LAYERED ARCHITECTURE 分层架构是实现 DDD 的基础，分层架构将不同的层次的实现分开，自上倒下应分为：
用户界面层 应用层 领域层（模型的精髓） 基础设施层 核心在于要将领域层单独出来实现 MODEL-DRIVEN DESIGN，对业务进行建模封装业务规则。调用规则也只能自上而下的调用，不能反向调用。
领域层（或模型层）分离出来之后使得模型足够丰富，结构足够清晰，可以捕捉到基本的业务知识，并有效的使用这些知识。
模式：ENTITY 用于跟踪对象的状态，有唯一标识符，在系统中是可变的，两个对象是否一个通过唯一标识来判断，不是靠它们的属性定义。
模式：VALUE OBJECT 区别与 ENTITY ，没有唯一标识，仅记录状态，一般设计为不可变用于共享 VALUE OBJECT，两个对象是否一个通过对象属性的值来判断。
模式：SERVICE 没有状态，但又需要建模的对象，只包含动作。用于一些不适合建模为对象的领域概念。
与领域概念相关的操作不是 ENTITY 或 VALUE OBJECT 的一个自然组成部署 接口是根据领域模型的其他元素定义的。 操作是无状态的 模式：MODULE（或 PACKAGE） 根据对象的意义划分领域模型，低耦合高内聚。按照模式或者对象生命周期或者其他方式划分都是错误的。
模式：AGGREGATE 划分模型边界，统一对关联模型的创建、修改、复制和销毁。一般选定一个 ENTITY 对象作为 AGGREGATE 的「根」，同时对事务应用一组规则：">
<meta name="author" content="Gray King">
<link rel="canonical" href="https://notes.0081800.xyz/notes/20210903080049-%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%BC%8F/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://notes.0081800.xyz/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://notes.0081800.xyz/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://notes.0081800.xyz/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://notes.0081800.xyz/apple-touch-icon.png">
<link rel="mask-icon" href="https://notes.0081800.xyz/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://notes.0081800.xyz/notes/20210903080049-%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%BC%8F/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:title" content="领域模式" />
<meta property="og:description" content="tags: DDD,《领域驱动设计》读书笔记 领域基础模式 模式：UBIQUITOUS LANGUAGE 在同领域专家、开发人员和项目管理沟通的过程中建立并使用 UBIQUITOUS LANGUAGE，，并在模型实现时依然使用 UBIQUITOUS LANGUAGE 来让设计与沟通相一致（中文语境下稍显困难），UBIQUITOUS LANGUAGE 让知识消化后直接驱动变更模型。
应用 UBIQUITOUS LANGUAGE 需要大声的建模。
模式：MODEL-DRIVEN DESIGN 严格按照模型来编写代码，让模型与实际系统相结合。 不再分离「分析模型」和程序设计，而是寻求一种能够满足这两方面需求的单一模型。 工具：面向对象编程语言、UML等。 更好的支持 UBIQUITOUS LANGUAGE. 模式：HANDS-ON MODELER 开发设计和模型设计紧密合作，避免模型设计者不参与编写和程序设计者不参与模型设计。 每一个开发人员都必须不同程度的参与模型讨论并且与领域专家保持联系，模型设计者及时通过 UBIQUITOUS LANGUAGE 与接触代码的人及时交换关于模型的想法。 领域模式构造块 模式：LAYERED ARCHITECTURE 分层架构是实现 DDD 的基础，分层架构将不同的层次的实现分开，自上倒下应分为：
用户界面层 应用层 领域层（模型的精髓） 基础设施层 核心在于要将领域层单独出来实现 MODEL-DRIVEN DESIGN，对业务进行建模封装业务规则。调用规则也只能自上而下的调用，不能反向调用。
领域层（或模型层）分离出来之后使得模型足够丰富，结构足够清晰，可以捕捉到基本的业务知识，并有效的使用这些知识。
模式：ENTITY 用于跟踪对象的状态，有唯一标识符，在系统中是可变的，两个对象是否一个通过唯一标识来判断，不是靠它们的属性定义。
模式：VALUE OBJECT 区别与 ENTITY ，没有唯一标识，仅记录状态，一般设计为不可变用于共享 VALUE OBJECT，两个对象是否一个通过对象属性的值来判断。
模式：SERVICE 没有状态，但又需要建模的对象，只包含动作。用于一些不适合建模为对象的领域概念。
与领域概念相关的操作不是 ENTITY 或 VALUE OBJECT 的一个自然组成部署 接口是根据领域模型的其他元素定义的。 操作是无状态的 模式：MODULE（或 PACKAGE） 根据对象的意义划分领域模型，低耦合高内聚。按照模式或者对象生命周期或者其他方式划分都是错误的。
模式：AGGREGATE 划分模型边界，统一对关联模型的创建、修改、复制和销毁。一般选定一个 ENTITY 对象作为 AGGREGATE 的「根」，同时对事务应用一组规则：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://notes.0081800.xyz/notes/20210903080049-%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%BC%8F/" /><meta property="article:section" content="notes" />
<meta property="article:published_time" content="2021-09-03T08:00:00+08:00" />
<meta property="article:modified_time" content="2021-09-03T08:00:00+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="领域模式"/>
<meta name="twitter:description" content="tags: DDD,《领域驱动设计》读书笔记 领域基础模式 模式：UBIQUITOUS LANGUAGE 在同领域专家、开发人员和项目管理沟通的过程中建立并使用 UBIQUITOUS LANGUAGE，，并在模型实现时依然使用 UBIQUITOUS LANGUAGE 来让设计与沟通相一致（中文语境下稍显困难），UBIQUITOUS LANGUAGE 让知识消化后直接驱动变更模型。
应用 UBIQUITOUS LANGUAGE 需要大声的建模。
模式：MODEL-DRIVEN DESIGN 严格按照模型来编写代码，让模型与实际系统相结合。 不再分离「分析模型」和程序设计，而是寻求一种能够满足这两方面需求的单一模型。 工具：面向对象编程语言、UML等。 更好的支持 UBIQUITOUS LANGUAGE. 模式：HANDS-ON MODELER 开发设计和模型设计紧密合作，避免模型设计者不参与编写和程序设计者不参与模型设计。 每一个开发人员都必须不同程度的参与模型讨论并且与领域专家保持联系，模型设计者及时通过 UBIQUITOUS LANGUAGE 与接触代码的人及时交换关于模型的想法。 领域模式构造块 模式：LAYERED ARCHITECTURE 分层架构是实现 DDD 的基础，分层架构将不同的层次的实现分开，自上倒下应分为：
用户界面层 应用层 领域层（模型的精髓） 基础设施层 核心在于要将领域层单独出来实现 MODEL-DRIVEN DESIGN，对业务进行建模封装业务规则。调用规则也只能自上而下的调用，不能反向调用。
领域层（或模型层）分离出来之后使得模型足够丰富，结构足够清晰，可以捕捉到基本的业务知识，并有效的使用这些知识。
模式：ENTITY 用于跟踪对象的状态，有唯一标识符，在系统中是可变的，两个对象是否一个通过唯一标识来判断，不是靠它们的属性定义。
模式：VALUE OBJECT 区别与 ENTITY ，没有唯一标识，仅记录状态，一般设计为不可变用于共享 VALUE OBJECT，两个对象是否一个通过对象属性的值来判断。
模式：SERVICE 没有状态，但又需要建模的对象，只包含动作。用于一些不适合建模为对象的领域概念。
与领域概念相关的操作不是 ENTITY 或 VALUE OBJECT 的一个自然组成部署 接口是根据领域模型的其他元素定义的。 操作是无状态的 模式：MODULE（或 PACKAGE） 根据对象的意义划分领域模型，低耦合高内聚。按照模式或者对象生命周期或者其他方式划分都是错误的。
模式：AGGREGATE 划分模型边界，统一对关联模型的创建、修改、复制和销毁。一般选定一个 ENTITY 对象作为 AGGREGATE 的「根」，同时对事务应用一组规则："/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://notes.0081800.xyz/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "领域模式",
      "item": "https://notes.0081800.xyz/notes/20210903080049-%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%BC%8F/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "领域模式",
  "name": "领域模式",
  "description": "tags: DDD,《领域驱动设计》读书笔记 领域基础模式 模式：UBIQUITOUS LANGUAGE 在同领域专家、开发人员和项目管理沟通的过程中建立并使用 UBIQUITOUS LANGUAGE，，并在模型实现时依然使用 UBIQUITOUS LANGUAGE 来让设计与沟通相一致（中文语境下稍显困难），UBIQUITOUS LANGUAGE 让知识消化后直接驱动变更模型。\n应用 UBIQUITOUS LANGUAGE 需要大声的建模。\n模式：MODEL-DRIVEN DESIGN 严格按照模型来编写代码，让模型与实际系统相结合。 不再分离「分析模型」和程序设计，而是寻求一种能够满足这两方面需求的单一模型。 工具：面向对象编程语言、UML等。 更好的支持 UBIQUITOUS LANGUAGE. 模式：HANDS-ON MODELER 开发设计和模型设计紧密合作，避免模型设计者不参与编写和程序设计者不参与模型设计。 每一个开发人员都必须不同程度的参与模型讨论并且与领域专家保持联系，模型设计者及时通过 UBIQUITOUS LANGUAGE 与接触代码的人及时交换关于模型的想法。 领域模式构造块 模式：LAYERED ARCHITECTURE 分层架构是实现 DDD 的基础，分层架构将不同的层次的实现分开，自上倒下应分为：\n用户界面层 应用层 领域层（模型的精髓） 基础设施层 核心在于要将领域层单独出来实现 MODEL-DRIVEN DESIGN，对业务进行建模封装业务规则。调用规则也只能自上而下的调用，不能反向调用。\n领域层（或模型层）分离出来之后使得模型足够丰富，结构足够清晰，可以捕捉到基本的业务知识，并有效的使用这些知识。\n模式：ENTITY 用于跟踪对象的状态，有唯一标识符，在系统中是可变的，两个对象是否一个通过唯一标识来判断，不是靠它们的属性定义。\n模式：VALUE OBJECT 区别与 ENTITY ，没有唯一标识，仅记录状态，一般设计为不可变用于共享 VALUE OBJECT，两个对象是否一个通过对象属性的值来判断。\n模式：SERVICE 没有状态，但又需要建模的对象，只包含动作。用于一些不适合建模为对象的领域概念。\n与领域概念相关的操作不是 ENTITY 或 VALUE OBJECT 的一个自然组成部署 接口是根据领域模型的其他元素定义的。 操作是无状态的 模式：MODULE（或 PACKAGE） 根据对象的意义划分领域模型，低耦合高内聚。按照模式或者对象生命周期或者其他方式划分都是错误的。\n模式：AGGREGATE 划分模型边界，统一对关联模型的创建、修改、复制和销毁。一般选定一个 ENTITY 对象作为 AGGREGATE 的「根」，同时对事务应用一组规则：",
  "keywords": [
    
  ],
  "articleBody": " tags: DDD,《领域驱动设计》读书笔记 领域基础模式 模式：UBIQUITOUS LANGUAGE 在同领域专家、开发人员和项目管理沟通的过程中建立并使用 UBIQUITOUS LANGUAGE，，并在模型实现时依然使用 UBIQUITOUS LANGUAGE 来让设计与沟通相一致（中文语境下稍显困难），UBIQUITOUS LANGUAGE 让知识消化后直接驱动变更模型。\n应用 UBIQUITOUS LANGUAGE 需要大声的建模。\n模式：MODEL-DRIVEN DESIGN 严格按照模型来编写代码，让模型与实际系统相结合。 不再分离「分析模型」和程序设计，而是寻求一种能够满足这两方面需求的单一模型。 工具：面向对象编程语言、UML等。 更好的支持 UBIQUITOUS LANGUAGE. 模式：HANDS-ON MODELER 开发设计和模型设计紧密合作，避免模型设计者不参与编写和程序设计者不参与模型设计。 每一个开发人员都必须不同程度的参与模型讨论并且与领域专家保持联系，模型设计者及时通过 UBIQUITOUS LANGUAGE 与接触代码的人及时交换关于模型的想法。 领域模式构造块 模式：LAYERED ARCHITECTURE 分层架构是实现 DDD 的基础，分层架构将不同的层次的实现分开，自上倒下应分为：\n用户界面层 应用层 领域层（模型的精髓） 基础设施层 核心在于要将领域层单独出来实现 MODEL-DRIVEN DESIGN，对业务进行建模封装业务规则。调用规则也只能自上而下的调用，不能反向调用。\n领域层（或模型层）分离出来之后使得模型足够丰富，结构足够清晰，可以捕捉到基本的业务知识，并有效的使用这些知识。\n模式：ENTITY 用于跟踪对象的状态，有唯一标识符，在系统中是可变的，两个对象是否一个通过唯一标识来判断，不是靠它们的属性定义。\n模式：VALUE OBJECT 区别与 ENTITY ，没有唯一标识，仅记录状态，一般设计为不可变用于共享 VALUE OBJECT，两个对象是否一个通过对象属性的值来判断。\n模式：SERVICE 没有状态，但又需要建模的对象，只包含动作。用于一些不适合建模为对象的领域概念。\n与领域概念相关的操作不是 ENTITY 或 VALUE OBJECT 的一个自然组成部署 接口是根据领域模型的其他元素定义的。 操作是无状态的 模式：MODULE（或 PACKAGE） 根据对象的意义划分领域模型，低耦合高内聚。按照模式或者对象生命周期或者其他方式划分都是错误的。\n模式：AGGREGATE 划分模型边界，统一对关联模型的创建、修改、复制和销毁。一般选定一个 ENTITY 对象作为 AGGREGATE 的「根」，同时对事务应用一组规则：\n根 ENTITY 具有全局标识，它最终负责检查固定规则。 边界内的 ENTITY 具有本地标识，这些标识只在 AGGREGATE 内部才是唯一的。 AGGREGATE 外部不的对象不能引入除根 ENTITY 之外的任何内部对象。根 ENTITY 可以把内部 ENTITY 引用传递出去做临时使用，但不能保持引用。 只有 AGGREGATE 的根能直接通过数据库查询获取。其他所有对象必须通过遍历关联来发现。 AGGREGATE 内部的对象可以保持对其他 AGGREGATE 根的引用。 删除操作必须一次删除 AGGREGATE 边界之内的所有对象。 当提交对 AGGREGATE 的更改时，整个 AGGREGATE 的所有固定规则都必须被满足。 模式：Factory 封装创建一个对象或者整个 AGGREGATE 的复杂创建工作，隐藏内部结构。实现的方式：\n简单的对象可以通过 FACTORY METHOD 实现在 AGGREGATE 的根 ENTITY 对象上。 复杂的对象应当转移给独立的 FACTORY。 ENTITY FACTORY 和 VALUE OBJECT FACTORY 两方面不同 VALUE OBJECT 不可变，所以其 FACTORY 生成的对象就是最终形式，因此 FACTORY 操作必须得到创建对象的完整形式。 ENTITY 需要在 FACTORY 生成对象时分配唯一标识。 模式：REPOSITORY 一个遍历 ENTITY 和 VALUE OBJECT 的起点对象（想象图书馆里的图书管理员）。\n只为那些确实需要直接访问的 AGGREGATE 根提供 REPOSITORY，让客户始终聚焦于模型，而将所有对象的存储和访问操作都交给 REPOSITORY 来完成。\nREPOSITORY 与 Factory 的关系 从创建对象角度\nREPOSITORY 负责基于查询的数据恢复已有对象，让客户感觉对象始终驻留内存。 FACTORY 负责创建新的对象。 同时 REPOSITORY 负责持久化相关工作，包括：\n存储对象 删除对象 领域高阶（？）模式 模式：SPECIFICATION 抽象谓词（返回真假的函数）。 为特殊目的创建谓词形式的显式的 VALUE OBJECT。 SPECIFICATION 就是一个谓词，可以用来测试任何对象以校验它们是否满足制定的标准。 规格（SPECIFICATION）中声明的是限制另一个对象状态的约束，被约束对象可以存在也可以不存在。\n领域反模式 模式：THE SMART UI 反模式 不分离用户界面和领域，在界面中实现所有业务逻辑。使用关系数据库作为共享的数据存储库。\n优点：\n效率高 人力成本低 快速响应需求更改 彼此独立，扩展容易 关系数据库提供数据整合 缺点：\n依赖数据库 没有行为重用 有扩展和迭代极限 无法适应复杂功能 ",
  "wordCount" : "190",
  "inLanguage": "en",
  "datePublished": "2021-09-03T08:00:00+08:00",
  "dateModified": "2021-09-03T08:00:00+08:00",
  "author":[{
    "@type": "Person",
    "name": "Gray King"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://notes.0081800.xyz/notes/20210903080049-%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%BC%8F/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Taking Smart Notes With Org-mode",
    "logo": {
      "@type": "ImageObject",
      "url": "https://notes.0081800.xyz/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://notes.0081800.xyz/" accesskey="h" title="Taking Smart Notes With Org-mode (Alt + H)">Taking Smart Notes With Org-mode</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://notes.0081800.xyz/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://notes.0081800.xyz/articles/" title="Articles">
                    <span>Articles</span>
                </a>
            </li>
            <li>
                <a href="https://notes.0081800.xyz/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://notes.0081800.xyz/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://notes.0081800.xyz/">Home</a>&nbsp;»&nbsp;<a href="https://notes.0081800.xyz/notes/">Notes</a></div>
    <h1 class="post-title">
      领域模式
    </h1>
    <div class="post-meta"><span title='2021-09-03 08:00:00 +0800 +0800'>September 3, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e9%a2%86%e5%9f%9f%e5%9f%ba%e7%a1%80%e6%a8%a1%e5%bc%8f" aria-label="领域基础模式">领域基础模式</a><ul>
                        
                <li>
                    <a href="#%e6%a8%a1%e5%bc%8f-ubiquitous-language" aria-label="模式：UBIQUITOUS LANGUAGE">模式：UBIQUITOUS LANGUAGE</a></li>
                <li>
                    <a href="#%e6%a8%a1%e5%bc%8f-model-driven-design" aria-label="模式：MODEL-DRIVEN DESIGN">模式：MODEL-DRIVEN DESIGN</a></li>
                <li>
                    <a href="#%e6%a8%a1%e5%bc%8f-hands-on-modeler" aria-label="模式：HANDS-ON MODELER">模式：HANDS-ON MODELER</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%a2%86%e5%9f%9f%e6%a8%a1%e5%bc%8f%e6%9e%84%e9%80%a0%e5%9d%97" aria-label="领域模式构造块">领域模式构造块</a><ul>
                        
                <li>
                    <a href="#%e6%a8%a1%e5%bc%8f-layered-architecture" aria-label="模式：LAYERED ARCHITECTURE">模式：LAYERED ARCHITECTURE</a></li>
                <li>
                    <a href="#%e6%a8%a1%e5%bc%8f-entity" aria-label="模式：ENTITY">模式：ENTITY</a></li>
                <li>
                    <a href="#%e6%a8%a1%e5%bc%8f-value-object" aria-label="模式：VALUE OBJECT">模式：VALUE OBJECT</a></li>
                <li>
                    <a href="#%e6%a8%a1%e5%bc%8f-service" aria-label="模式：SERVICE">模式：SERVICE</a></li>
                <li>
                    <a href="#%e6%a8%a1%e5%bc%8f-module-%e6%88%96-package" aria-label="模式：MODULE（或 PACKAGE）">模式：MODULE（或 PACKAGE）</a></li>
                <li>
                    <a href="#%e6%a8%a1%e5%bc%8f-aggregate" aria-label="模式：AGGREGATE">模式：AGGREGATE</a></li>
                <li>
                    <a href="#%e6%a8%a1%e5%bc%8f-factory" aria-label="模式：Factory">模式：Factory</a><ul>
                        
                <li>
                    <a href="#entity-factory-%e5%92%8c-value-object-factory-%e4%b8%a4%e6%96%b9%e9%9d%a2%e4%b8%8d%e5%90%8c" aria-label="ENTITY FACTORY 和 VALUE OBJECT FACTORY 两方面不同">ENTITY FACTORY 和 VALUE OBJECT FACTORY 两方面不同</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%a8%a1%e5%bc%8f-repository" aria-label="模式：REPOSITORY">模式：REPOSITORY</a><ul>
                        
                <li>
                    <a href="#repository-%e4%b8%8e-factory-%e7%9a%84%e5%85%b3%e7%b3%bb" aria-label="REPOSITORY 与 Factory 的关系">REPOSITORY 与 Factory 的关系</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e9%a2%86%e5%9f%9f%e9%ab%98%e9%98%b6-%e6%a8%a1%e5%bc%8f" aria-label="领域高阶（？）模式">领域高阶（？）模式</a><ul>
                        
                <li>
                    <a href="#%e6%a8%a1%e5%bc%8f-specification" aria-label="模式：SPECIFICATION">模式：SPECIFICATION</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%a2%86%e5%9f%9f%e5%8f%8d%e6%a8%a1%e5%bc%8f" aria-label="领域反模式">领域反模式</a><ul>
                        
                <li>
                    <a href="#%e6%a8%a1%e5%bc%8f-the-smart-ui-%e5%8f%8d%e6%a8%a1%e5%bc%8f" aria-label="模式：THE SMART UI 反模式">模式：THE SMART UI 反模式</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><ul>
<li>tags: <a href="/notes/20210814071825-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/">DDD</a>,<a href="/notes/20200320171301_%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/">《领域驱动设计》读书笔记</a></li>
</ul>
<h2 id="领域基础模式">领域基础模式<a hidden class="anchor" aria-hidden="true" href="#领域基础模式">#</a></h2>
<h3 id="模式-ubiquitous-language">模式：UBIQUITOUS LANGUAGE<a hidden class="anchor" aria-hidden="true" href="#模式-ubiquitous-language">#</a></h3>
<p>在同领域专家、开发人员和项目管理沟通的过程中建立并使用 UBIQUITOUS LANGUAGE，，并在模型实现时依然使用 UBIQUITOUS LANGUAGE 来让设计与沟通相一致（中文语境下稍显困难），UBIQUITOUS LANGUAGE 让知识消化后直接驱动变更模型。</p>
<p>应用 UBIQUITOUS LANGUAGE 需要<strong>大声的建模</strong>。</p>
<h3 id="模式-model-driven-design">模式：MODEL-DRIVEN DESIGN<a hidden class="anchor" aria-hidden="true" href="#模式-model-driven-design">#</a></h3>
<ul>
<li>严格按照模型来编写代码，让模型与实际系统相结合。</li>
<li>不再分离「分析模型」和程序设计，而是寻求一种能够满足这两方面需求的单一模型。</li>
<li>工具：面向对象编程语言、UML等。</li>
<li>更好的支持 <a href="#%E6%A8%A1%E5%BC%8F-ubiquitous-language">UBIQUITOUS LANGUAGE</a>.</li>
</ul>
<h3 id="模式-hands-on-modeler">模式：HANDS-ON MODELER<a hidden class="anchor" aria-hidden="true" href="#模式-hands-on-modeler">#</a></h3>
<ul>
<li>开发设计和模型设计紧密合作，避免模型设计者不参与编写和程序设计者不参与模型设计。</li>
<li>每一个开发人员都必须不同程度的参与模型讨论并且与领域专家保持联系，模型设计者及时通过 <a href="#%E6%A8%A1%E5%BC%8F-ubiquitous-language">UBIQUITOUS LANGUAGE</a> 与接触代码的人及时交换关于模型的想法。</li>
</ul>
<h2 id="领域模式构造块">领域模式构造块<a hidden class="anchor" aria-hidden="true" href="#领域模式构造块">#</a></h2>
<figure>
    <img loading="lazy" src="/ox-hugo/ddd-blocks.png"/> 
</figure>

<h3 id="模式-layered-architecture">模式：LAYERED ARCHITECTURE<a hidden class="anchor" aria-hidden="true" href="#模式-layered-architecture">#</a></h3>
<p>分层架构是实现 DDD 的基础，分层架构将不同的层次的实现分开，自上倒下应分为：</p>
<ul>
<li>用户界面层</li>
<li>应用层</li>
<li>领域层（模型的精髓）</li>
<li>基础设施层</li>
</ul>
<p>核心在于要将领域层单独出来实现 <a href="#%E6%A8%A1%E5%BC%8F-model-driven-design">MODEL-DRIVEN DESIGN</a>，对业务进行建模封装业务规则。调用规则也只能自上而下的调用，不能反向调用。</p>
<p>领域层（或模型层）分离出来之后使得模型足够丰富，结构足够清晰，可以捕捉到基本的业务知识，并有效的使用这些知识。</p>
<h3 id="模式-entity">模式：ENTITY<a hidden class="anchor" aria-hidden="true" href="#模式-entity">#</a></h3>
<p>用于跟踪对象的状态，有唯一标识符，在系统中是可变的，两个对象是否一个通过唯一标识来判断，不是靠它们的属性定义。</p>
<h3 id="模式-value-object">模式：VALUE OBJECT<a hidden class="anchor" aria-hidden="true" href="#模式-value-object">#</a></h3>
<p>区别与 ENTITY ，没有唯一标识，仅记录状态，一般设计为不可变用于共享 VALUE OBJECT，两个对象是否一个通过对象属性的值来判断。</p>
<h3 id="模式-service">模式：SERVICE<a hidden class="anchor" aria-hidden="true" href="#模式-service">#</a></h3>
<p>没有状态，但又需要建模的对象，只包含动作。用于一些不适合建模为对象的领域概念。</p>
<ul>
<li>与领域概念相关的操作不是 ENTITY 或 VALUE OBJECT 的一个自然组成部署</li>
<li>接口是根据领域模型的其他元素定义的。</li>
<li>操作是无状态的</li>
</ul>
<h3 id="模式-module-或-package">模式：MODULE（或 PACKAGE）<a hidden class="anchor" aria-hidden="true" href="#模式-module-或-package">#</a></h3>
<p>根据对象的意义划分领域模型，低耦合高内聚。按照模式或者对象生命周期或者其他方式划分都是错误的。</p>
<h3 id="模式-aggregate">模式：AGGREGATE<a hidden class="anchor" aria-hidden="true" href="#模式-aggregate">#</a></h3>
<p>划分模型边界，统一对关联模型的创建、修改、复制和销毁。一般选定一个 ENTITY 对象作为 AGGREGATE 的「根」，同时对事务应用一组规则：</p>
<ul>
<li>根 ENTITY 具有全局标识，它最终负责检查固定规则。</li>
<li>边界内的 ENTITY 具有本地标识，这些标识只在 AGGREGATE 内部才是唯一的。</li>
<li>AGGREGATE 外部不的对象不能引入除根 ENTITY 之外的任何内部对象。根 ENTITY 可以把内部 ENTITY 引用传递出去做临时使用，但不能保持引用。</li>
<li>只有 AGGREGATE 的根能直接通过数据库查询获取。其他所有对象必须通过遍历关联来发现。</li>
<li>AGGREGATE 内部的对象可以保持对其他 AGGREGATE 根的引用。</li>
<li>删除操作必须一次删除 AGGREGATE 边界之内的所有对象。</li>
<li>当提交对 AGGREGATE 的更改时，整个 AGGREGATE 的所有固定规则都必须被满足。</li>
</ul>
<h3 id="模式-factory">模式：Factory<a hidden class="anchor" aria-hidden="true" href="#模式-factory">#</a></h3>
<p>封装创建一个对象或者整个 AGGREGATE 的复杂创建工作，隐藏内部结构。实现的方式：</p>
<ul>
<li>简单的对象可以通过 FACTORY METHOD 实现在 AGGREGATE 的根 ENTITY 对象上。</li>
<li>复杂的对象应当转移给独立的 FACTORY。</li>
</ul>
<h4 id="entity-factory-和-value-object-factory-两方面不同">ENTITY FACTORY 和 VALUE OBJECT FACTORY 两方面不同<a hidden class="anchor" aria-hidden="true" href="#entity-factory-和-value-object-factory-两方面不同">#</a></h4>
<ul>
<li>VALUE OBJECT 不可变，所以其 FACTORY 生成的对象就是最终形式，因此 FACTORY 操作必须得到创建对象的完整形式。</li>
<li>ENTITY 需要在 FACTORY 生成对象时分配唯一标识。</li>
</ul>
<h3 id="模式-repository">模式：REPOSITORY<a hidden class="anchor" aria-hidden="true" href="#模式-repository">#</a></h3>
<p>一个遍历 ENTITY 和 VALUE OBJECT 的起点对象（想象图书馆里的图书管理员）。</p>
<p>只为那些确实需要直接访问的 AGGREGATE 根提供 REPOSITORY，让客户始终聚焦于模型，而将所有对象的存储和访问操作都交给 REPOSITORY 来完成。</p>
<h4 id="repository-与-factory-的关系">REPOSITORY 与 Factory 的关系<a hidden class="anchor" aria-hidden="true" href="#repository-与-factory-的关系">#</a></h4>
<p>从创建对象角度</p>
<ul>
<li>REPOSITORY 负责基于查询的数据恢复已有对象，让客户感觉对象始终驻留内存。</li>
<li>FACTORY 负责创建新的对象。</li>
</ul>
<p>同时 REPOSITORY 负责持久化相关工作，包括：</p>
<ul>
<li>存储对象</li>
<li>删除对象</li>
</ul>
<h2 id="领域高阶-模式">领域高阶（？）模式<a hidden class="anchor" aria-hidden="true" href="#领域高阶-模式">#</a></h2>
<h3 id="模式-specification">模式：SPECIFICATION<a hidden class="anchor" aria-hidden="true" href="#模式-specification">#</a></h3>
<p>抽象谓词（返回真假的函数）。
为特殊目的创建谓词形式的显式的 VALUE OBJECT。 SPECIFICATION 就是一个谓词，可以用来测试任何对象以校验它们是否满足制定的标准。
规格（SPECIFICATION）中声明的是限制另一个对象状态的约束，被约束对象可以存在也可以不存在。</p>
<h2 id="领域反模式">领域反模式<a hidden class="anchor" aria-hidden="true" href="#领域反模式">#</a></h2>
<h3 id="模式-the-smart-ui-反模式">模式：THE SMART UI 反模式<a hidden class="anchor" aria-hidden="true" href="#模式-the-smart-ui-反模式">#</a></h3>
<p>不分离用户界面和领域，在界面中实现所有业务逻辑。使用关系数据库作为共享的数据存储库。</p>
<p>优点：</p>
<ul>
<li>效率高</li>
<li>人力成本低</li>
<li>快速响应需求更改</li>
<li>彼此独立，扩展容易</li>
<li>关系数据库提供数据整合</li>
</ul>
<p>缺点：</p>
<ul>
<li>依赖数据库</li>
<li>没有行为重用</li>
<li>有扩展和迭代极限</li>
<li>无法适应复杂功能</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>


   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   
      
   

   

   

   

   

   

   

   

   

   

   

   

   

   


<hr />

  <div class="bl-section">
    <h3>Links to this note</h3>
    <br />
    <div class="backlinks">
      <ul>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>《领域驱动设计》读书笔记
              </h2>
            </header>
            <div class="entry-content">
              <p>tags: 正在读的书,读书笔记,DDD 前言和目录 好的软件需要控制复杂性，好的领域模型可以帮助控制复杂性。
什么样的项目需要 DDD？尝试型的小型项目应该不需要 DDD，但是一旦上了规模考虑后续迭代则需要 DDD。
本书组织方式：
领域建模 领域建模的过程就是消化知识的过程，这个过程应该贯穿整个开发过程，需要持续学习。
模型用来描绘人们所关注的实现或想法的某个方面，比如地图就是模型。
模型是一种简化，是对实现的解释：把与解决问题密切相关的方面抽象出来，而忽略无关的细节。
软件问题建模的区域就是软件的领域
物质世界的领域：机票预订程序涉及的飞机乘客。 无形的领域：会计程序的金融领域。 领域涉及知识信息超载的问题，模型这种知识对知识进行了选择性的简化和有意的结构化。
领域模型将领域专家头脑中的支持严格的组织且有选择的抽象，并不是尽可能建立一个符合“现实”的模型。
模型表示 关联 规定一个遍历方向：存在双向联结时（地址 -&gt; 人 或 人 -&gt; 地址）尽量只用一种，并避免互相关联 添加一个限定符，以便有效减少多重关联 消除不必要的关联 表示方式 领域模式 实践 MODEL-DRIVEN DESIGN 隔离领域：引入应用层 应用 LAYERED ARCHITECTURE 把领域层划分出来，通过应用层类来处理应用程序功能。应用层类是协调者，负责提问，领域层负责回答。
将 ENTITY 和 VALUE OBJECT 区分开 依次考虑对象是必须跟踪的 ENTITY 还是表示一个 VALUE OBJECT。
AGGREGATE 边界 识别模型中的 AGGREGATE 根和对应的边界。
选择 REPOSITORY 为 AGGREGATE 根对象建立 REPOSITORY。
场景走查 根据应用程序特性复核建模，进行场景走查，确保能够有效地解决应用问题。可以走查一些正常和异常业务场景进行复核。
对象创建 如果对象复杂则创建单独的 FACTORY 类进行对象创建，简单对象可以直接在 AGGREGATE 根上通过 FACTORY METHOD 进行创建。...</p>
            </div>
            <footer class="entry-footer"><span title='2019-06-15 00:00:00 +0800 +0800'>June 15, 2019</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to 《领域驱动设计》读书笔记" href="https://notes.0081800.xyz/notes/20200320171301_%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"></a>
          </article>
       
     </ul>
    </div>
  </div>


</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://notes.0081800.xyz/">Taking Smart Notes With Org-mode</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
