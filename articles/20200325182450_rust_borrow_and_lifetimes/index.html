<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Rust Borrow and Lifetimes | Taking Smart Notes With Org-mode</title>
<meta name="keywords" content="">
<meta name="description" content="tags: Rust,Translate,Rust Wrapper Types 原文链接：Rust Borrow and Lifetimes。
Rust 是一门处于往 1.0 活跃开发的新语言（译注：1.0 早已发布，目前最新稳定版本 1.42）。 我必须再写一篇关于我为什么觉得 Rust 牛逼的新博客，但是今天我将关注在它的借用（borrow） 和生命周期（lifetimes）系统，这也是常常让包括我在内的 Rust 新手陷入困境的地方。这篇文章假设 你基本了解 Rust，如果还没推荐你先阅读指南和指针指南。
资源所有权和借用 Rust 通过一个难缠的（sophisticated）借用系统在不用 GC 的情况下达到内存安全。对于任何资源 （栈内存、堆内存、文件句柄等），他们都对应一个唯一的所有者（owner）在需要的情况下处理资源回收。 你可以通过 &amp; 或者 &amp;mut 创建一个新的绑定指向该资源，这被称之为借用或可变借用。编译器确保 所有的所有者（owners）和借用者（borrowers）行为正确。
拷贝和转移（Copy and move） 在我们开始进入借用系统之前，我们需要知道 Rust 如何处理拷贝和转移。这个 StackOverflow 答案非常值得一读。 基本上，在赋值和函数调用上：
如果值是可拷贝的（copyable）（仅涉及原始（primitive）类型，不涉及如内存或文件句柄的资源），编译器默认进行拷贝。 其他情况，编译器转移（moves）所有权（ownership）并使原来的绑定无效。 简而言之，POD（Plan Old Data） =&gt; 拷贝，Non-POD（线性类型（linear types））=&gt; 转移。
以下是一些额外的注释供你参考：
Rust 拷贝像 C。每一个按值（by-value）使用一个值都是字节拷贝（通过 memcpy 浅拷贝），而不是语义上的拷贝或克隆。 如果想要让一个 POD 结构体变成不可拷贝的，你可以使用一个 NoCopy 标记，或者实现 Drop 特性（trait）。 转移之后，所有权就转移到了下一个所有者那。
资源回收 Rust 会在任何资源的所有权消失后立刻释放该资源，就这些，当：">
<meta name="author" content="Gray King">
<link rel="canonical" href="https://notes.0081800.xyz/articles/20200325182450_rust_borrow_and_lifetimes/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://notes.0081800.xyz/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://notes.0081800.xyz/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://notes.0081800.xyz/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://notes.0081800.xyz/apple-touch-icon.png">
<link rel="mask-icon" href="https://notes.0081800.xyz/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Rust Borrow and Lifetimes" />
<meta property="og:description" content="tags: Rust,Translate,Rust Wrapper Types 原文链接：Rust Borrow and Lifetimes。
Rust 是一门处于往 1.0 活跃开发的新语言（译注：1.0 早已发布，目前最新稳定版本 1.42）。 我必须再写一篇关于我为什么觉得 Rust 牛逼的新博客，但是今天我将关注在它的借用（borrow） 和生命周期（lifetimes）系统，这也是常常让包括我在内的 Rust 新手陷入困境的地方。这篇文章假设 你基本了解 Rust，如果还没推荐你先阅读指南和指针指南。
资源所有权和借用 Rust 通过一个难缠的（sophisticated）借用系统在不用 GC 的情况下达到内存安全。对于任何资源 （栈内存、堆内存、文件句柄等），他们都对应一个唯一的所有者（owner）在需要的情况下处理资源回收。 你可以通过 &amp; 或者 &amp;mut 创建一个新的绑定指向该资源，这被称之为借用或可变借用。编译器确保 所有的所有者（owners）和借用者（borrowers）行为正确。
拷贝和转移（Copy and move） 在我们开始进入借用系统之前，我们需要知道 Rust 如何处理拷贝和转移。这个 StackOverflow 答案非常值得一读。 基本上，在赋值和函数调用上：
如果值是可拷贝的（copyable）（仅涉及原始（primitive）类型，不涉及如内存或文件句柄的资源），编译器默认进行拷贝。 其他情况，编译器转移（moves）所有权（ownership）并使原来的绑定无效。 简而言之，POD（Plan Old Data） =&gt; 拷贝，Non-POD（线性类型（linear types））=&gt; 转移。
以下是一些额外的注释供你参考：
Rust 拷贝像 C。每一个按值（by-value）使用一个值都是字节拷贝（通过 memcpy 浅拷贝），而不是语义上的拷贝或克隆。 如果想要让一个 POD 结构体变成不可拷贝的，你可以使用一个 NoCopy 标记，或者实现 Drop 特性（trait）。 转移之后，所有权就转移到了下一个所有者那。
资源回收 Rust 会在任何资源的所有权消失后立刻释放该资源，就这些，当：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://notes.0081800.xyz/articles/20200325182450_rust_borrow_and_lifetimes/" /><meta property="article:section" content="articles" />
<meta property="article:published_time" content="2020-03-25T00:00:00+08:00" />
<meta property="article:modified_time" content="2020-03-25T00:00:00+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Rust Borrow and Lifetimes"/>
<meta name="twitter:description" content="tags: Rust,Translate,Rust Wrapper Types 原文链接：Rust Borrow and Lifetimes。
Rust 是一门处于往 1.0 活跃开发的新语言（译注：1.0 早已发布，目前最新稳定版本 1.42）。 我必须再写一篇关于我为什么觉得 Rust 牛逼的新博客，但是今天我将关注在它的借用（borrow） 和生命周期（lifetimes）系统，这也是常常让包括我在内的 Rust 新手陷入困境的地方。这篇文章假设 你基本了解 Rust，如果还没推荐你先阅读指南和指针指南。
资源所有权和借用 Rust 通过一个难缠的（sophisticated）借用系统在不用 GC 的情况下达到内存安全。对于任何资源 （栈内存、堆内存、文件句柄等），他们都对应一个唯一的所有者（owner）在需要的情况下处理资源回收。 你可以通过 &amp; 或者 &amp;mut 创建一个新的绑定指向该资源，这被称之为借用或可变借用。编译器确保 所有的所有者（owners）和借用者（borrowers）行为正确。
拷贝和转移（Copy and move） 在我们开始进入借用系统之前，我们需要知道 Rust 如何处理拷贝和转移。这个 StackOverflow 答案非常值得一读。 基本上，在赋值和函数调用上：
如果值是可拷贝的（copyable）（仅涉及原始（primitive）类型，不涉及如内存或文件句柄的资源），编译器默认进行拷贝。 其他情况，编译器转移（moves）所有权（ownership）并使原来的绑定无效。 简而言之，POD（Plan Old Data） =&gt; 拷贝，Non-POD（线性类型（linear types））=&gt; 转移。
以下是一些额外的注释供你参考：
Rust 拷贝像 C。每一个按值（by-value）使用一个值都是字节拷贝（通过 memcpy 浅拷贝），而不是语义上的拷贝或克隆。 如果想要让一个 POD 结构体变成不可拷贝的，你可以使用一个 NoCopy 标记，或者实现 Drop 特性（trait）。 转移之后，所有权就转移到了下一个所有者那。
资源回收 Rust 会在任何资源的所有权消失后立刻释放该资源，就这些，当："/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://notes.0081800.xyz/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Rust Borrow and Lifetimes",
      "item": "https://notes.0081800.xyz/articles/20200325182450_rust_borrow_and_lifetimes/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Rust Borrow and Lifetimes",
  "name": "Rust Borrow and Lifetimes",
  "description": "tags: Rust,Translate,Rust Wrapper Types 原文链接：Rust Borrow and Lifetimes。\nRust 是一门处于往 1.0 活跃开发的新语言（译注：1.0 早已发布，目前最新稳定版本 1.42）。 我必须再写一篇关于我为什么觉得 Rust 牛逼的新博客，但是今天我将关注在它的借用（borrow） 和生命周期（lifetimes）系统，这也是常常让包括我在内的 Rust 新手陷入困境的地方。这篇文章假设 你基本了解 Rust，如果还没推荐你先阅读指南和指针指南。\n资源所有权和借用 Rust 通过一个难缠的（sophisticated）借用系统在不用 GC 的情况下达到内存安全。对于任何资源 （栈内存、堆内存、文件句柄等），他们都对应一个唯一的所有者（owner）在需要的情况下处理资源回收。 你可以通过 \u0026amp; 或者 \u0026amp;mut 创建一个新的绑定指向该资源，这被称之为借用或可变借用。编译器确保 所有的所有者（owners）和借用者（borrowers）行为正确。\n拷贝和转移（Copy and move） 在我们开始进入借用系统之前，我们需要知道 Rust 如何处理拷贝和转移。这个 StackOverflow 答案非常值得一读。 基本上，在赋值和函数调用上：\n如果值是可拷贝的（copyable）（仅涉及原始（primitive）类型，不涉及如内存或文件句柄的资源），编译器默认进行拷贝。 其他情况，编译器转移（moves）所有权（ownership）并使原来的绑定无效。 简而言之，POD（Plan Old Data） =\u0026gt; 拷贝，Non-POD（线性类型（linear types））=\u0026gt; 转移。\n以下是一些额外的注释供你参考：\nRust 拷贝像 C。每一个按值（by-value）使用一个值都是字节拷贝（通过 memcpy 浅拷贝），而不是语义上的拷贝或克隆。 如果想要让一个 POD 结构体变成不可拷贝的，你可以使用一个 NoCopy 标记，或者实现 Drop 特性（trait）。 转移之后，所有权就转移到了下一个所有者那。\n资源回收 Rust 会在任何资源的所有权消失后立刻释放该资源，就这些，当：",
  "keywords": [
    
  ],
  "articleBody": " tags: Rust,Translate,Rust Wrapper Types 原文链接：Rust Borrow and Lifetimes。\nRust 是一门处于往 1.0 活跃开发的新语言（译注：1.0 早已发布，目前最新稳定版本 1.42）。 我必须再写一篇关于我为什么觉得 Rust 牛逼的新博客，但是今天我将关注在它的借用（borrow） 和生命周期（lifetimes）系统，这也是常常让包括我在内的 Rust 新手陷入困境的地方。这篇文章假设 你基本了解 Rust，如果还没推荐你先阅读指南和指针指南。\n资源所有权和借用 Rust 通过一个难缠的（sophisticated）借用系统在不用 GC 的情况下达到内存安全。对于任何资源 （栈内存、堆内存、文件句柄等），他们都对应一个唯一的所有者（owner）在需要的情况下处理资源回收。 你可以通过 \u0026 或者 \u0026mut 创建一个新的绑定指向该资源，这被称之为借用或可变借用。编译器确保 所有的所有者（owners）和借用者（borrowers）行为正确。\n拷贝和转移（Copy and move） 在我们开始进入借用系统之前，我们需要知道 Rust 如何处理拷贝和转移。这个 StackOverflow 答案非常值得一读。 基本上，在赋值和函数调用上：\n如果值是可拷贝的（copyable）（仅涉及原始（primitive）类型，不涉及如内存或文件句柄的资源），编译器默认进行拷贝。 其他情况，编译器转移（moves）所有权（ownership）并使原来的绑定无效。 简而言之，POD（Plan Old Data） =\u003e 拷贝，Non-POD（线性类型（linear types））=\u003e 转移。\n以下是一些额外的注释供你参考：\nRust 拷贝像 C。每一个按值（by-value）使用一个值都是字节拷贝（通过 memcpy 浅拷贝），而不是语义上的拷贝或克隆。 如果想要让一个 POD 结构体变成不可拷贝的，你可以使用一个 NoCopy 标记，或者实现 Drop 特性（trait）。 转移之后，所有权就转移到了下一个所有者那。\n资源回收 Rust 会在任何资源的所有权消失后立刻释放该资源，就这些，当：\n所有者超出作用域，或 正在持有的所有者改变绑定（原始绑定变成 void）。 所有者和借用者的权限（privileges）和限制 这一节基于 Rust Guide 在权限（privileges）一部分提到拷贝和转移。\n所有者有一些权限。它可以：\n控制资源回收。 借出资源，不可变的（可多次借用）或可变的（只能独占），和 交出所有权（通过转移） 同时所有者也存在一些限制：\n不可变借用期间，所有者不能\na. 改变资源，或者\nb. 以可变的方式借出资源。\n可变借用期间所有者不能\na. 访问该资源，或者\nb. 再次借出该资源。\n借用者同时也有一些权限。除了访问或者更改借用的资源外，借用者也可以进一步借出（share the borrow）：\n不可变借用者可以借出（拷贝）不可变借用（译注：再次以不可变借用借出） 可变借用者可以交出（转移）可变借用。（可变引用默认使用转移。） 代码示例 关于借用我们已经聊的够多了，让我们一起来看一些代码吧（你可以通过 https://play.rust-lang.org 运行这些 Rust 代码。） 在下面所有的例子中，我们将使用不可拷贝的 struct Foo ，因为它包含了一个装箱（boxed）（堆分配）值。 使用不可拷贝资源可以限制相关操作，让我们更好的学习。\n对于每一个代码示例，我们还提供了一个“作用域图表”（scope chart）来展示所有者和借用者的作用域。 图表第一行的大括号和代码中的大括号一一对应。\n所有者在可变借用期间不能访问资源 如果我们将代码中的 println! 解除注释，代码将不能编译：\nstruct Foo { f: Box\u003cint\u003e, } fn main() { let mut a = Foo { f: box 0 }; // mutable borrow let x = \u0026mut a; // error: cannot borrow `a.f` as immutable because `a` is also borrowed as mutable // println!(\"{}\", a.f); } { a x * } owner a |_____| borrower x |___| x = \u0026mut a access a.f | error 这违反了所有者限制 #2(a)。如果我们将 let x = \u0026mut a; 在一个嵌套的代码块里：借用 在 println! 之前结束，这段代码将能正常工作：\nfn main() { let mut a = Foo { f: box 0 }; { // mutable borrow let x = \u0026mut a; // mutable borrow ends here } println!(\"{}\", a.f); } { a { x } * } owner a |_________| borrower x |_| x = \u0026mut a access a.f | OK 借用者可以转移可变借用到一个新的借用者 这段代码展示借用者的权限 #2: 可变借用 x 可以将所有权转移可变借用到一个新的借用者 y 。\nfn main() { let mut a = Foo { f: box 0 }; // mutable borrow let x = \u0026mut a; // move the mutable borrow to new borrower y let y = x; // error: use of moved value: `x.f` // println!(\"{}\", x.f); } { a x y * } owner a |_______| borrower x |_| x = \u0026mut a borrower y |___| y = x access x.f | error 转移之后，原始的借用者 x 不再能访问借用的资源。\n借用作用域（Borrow scope） 如果我们开始传递引用（ \u0026 和 \u0026mut）事情就开始变得有趣，同时也是 Rust 新手们开始困惑的地方。\n生命周期（Lifetime） 在整个借用过程中，知道借用者的借用什么时候开始和结束非常重要。在生命周期指南中是这样定义生命周期的：\nA lifetime is a static approximation of the span of execution during which the pointer is valid: it always corresponds to some expression or block within the program.\n生命周期是指针有效范围的静态近似值：它始终对应程序中的某些表达式或代码块。\n然而，我更喜欢使用 借用作用域（borrow scope） 这个术语去描述借用生效的作用域。请注意它不同于上面生命周期的定义。 （我第一次见到这个术语是在一个 Rust RFC 讨论 中，尽管我的定义可能会有所不同。）我会在稍后给出我为什么避免使用生命周期的原因。 现在我们先把生命周期放在一边。\n\u0026 = borrow 一些关于借用的事情：\n首先，只需要记住 \u0026 = 借用， \u0026mut = 可变借用。任何地方你看到一个 \u0026 ，那就是一个借用。\n其次，当一个 \u0026 出现在任何结构体中（在它的字段中）或者函数_闭包（返回值或者捕获的引用），结构体_函数/闭包就是一个借用者， 并且应用所有的借用规则。\n再次，对于每一个借用，都存在一个所有者和一个或多个借用者。\n扩展借用作用域 一些关于借用作用域的事情：\n首先，一个借用作用域：\n是一个借用生效的范围，并且 不一定是借用者的词法作用域，因为借用者可以扩展借用作用域（参见下面）。 其次，借用者在赋值或者函数调用中可以通过拷贝（不可变借用）或者转移（可变借用）扩展借用作用域。 接收者（receiver）（可以是新的绑定、结构体、函数或者闭包）变成新的借用者。\n再次，借用作用域是所有借用者作用域的并集，并且被借用的资源必须在整个借用作用域里有效。\n借用公式 根据最后一点，我们得到一个借用公式：\n资源作用域 \u003e= 借用作用域 = 所有借用者作用域的并集。\n代码示例 让我们看一些扩展作用域的代码示例。结构体 struct Foo 和前面的一样：\nfn main() { let mut a = Foo { f: box 0 }; let y: \u0026Foo; if false { // borrow let x = \u0026a; // share the borrow with new borrower y, hence extend the borrow scope y = x; } // error: cannot assign to `a.f` because it is borrowed // a.f = box 1; } { a { x y } * } resource a |___________| borrower x |___| x = \u0026a borrower y |_____| y = x borrow scope |=======| mutate a.f | error 即使借用发生在 if 代码块之内并且借用者 x 在 if 代码块之后超出作用域，它已经通过赋值 y=x; 扩展了借用作用域， 所以存在两个借用者： x 和 y 。根据借用公式：借用作用域是借用者 x 和借用者 y 作用域的并集： 范围开始第一次借用于 let x = \u0026a; 直到 main 代码块的结尾。（注意绑定 y 在 y=x; 之前不是借用者。）\n你可能注意到了由于条件永远是 false if 代码块永远不会执行，但是编译器始终拒绝资源所有者 a 去访问 它的资源。这是因为所有的借用检查发生在编译期，这样程序运行时就不需要做任何事情。\n借用多个资源 目前为止我们只关注借用单个资源。借用者可以借用多个资源吗？当然！比如一个函数可以接受两个引用然后 基于一些情况返回其中一个，e.g. 其中字段值比较大的那一个。\nfn max(x: \u0026Foo, y: \u0026Foo) -\u003e \u0026Foo max 函数返回一个 \u0026 指针，因此它是一个借用者。返回的结果可以是输入参数的任意一个，所以它借用了 两鞥额资源。\n命名借用作用域（Named borrow scope） 当存在多个 \u0026 指针作为输入，我们需要使用 命名生命周期（named lifetimes） 指定它们之间的关系， 参见 Lifetimes Guide。但现在，让我们叫它们 命名借用作用域（named borrow scopes） 。\n上面的代码没有使用 命名生命周期 指定它们之间的关系是不会通过编译器的，i.e. 哪些借用者 分组（grouped） 到哪个借用作用域。下面的实现是合法的：\nfn max\u003c'a\u003e(x: \u0026'a Foo, y: \u0026'a Foo) -\u003e \u0026'a Foo { if x.f \u003e y.f { x } else { y } } (All resources and borrowers are grouped in borrow scope 'a.) max( { } ) resource *x \u003c--------------\u003e resource *y \u003c--------------\u003e borrow scope 'a \u003c==============\u003e borrower x |___| borrower y |___| return value |___| pass to the caller 在这个函数中，我们有一个借用作用域 'a 和三个借用者：两个输入参数和函数返回结果。 前面提到的借用公式依然生效，但是现在每个被借用的资源必须满足公式。参见下面的例子：\n代码示例 在接下来的代码中，我们来使用上面的 max 函数在 a 和 b 之间选择一个更大 Foo ：\nfn main() { let a = Foo { f: box 1 }; let y: \u0026Foo; if false { let b = Foo { f: box 0 }; let x = max(\u0026a, \u0026b); // error: `b` does not live long enough // y = x; } } { a { b x ( ) y } } resource a |________________| pass resource b |__________| fail borrow scope |==========| temp borrower |_| \u0026a temp borrower |_| \u0026b borrower x |________| x = max(\u0026a, \u0026b) borrower y |___| y = x 直到 let x = max(\u0026a, \u0026b) 都一些正常，因为 \u0026a 和 \u0026b 都是尽在表达式中有效的临时引用， 并且第三个借用 x 借用了两个资源（不管最终是 a 或 b ，对于借用检查器而言它都借用了）直到 if 块结束，所以借用作用域是从 let x = max(\u0026a, \u0026b); 到 if 块结尾。两个资源 a 和 b 在整个借用作用域 都有效,因此满足借用公式。\n现在如果我们解除最后一个赋值 y = x; 的注释， y 变成第四个借用者，然后借用作用域被扩展到 main 块的结尾，导致资源 b 不能满足公式。\n结构体作为借用者 除了函数和闭包之外，一个结构体也可以通过其字段存储多个引用来借用多个资源。我们通过下面的一些例子 来看看借用公式如何生效的。我们来使用 Link 结构体来保存一个引用（不可变借用）：\nstruct Link\u003c'a\u003e { link: \u0026'a Foo, } 结构体借用多个资源 即使只有一个字段，结构体 Link 也可以借用多个资源：\nfn main() { let a = Foo { f: box 0 }; let mut x = Link { link: \u0026a }; if false { let b = Foo { f: box 1 }; // error: `b` does not live long enough // x.link = \u0026b; } } { a x { b * } } resource a |___________| pass resource b |___| fail borrow scope |=========| borrower x |_________| x.link = \u0026a borrower x |___| x.link = \u0026b 在上面例子中，借用者 x 从所有者 a 借用资源，借用作用域到 main 块的结尾。So far so good。 如果我们解除最后一个赋值 x.link = \u0026b; 的注释， x 也尝试从所有者 b 借用资源，这会让资源 b 不能满足借用公式。\n没有返回值的函数扩展借用作用域 一个没有返回值的函数同样也可以通过输出参数能扩展借用作用域。例如，这个函数 store_foo 接受一个 Link 的可变引用，然后存储一个引用（不可变借用）到 Foo 里：\nfn store_foo\u003c'a'\u003e(x: \u0026mut Link\u003c'a\u003e, y: \u0026'a Foo) { x.link = y; } 在接下来的代码中，被 a 所有的资源是被借用资源； Link 结构体被借用者 x 可变的引用着（i.e. *x 是借用者）； 借用作用域直到 main 块的结尾。\nfn main() { let a = Foo { f: box 0 }; let x = \u0026mut Link { link: \u0026a }; if false { let b = Foo { f: box 1 }; // store_foo(x, \u0026b); } } { a x { b * } } resource a |___________| pass resource b |___| fail borrow scope |=========| borrower *x |_________| x.link = \u0026a borrower *x |___| x.link = \u0026b 如果我们解除最后一个函数调用 store_foo(x, \u0026b); ,这个函数将会尝试将 \u0026b 存储到 x.link ， 将资源 b 作为另外一个被借用的资源，由于 b 的作用域没有覆盖整个借用作用域，导致不满足借用公式。\n多个借用作用域 一个函数中可以存在多个借用作用域。例如：\nfn superstore_foo\u003c'a, 'b\u003e(x: \u0026mut Link\u003c'a\u003e, y: \u0026'a Foo, x2: \u0026mut Link\u003c'b\u003e, y2: \u0026'b Foo) { x.link = y; x2.link = y2; } 这个的函数（可能不是特别有用）中，涉及两个不同的借用作用域。每个借用作用域都有它们自己的作用域公式要满足。\n为什么生命周期会造成困惑 最后，我想解释一下为什么我认为 Rust 借用系统使用 生命周期 术语会造成困惑（同时避免在这片博文中使用它）。\n当我们讨论借用时会涉及到不同类型的“生命周期”：\nA. 资源所有者的生命周期（或者 被所有/被借用 资源 B. 被借用的生命周期，i.e. 从开始借用到最后返还 C. 每一个独立的借用者或被借用的指针的生命周期\n当有人说“生命周期”，它可以指上面的任何一个。如果涉及多个资源和借用者就会变的更加困惑。 比如，在函数或者结构体生命中一个“命名的生命周期”指哪个？是 A、B 或者 C？\n在我们的前一个 max 函数中：\nfn max\u003c'a\u003e(x: \u0026'a Foo, y: \u0026'a Foo) -\u003e \u0026'a Foo { if x.f \u003e y.f { x } else { y } } 生命周期 'a 的意义是什么？它不应该是 A，因为涉及两个资源并且他们有不同的生命周期。也不可能是 C， 因为有三个借用者： x 、 y 和函数的返回值，并且他们也都有不同的生命周期。它是 B 吗？可能。 但是整个借用作用域并不是一个具体的对象，它怎么能有一个“生命周期”呢？称它为生命周期就会造成困惑。\n另一种说法是它意味着对被借用资源的最小生命周期要求。一定程度上是有道理的， 但是我们怎么称呼最小生命周期要求“生命周期”？\n所有权/借用概念自身已经够复杂了。我会说：对术语“生命周期”的困惑对学习这个概念造成了更多的莫名其妙。\nP.S. 使用上面定义的 A、B 和 C，借用公式变成：\nA \u003e= B = C_1,UC_2U…UC_n\n学习 Rust 是值得的！ 尽管借用和所有权可能让你花一些时间来掌握（to grok），但是是一个非常有趣的学习。Rust 尝试不用 GC 来实现内存安全，并且目前来看做的非常好。一些人说他们通过学习 Haskell 改变了他们编程的方式。 我认为Rust 同样也值得你学习。\n希望这篇博文能提供一些帮助。\n",
  "wordCount" : "1120",
  "inLanguage": "en",
  "datePublished": "2020-03-25T00:00:00+08:00",
  "dateModified": "2020-03-25T00:00:00+08:00",
  "author":[{
    "@type": "Person",
    "name": "Gray King"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://notes.0081800.xyz/articles/20200325182450_rust_borrow_and_lifetimes/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Taking Smart Notes With Org-mode",
    "logo": {
      "@type": "ImageObject",
      "url": "https://notes.0081800.xyz/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://notes.0081800.xyz/" accesskey="h" title="Taking Smart Notes With Org-mode (Alt + H)">Taking Smart Notes With Org-mode</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://notes.0081800.xyz/articles/" title="Articles">
                    <span>Articles</span>
                </a>
            </li>
            <li>
                <a href="https://notes.0081800.xyz/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://notes.0081800.xyz/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://notes.0081800.xyz/">Home</a>&nbsp;»&nbsp;<a href="https://notes.0081800.xyz/articles/">Articles</a></div>
    <h1 class="post-title">
      Rust Borrow and Lifetimes
    </h1>
    <div class="post-meta"><span title='2020-03-25 00:00:00 +0800 +0800'>March 25, 2020</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Gray King

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e8%b5%84%e6%ba%90%e6%89%80%e6%9c%89%e6%9d%83%e5%92%8c%e5%80%9f%e7%94%a8" aria-label="资源所有权和借用">资源所有权和借用</a></li>
                <li>
                    <a href="#%e6%8b%b7%e8%b4%9d%e5%92%8c%e8%bd%ac%e7%a7%bb-copy-and-move" aria-label="拷贝和转移（Copy and move）">拷贝和转移（Copy and move）</a></li>
                <li>
                    <a href="#%e8%b5%84%e6%ba%90%e5%9b%9e%e6%94%b6" aria-label="资源回收">资源回收</a></li>
                <li>
                    <a href="#%e6%89%80%e6%9c%89%e8%80%85%e5%92%8c%e5%80%9f%e7%94%a8%e8%80%85%e7%9a%84%e6%9d%83%e9%99%90-privileges-%e5%92%8c%e9%99%90%e5%88%b6" aria-label="所有者和借用者的权限（privileges）和限制">所有者和借用者的权限（privileges）和限制</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e7%a4%ba%e4%be%8b" aria-label="代码示例">代码示例</a><ul>
                        
                <li>
                    <a href="#%e6%89%80%e6%9c%89%e8%80%85%e5%9c%a8%e5%8f%af%e5%8f%98%e5%80%9f%e7%94%a8%e6%9c%9f%e9%97%b4%e4%b8%8d%e8%83%bd%e8%ae%bf%e9%97%ae%e8%b5%84%e6%ba%90" aria-label="所有者在可变借用期间不能访问资源">所有者在可变借用期间不能访问资源</a></li>
                <li>
                    <a href="#%e5%80%9f%e7%94%a8%e8%80%85%e5%8f%af%e4%bb%a5%e8%bd%ac%e7%a7%bb%e5%8f%af%e5%8f%98%e5%80%9f%e7%94%a8%e5%88%b0%e4%b8%80%e4%b8%aa%e6%96%b0%e7%9a%84%e5%80%9f%e7%94%a8%e8%80%85" aria-label="借用者可以转移可变借用到一个新的借用者">借用者可以转移可变借用到一个新的借用者</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%80%9f%e7%94%a8%e4%bd%9c%e7%94%a8%e5%9f%9f-borrow-scope" aria-label="借用作用域（Borrow scope）">借用作用域（Borrow scope）</a><ul>
                        
                <li>
                    <a href="#%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f-lifetime" aria-label="生命周期（Lifetime）">生命周期（Lifetime）</a></li>
                <li>
                    <a href="#and-borrow" aria-label="&amp;amp; = borrow">&amp; = borrow</a></li>
                <li>
                    <a href="#%e6%89%a9%e5%b1%95%e5%80%9f%e7%94%a8%e4%bd%9c%e7%94%a8%e5%9f%9f" aria-label="扩展借用作用域">扩展借用作用域</a></li>
                <li>
                    <a href="#%e5%80%9f%e7%94%a8%e5%85%ac%e5%bc%8f" aria-label="借用公式">借用公式</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e7%a4%ba%e4%be%8b" aria-label="代码示例">代码示例</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%80%9f%e7%94%a8%e5%a4%9a%e4%b8%aa%e8%b5%84%e6%ba%90" aria-label="借用多个资源">借用多个资源</a><ul>
                        
                <li>
                    <a href="#%e5%91%bd%e5%90%8d%e5%80%9f%e7%94%a8%e4%bd%9c%e7%94%a8%e5%9f%9f-named-borrow-scope" aria-label="命名借用作用域（Named borrow scope）">命名借用作用域（Named borrow scope）</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e7%a4%ba%e4%be%8b" aria-label="代码示例">代码示例</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%bb%93%e6%9e%84%e4%bd%93%e4%bd%9c%e4%b8%ba%e5%80%9f%e7%94%a8%e8%80%85" aria-label="结构体作为借用者">结构体作为借用者</a><ul>
                        
                <li>
                    <a href="#%e7%bb%93%e6%9e%84%e4%bd%93%e5%80%9f%e7%94%a8%e5%a4%9a%e4%b8%aa%e8%b5%84%e6%ba%90" aria-label="结构体借用多个资源">结构体借用多个资源</a></li>
                <li>
                    <a href="#%e6%b2%a1%e6%9c%89%e8%bf%94%e5%9b%9e%e5%80%bc%e7%9a%84%e5%87%bd%e6%95%b0%e6%89%a9%e5%b1%95%e5%80%9f%e7%94%a8%e4%bd%9c%e7%94%a8%e5%9f%9f" aria-label="没有返回值的函数扩展借用作用域">没有返回值的函数扩展借用作用域</a></li>
                <li>
                    <a href="#%e5%a4%9a%e4%b8%aa%e5%80%9f%e7%94%a8%e4%bd%9c%e7%94%a8%e5%9f%9f" aria-label="多个借用作用域">多个借用作用域</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e4%bc%9a%e9%80%a0%e6%88%90%e5%9b%b0%e6%83%91" aria-label="为什么生命周期会造成困惑">为什么生命周期会造成困惑</a></li>
                <li>
                    <a href="#%e5%ad%a6%e4%b9%a0-rust-%e6%98%af%e5%80%bc%e5%be%97%e7%9a%84" aria-label="学习 Rust 是值得的！">学习 Rust 是值得的！</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><ul>
<li>tags: <a href="/topics/20200307191429_rust/">Rust</a>,<a href="/topics/20200309112105_translate/">Translate</a>,<a href="/notes/20200325165657_rust_wrapper_types/">Rust Wrapper Types</a></li>
</ul>
<p>原文链接：<a href="http://arthurtw.github.io/2014/11/30/rust-borrow-lifetimes.html">Rust Borrow and Lifetimes</a>。</p>
<p>Rust 是一门处于往 1.0 活跃开发的新语言（译注：1.0 早已发布，目前最新稳定版本 <a href="https://github.com/rust-lang/rust/releases/tag/1.42.0">1.42</a>）。
我必须再写一篇关于我为什么觉得 Rust 牛逼的新博客，但是今天我将关注在它的借用（borrow）
和生命周期（lifetimes）系统，这也是常常让包括我在内的 Rust 新手陷入困境的地方。这篇文章假设
你基本了解 Rust，如果还没推荐你先阅读<a href="http://doc.rust-lang.org/guide.html">指南</a>和<a href="http://doc.rust-lang.org/guide-pointers.html">指针指南</a>。</p>
<h2 id="资源所有权和借用">资源所有权和借用<a hidden class="anchor" aria-hidden="true" href="#资源所有权和借用">#</a></h2>
<p>Rust 通过一个难缠的（sophisticated）借用系统在不用 GC 的情况下达到内存安全。对于任何资源
（栈内存、堆内存、文件句柄等），他们都对应一个唯一的所有者（owner）在需要的情况下处理资源回收。
你可以通过 <code>&amp;</code> 或者 <code>&amp;mut</code> 创建一个新的绑定指向该资源，这被称之为借用或可变借用。编译器确保
所有的所有者（owners）和借用者（borrowers）行为正确。</p>
<h2 id="拷贝和转移-copy-and-move">拷贝和转移（Copy and move）<a hidden class="anchor" aria-hidden="true" href="#拷贝和转移-copy-and-move">#</a></h2>
<p>在我们开始进入借用系统之前，我们需要知道 Rust 如何处理拷贝和转移。这个 <a href="https://stackoverflow.com/questions/24253344/is-it-possible-to-make-a-type-only-movable-and-not-copyable/24253573#24253573">StackOverflow 答案</a>非常值得一读。
基本上，在赋值和函数调用上：</p>
<ol>
<li>如果值是可拷贝的（copyable）（仅涉及原始（primitive）类型，不涉及如内存或文件句柄的资源），编译器默认进行拷贝。</li>
<li>其他情况，编译器转移（moves）所有权（ownership）并使原来的绑定无效。</li>
</ol>
<p>简而言之，POD（Plan Old Data） =&gt; 拷贝，Non-POD（线性类型（linear types））=&gt; 转移。</p>
<p>以下是一些额外的注释供你参考：</p>
<ul>
<li>Rust 拷贝像 C。每一个按值（by-value）使用一个值都是字节拷贝（通过 <code>memcpy</code> 浅拷贝），而不是语义上的拷贝或克隆。</li>
<li>如果想要让一个 POD 结构体变成不可拷贝的，你可以使用一个 <a href="http://doc.rust-lang.org/std/kinds/marker/struct.NoCopy.html">NoCopy</a> 标记，或者实现 <a href="http://doc.rust-lang.org/std/ops/trait.Drop.html">Drop</a> 特性（trait）。</li>
</ul>
<p>转移之后，所有权就转移到了下一个所有者那。</p>
<h2 id="资源回收">资源回收<a hidden class="anchor" aria-hidden="true" href="#资源回收">#</a></h2>
<p>Rust 会在任何资源的所有权消失后立刻释放该资源，就这些，当：</p>
<ol>
<li>所有者超出作用域，或</li>
<li>正在持有的所有者改变绑定（原始绑定变成 void）。</li>
</ol>
<h2 id="所有者和借用者的权限-privileges-和限制">所有者和借用者的权限（privileges）和限制<a hidden class="anchor" aria-hidden="true" href="#所有者和借用者的权限-privileges-和限制">#</a></h2>
<p>这一节基于 <a href="http://doc.rust-lang.org/guide.html">Rust Guide</a> 在权限（privileges）一部分提到拷贝和转移。</p>
<p>所有者有一些权限。它可以：</p>
<ol>
<li>控制资源回收。</li>
<li>借出资源，不可变的（可多次借用）或可变的（只能独占），和</li>
<li>交出所有权（通过转移）</li>
</ol>
<p>同时所有者也存在一些限制：</p>
<ol>
<li>
<p>不可变借用期间，所有者不能</p>
<p>a. 改变资源，或者</p>
<p>b. 以可变的方式借出资源。</p>
</li>
<li>
<p>可变借用期间所有者不能</p>
<p>a. 访问该资源，或者</p>
<p>b. 再次借出该资源。</p>
</li>
</ol>
<p>借用者同时也有一些权限。除了访问或者更改借用的资源外，借用者也可以进一步借出（share the borrow）：</p>
<ol>
<li>不可变借用者可以借出（拷贝）不可变借用（译注：再次以不可变借用借出）</li>
<li>可变借用者可以交出（转移）可变借用。（可变引用默认使用转移。）</li>
</ol>
<h2 id="代码示例">代码示例<a hidden class="anchor" aria-hidden="true" href="#代码示例">#</a></h2>
<p>关于借用我们已经聊的够多了，让我们一起来看一些代码吧（你可以通过 <a href="https://play.rust-lang.org">https://play.rust-lang.org</a> 运行这些 Rust 代码。）
在下面所有的例子中，我们将使用不可拷贝的 <code>struct Foo</code> ，因为它包含了一个装箱（boxed）（堆分配）值。
使用不可拷贝资源可以限制相关操作，让我们更好的学习。</p>
<p>对于每一个代码示例，我们还提供了一个“作用域图表”（scope chart）来展示所有者和借用者的作用域。
图表第一行的大括号和代码中的大括号一一对应。</p>
<h3 id="所有者在可变借用期间不能访问资源">所有者在可变借用期间不能访问资源<a hidden class="anchor" aria-hidden="true" href="#所有者在可变借用期间不能访问资源">#</a></h3>
<p>如果我们将代码中的 <code>println!</code> 解除注释，代码将不能编译：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>		f: Box<span style="color:#f92672">&lt;</span>int<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> a <span style="color:#f92672">=</span> Foo { f: <span style="color:#a6e22e">box</span> <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// mutable borrow
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> a;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// error: cannot borrow `a.f` as immutable because `a` is also borrowed as mutable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// println!(&#34;{}&#34;, a.f);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">					 { a x * }
	 owner a   |_____|
borrower x     |___| x = &amp;mut a
access a.f       |   error
</code></pre><p>这违反了所有者限制 #2(a)。如果我们将 <code>let x = &amp;mut a;</code> 在一个嵌套的代码块里：借用
在 <code>println!</code> 之前结束，这段代码将能正常工作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> a <span style="color:#f92672">=</span> Foo { f: <span style="color:#a6e22e">box</span> <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// mutable borrow
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> a;
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// mutable borrow ends here
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		}
</span></span><span style="display:flex;"><span>		println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, a.f);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">					 { a { x } * }
	 owner a   |_________|
borrower x       |_|     x = &amp;mut a
access a.f           |   OK
</code></pre><h3 id="借用者可以转移可变借用到一个新的借用者">借用者可以转移可变借用到一个新的借用者<a hidden class="anchor" aria-hidden="true" href="#借用者可以转移可变借用到一个新的借用者">#</a></h3>
<p>这段代码展示借用者的权限 #2: 可变借用 <code>x</code> 可以将所有权转移可变借用到一个新的借用者 <code>y</code> 。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> a <span style="color:#f92672">=</span> Foo { f: <span style="color:#a6e22e">box</span> <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// mutable borrow
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> a;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// move the mutable borrow to new borrower y
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">let</span> y <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// error: use of moved value: `x.f`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// println!(&#34;{}&#34;, x.f);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">					 { a x y * }
	 owner a   |_______|
borrower x     |_|     x = &amp;mut a
borrower y       |___| y = x
access x.f         |   error
</code></pre><p>转移之后，原始的借用者 <code>x</code> 不再能访问借用的资源。</p>
<h2 id="借用作用域-borrow-scope">借用作用域（Borrow scope）<a hidden class="anchor" aria-hidden="true" href="#借用作用域-borrow-scope">#</a></h2>
<p>如果我们开始传递引用（ <code>&amp;</code> 和 <code>&amp;mut</code>）事情就开始变得有趣，同时也是 Rust 新手们开始困惑的地方。</p>
<h3 id="生命周期-lifetime">生命周期（Lifetime）<a hidden class="anchor" aria-hidden="true" href="#生命周期-lifetime">#</a></h3>
<p>在整个借用过程中，知道借用者的借用什么时候开始和结束非常重要。在<a href="http://doc.rust-lang.org/guide-lifetimes.html">生命周期指南</a>中是这样定义生命周期的：</p>
<blockquote>
<p>A lifetime is a static approximation of the span of execution during which the pointer is valid: it always corresponds to some expression or block within the program.</p>
</blockquote>
<!-- raw HTML omitted -->
<blockquote>
<p>生命周期是指针有效范围的静态近似值：它始终对应程序中的某些表达式或代码块。</p>
</blockquote>
<p>然而，我更喜欢使用 <strong>借用作用域（borrow scope）</strong> 这个术语去描述借用生效的作用域。请注意它不同于上面生命周期的定义。
（我第一次见到这个术语是在一个 Rust <a href="https://github.com/rust-lang/rfcs/pull/431">RFC 讨论</a> 中，尽管我的定义可能会有所不同。）我会在稍后给出我为什么避免使用生命周期的原因。
现在我们先把生命周期放在一边。</p>
<h3 id="and-borrow">&amp; = borrow<a hidden class="anchor" aria-hidden="true" href="#and-borrow">#</a></h3>
<p>一些关于借用的事情：</p>
<p>首先，只需要记住 <code>&amp;</code> = 借用， <code>&amp;mut</code> = 可变借用。任何地方你看到一个 <code>&amp;</code> ，那就是一个借用。</p>
<p>其次，当一个 <code>&amp;</code> 出现在任何结构体中（在它的字段中）或者函数_闭包（返回值或者捕获的引用），结构体_函数/闭包就是一个借用者，
并且应用所有的借用规则。</p>
<p>再次，对于每一个借用，都存在一个所有者和一个或多个借用者。</p>
<h3 id="扩展借用作用域">扩展借用作用域<a hidden class="anchor" aria-hidden="true" href="#扩展借用作用域">#</a></h3>
<p>一些关于借用作用域的事情：</p>
<p>首先，一个借用作用域：</p>
<ul>
<li>是一个借用生效的范围，并且</li>
<li>不一定是借用者的词法作用域，因为借用者可以扩展借用作用域（参见下面）。</li>
</ul>
<p>其次，借用者在赋值或者函数调用中可以通过拷贝（不可变借用）或者转移（可变借用）扩展借用作用域。
接收者（receiver）（可以是新的绑定、结构体、函数或者闭包）变成新的借用者。</p>
<p>再次，借用作用域是所有借用者作用域的并集，并且被借用的资源必须在整个借用作用域里有效。</p>
<h3 id="借用公式">借用公式<a hidden class="anchor" aria-hidden="true" href="#借用公式">#</a></h3>
<p>根据最后一点，我们得到一个借用公式：</p>
<blockquote>
<p>资源作用域 &gt;= 借用作用域 = 所有借用者作用域的并集。</p>
</blockquote>
<h3 id="代码示例">代码示例<a hidden class="anchor" aria-hidden="true" href="#代码示例">#</a></h3>
<p>让我们看一些扩展作用域的代码示例。结构体 <code>struct Foo</code> 和前面的一样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> a <span style="color:#f92672">=</span> Foo { f: <span style="color:#a6e22e">box</span> <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> y: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Foo</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">false</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// borrow
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>a;
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// share the borrow with new borrower y, hence extend the borrow scope
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				y <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// error: cannot assign to `a.f` because it is borrowed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// a.f = box 1;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">						 { a { x y } * }
	resource a   |___________|
	borrower x       |___|     x = &amp;a
	borrower y         |_____| y = x
borrow scope       |=======|
	mutate a.f             |   error
</code></pre><p>即使借用发生在 <code>if</code> 代码块之内并且借用者 <code>x</code> 在 <code>if</code> 代码块之后超出作用域，它已经通过赋值 <code>y=x;</code> 扩展了借用作用域，
所以存在两个借用者： <code>x</code> 和 <code>y</code> 。根据借用公式：借用作用域是借用者 <code>x</code> 和借用者 <code>y</code> 作用域的并集：
范围开始第一次借用于 <code>let x = &amp;a;</code> 直到 <code>main</code> 代码块的结尾。（注意绑定 <code>y</code> 在 <code>y=x;</code> 之前不是借用者。）</p>
<p>你可能注意到了由于条件永远是 false <code>if</code> 代码块永远不会执行，但是编译器始终拒绝资源所有者 <code>a</code> 去访问
它的资源。这是因为所有的借用检查发生在编译期，这样程序运行时就不需要做任何事情。</p>
<h2 id="借用多个资源">借用多个资源<a hidden class="anchor" aria-hidden="true" href="#借用多个资源">#</a></h2>
<p>目前为止我们只关注借用单个资源。借用者可以借用多个资源吗？当然！比如一个函数可以接受两个引用然后
基于一些情况返回其中一个，e.g. 其中字段值比较大的那一个。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">max</span>(x: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Foo</span>, y: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Foo</span>) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Foo</span>
</span></span></code></pre></div><p><code>max</code> 函数返回一个 <code>&amp;</code> 指针，因此它是一个借用者。返回的结果可以是输入参数的任意一个，所以它借用了
两鞥额资源。</p>
<h3 id="命名借用作用域-named-borrow-scope">命名借用作用域（Named borrow scope）<a hidden class="anchor" aria-hidden="true" href="#命名借用作用域-named-borrow-scope">#</a></h3>
<p>当存在多个 <code>&amp;</code> 指针作为输入，我们需要使用 <strong>命名生命周期（named lifetimes）</strong> 指定它们之间的关系，
参见 <a href="http://doc.rust-lang.org/guide-lifetimes.html#named-lifetimes">Lifetimes Guide</a>。但现在，让我们叫它们 <strong>命名借用作用域（named borrow scopes）</strong> 。</p>
<p>上面的代码没有使用 <strong>命名生命周期</strong> 指定它们之间的关系是不会通过编译器的，i.e. 哪些借用者 <strong>分组（grouped）</strong>
到哪个借用作用域。下面的实现是合法的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">max</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span>(x: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#a6e22e">Foo</span>, y: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#a6e22e">Foo</span>) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> x.f <span style="color:#f92672">&gt;</span> y.f { x } <span style="color:#66d9ef">else</span> { y }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">(All resources and borrowers are grouped in borrow scope &#39;a.)
									max( {   } )
		resource *x &lt;--------------&gt;
		resource *y &lt;--------------&gt;
borrow scope &#39;a &lt;==============&gt;
		 borrower x        |___|
		 borrower y        |___|
	 return value          |___|   pass to the caller
</code></pre><p>在这个函数中，我们有一个借用作用域 <code>'a</code> 和三个借用者：两个输入参数和函数返回结果。
前面提到的借用公式依然生效，但是现在每个被借用的资源必须满足公式。参见下面的例子：</p>
<h3 id="代码示例">代码示例<a hidden class="anchor" aria-hidden="true" href="#代码示例">#</a></h3>
<p>在接下来的代码中，我们来使用上面的 <code>max</code> 函数在 <code>a</code> 和 <code>b</code> 之间选择一个更大 <code>Foo</code> ：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> Foo { f: <span style="color:#a6e22e">box</span> <span style="color:#ae81ff">1</span> };
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> y: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Foo</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">false</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> Foo { f: <span style="color:#a6e22e">box</span> <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> max(<span style="color:#f92672">&amp;</span>a, <span style="color:#f92672">&amp;</span>b);
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// error: `b` does not live long enough
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#75715e">// y = x;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">							{ a { b x (  ) y } }
	 resource a   |________________| pass
	 resource b       |__________|   fail
 borrow scope         |==========|
temp borrower            |_|       &amp;a
temp borrower            |_|       &amp;b
	 borrower x         |________|   x = max(&amp;a, &amp;b)
	 borrower y                |___| y = x
</code></pre><p>直到 <code>let x = max(&amp;a, &amp;b)</code> 都一些正常，因为 <code>&amp;a</code> 和 <code>&amp;b</code> 都是尽在表达式中有效的临时引用，
并且第三个借用 <code>x</code> 借用了两个资源（不管最终是 <code>a</code> 或 <code>b</code> ，对于借用检查器而言它都借用了）直到 <code>if</code>
块结束，所以借用作用域是从 <code>let x = max(&amp;a, &amp;b);</code> 到 <code>if</code> 块结尾。两个资源 <code>a</code> 和 <code>b</code> 在整个借用作用域
都有效,因此满足借用公式。</p>
<p>现在如果我们解除最后一个赋值 <code>y = x;</code> 的注释， <code>y</code> 变成第四个借用者，然后借用作用域被扩展到 <code>main</code>
块的结尾，导致资源 <code>b</code> 不能满足公式。</p>
<h2 id="结构体作为借用者">结构体作为借用者<a hidden class="anchor" aria-hidden="true" href="#结构体作为借用者">#</a></h2>
<p>除了函数和闭包之外，一个结构体也可以通过其字段存储多个引用来借用多个资源。我们通过下面的一些例子
来看看借用公式如何生效的。我们来使用 <code>Link</code> 结构体来保存一个引用（不可变借用）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Link</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	link: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#a6e22e">Foo</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="结构体借用多个资源">结构体借用多个资源<a hidden class="anchor" aria-hidden="true" href="#结构体借用多个资源">#</a></h3>
<p>即使只有一个字段，结构体 <code>Link</code> 也可以借用多个资源：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> Foo { f: <span style="color:#a6e22e">box</span> <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> x <span style="color:#f92672">=</span> Link { link: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">a</span> };
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">false</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> Foo { f: <span style="color:#a6e22e">box</span> <span style="color:#ae81ff">1</span> };
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// error: `b` does not live long enough
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#75715e">// x.link = &amp;b;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">						 { a x { b * } }
	resource a   |___________| pass
	resource b         |___|   fail
borrow scope     |=========|
	borrower x     |_________| x.link = &amp;a
	borrower x           |___| x.link = &amp;b
</code></pre><p>在上面例子中，借用者 <code>x</code> 从所有者 <code>a</code> 借用资源，借用作用域到 <code>main</code> 块的结尾。So far so good。
如果我们解除最后一个赋值 <code>x.link = &amp;b;</code> 的注释， <code>x</code> 也尝试从所有者 <code>b</code> 借用资源，这会让资源 <code>b</code>
不能满足借用公式。</p>
<h3 id="没有返回值的函数扩展借用作用域">没有返回值的函数扩展借用作用域<a hidden class="anchor" aria-hidden="true" href="#没有返回值的函数扩展借用作用域">#</a></h3>
<p>一个没有返回值的函数同样也可以通过输出参数能扩展借用作用域。例如，这个函数 <code>store_foo</code> 接受一个
<code>Link</code> 的可变引用，然后存储一个引用（不可变借用）到 <code>Foo</code> 里：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">store_foo</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">&gt;</span>(x: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Link<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span>, y: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#a6e22e">Foo</span>) {
</span></span><span style="display:flex;"><span>	x.link <span style="color:#f92672">=</span> y;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在接下来的代码中，被 <code>a</code> 所有的资源是被借用资源； <code>Link</code> 结构体被借用者 <code>x</code> 可变的引用着（i.e. <code>*x</code> 是借用者）；
借用作用域直到 <code>main</code> 块的结尾。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> Foo { f: <span style="color:#a6e22e">box</span> <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> Link { link: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">a</span> };
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">false</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> Foo { f: <span style="color:#a6e22e">box</span> <span style="color:#ae81ff">1</span> };
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// store_foo(x, &amp;b);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">						 { a x { b * } }
	resource a   |___________| pass
	resource b         |___|   fail
borrow scope     |=========|
 borrower *x     |_________| x.link = &amp;a
 borrower *x           |___| x.link = &amp;b
</code></pre><p>如果我们解除最后一个函数调用 <code>store_foo(x, &amp;b);</code> ,这个函数将会尝试将 <code>&amp;b</code> 存储到 <code>x.link</code> ，
将资源 <code>b</code> 作为另外一个被借用的资源，由于 <code>b</code> 的作用域没有覆盖整个借用作用域，导致不满足借用公式。</p>
<h3 id="多个借用作用域">多个借用作用域<a hidden class="anchor" aria-hidden="true" href="#多个借用作用域">#</a></h3>
<p>一个函数中可以存在多个借用作用域。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">superstore_foo</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span>, <span style="color:#a6e22e">&#39;b</span><span style="color:#f92672">&gt;</span>(x: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Link<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span>, y: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#a6e22e">Foo</span>,
</span></span><span style="display:flex;"><span>													x2: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Link<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;b</span><span style="color:#f92672">&gt;</span>, y2: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;b</span> <span style="color:#a6e22e">Foo</span>) {
</span></span><span style="display:flex;"><span>		x.link <span style="color:#f92672">=</span> y;
</span></span><span style="display:flex;"><span>		x2.link <span style="color:#f92672">=</span> y2;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个的函数（可能不是特别有用）中，涉及两个不同的借用作用域。每个借用作用域都有它们自己的作用域公式要满足。</p>
<h2 id="为什么生命周期会造成困惑">为什么生命周期会造成困惑<a hidden class="anchor" aria-hidden="true" href="#为什么生命周期会造成困惑">#</a></h2>
<p>最后，我想解释一下为什么我认为 Rust 借用系统使用 <strong>生命周期</strong> 术语会造成困惑（同时避免在这片博文中使用它）。</p>
<p>当我们讨论借用时会涉及到不同类型的“生命周期”：</p>
<p>A. 资源所有者的生命周期（或者 被所有/被借用 资源
B. 被借用的生命周期，i.e. 从开始借用到最后返还
C. 每一个独立的借用者或被借用的指针的生命周期</p>
<p>当有人说“生命周期”，它可以指上面的任何一个。如果涉及多个资源和借用者就会变的更加困惑。
比如，在函数或者结构体生命中一个“命名的生命周期”指哪个？是 A、B 或者 C？</p>
<p>在我们的前一个 <code>max</code> 函数中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">max</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span>(x: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#a6e22e">Foo</span>, y: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#a6e22e">Foo</span>) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> x.f <span style="color:#f92672">&gt;</span> y.f { x } <span style="color:#66d9ef">else</span> { y }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>生命周期 <code>'a</code> 的意义是什么？它不应该是 A，因为涉及两个资源并且他们有不同的生命周期。也不可能是 C，
因为有三个借用者： <code>x</code> 、 <code>y</code> 和函数的返回值，并且他们也都有不同的生命周期。它是 B 吗？可能。
但是整个借用作用域并不是一个具体的对象，它怎么能有一个“生命周期”呢？称它为生命周期就会造成困惑。</p>
<p>另一种说法是它意味着对被借用资源的最小生命周期要求。一定程度上是有道理的，
但是我们怎么称呼最小生命周期要求“生命周期”？</p>
<p>所有权/借用概念自身已经够复杂了。我会说：对术语“生命周期”的困惑对学习这个概念造成了更多的莫名其妙。</p>
<p>P.S. 使用上面定义的 A、B 和 C，借用公式变成：</p>
<blockquote>
<p>A &gt;= B = C_1,UC_2U&hellip;UC_n</p>
</blockquote>
<h2 id="学习-rust-是值得的">学习 Rust 是值得的！<a hidden class="anchor" aria-hidden="true" href="#学习-rust-是值得的">#</a></h2>
<p>尽管借用和所有权可能让你花一些时间来掌握（to grok），但是是一个非常有趣的学习。Rust 尝试不用 GC
来实现内存安全，并且目前来看做的非常好。一些人说他们通过学习 Haskell 改变了他们编程的方式。
我认为Rust 同样也值得你学习。</p>
<p>希望这篇博文能提供一些帮助。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>


   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   
      
   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   


<hr />

  <div class="bl-section">
    <h3>Links to this note</h3>
    <br />
    <div class="backlinks">
      <ul>
       
          <article class="post-entry"> 
            <header class="entry-header">
              <h2>生命周期
              </h2>
            </header>
            <div class="entry-content">
              <p>生命周期 Rust 中的每一个引用都有其生命周期：引用有效的作用域。 大部分情况下生命周期都是隐式和自举的，在无法完成的情况下就需要我们通过生命周期泛型参数帮助编译器进行注解。 生命周期的主要目标是避免悬空指针。 生命周期泛型参数定义各个引用之间（参数和参数、参数和返回值）的关系，并不改变（延长）变量原本的生命周期 &amp;i32 // a reference &amp;&#39;a i32 // a reference with an explicit lifetime &amp;&#39;a mut i32 // a mutable reference with an explicit lifetime 参考以下代码
fn longest&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str { if x.len() &gt; y.len() { x } else { y } } 以上代码
标注生命周期 &#39;a 函数有两个引用参数，都使用生命周期 &#39;a 表示两个参数的生命周期必须一致（存活的周期一样长） 函数返回一个引用，并且存活的时间和生命周期 &#39;a 一致 以上指定不改变任何传入的引用的生命周期，我们只是要求借用检查器（borrow checker）检查这些约束。 也就是说借用检查器要检查传入的两个引用的生命周期必须一致，返回的引用的存活周期不能超过传入的引用的存活周期 思考 当函数返回一个引用时，返回值的生命周期注解要和参数的其中之一相匹配，否则那么引用就是指向里函数内创建的值（不能返回）。 也就是说返回引用时，引用的声明周期必须和参数（其一）相关。如果想要返回函数内创建的值最好返回一个有所有权的值类型。
结构体生命周期 如果结构体需要持有引用，需要在定义结构体时给每一个引用都加上生命周期注解。...</p>
            </div>
            <footer class="entry-footer"><span title='2020-06-29 18:04:00 +0800 +0800'>June 29, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gray King</footer>
            <a class="entry-link" aria-label="post link to 生命周期" href="https://notes.0081800.xyz/notes/20200629180413-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"></a>
          </article>
       
     </ul>
    </div>
  </div>


</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://notes.0081800.xyz/">Taking Smart Notes With Org-mode</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
